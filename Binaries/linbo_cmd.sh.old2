#!/bin/sh
# linbo_cmd - Backend worker script for LINBO
# (C) Klaus Knopper 2007
# License: GPL V2


help(){
echo "
 Invalid LINBO command: »$@«

 Syntax: linbo_cmd command option1 option2 ...

 Examples:
 start bootdev rootdev kernel initrd append
               - boot OS
 syncr server  cachedev baseimage image bootdev rootdev kernel initrd
               - sync cache from server AND partitions from cache
 syncl cachedev baseimage image bootdev rootdev kernel initrd
               - sync partitions from cache

 Image types: 
 .cloop - full block device (partition) image, cloop-compressed
          accompanied by a .list file for quicksync
 .rsync - incremental rsync batch, cloop-compressed
 " 1>&2
}

TMP="/tmp/linbo_cmd.$$.tmp"

cmd="$1"
[ -n "$cmd" ] && shift # Command args are now $@

# fstype partition
fstype(){
 phead="$(dd if="$1" bs=128k count=2 2>/dev/null)"
 local RC="$?"
 [ "$RC" = "0" ] || return "$RC"
 case "$phead" in
  *NTFS*) echo "ntfs" ;;
  *[Rr][Ee][Ii][Ss][Ee][Rr]*) echo "reiserfs" ;;
  *) echo "auto" ;;
 esac
 return 0
}


# mountpart partition destdir [options]
mountpart(){
 type=""
 for i in 1 2 3 4 5; do
  type="$(fstype $1)"
  local RC="$?"
  [ "$RC" = "0" ] && break
  [ "$i" = "5" ] && break
  echo "Partition $1 ist noch nicht verfügbar, versuche erneut..."
  sleep 2
 done
 [ "$RC" = "0" ] || { echo "Partition $1 ist nicht verfügbar, wurde die Platte schon partitioniert?" 1>&2; return "$RC"; }
 case "$type" in
  ntfs)
   OPTS=force,silent,umask=0,no_def_opts,allow_other,streams_interface=windows
   case "$3" in -r) OPTS="$OPTS,ro" ;; esac
   ntfs-3g -o "$OPTS" "$1" "$2"
   ;;
  *)
   mount $3 "$1" "$2"
   ;;
 esac
 return "$?"
}

# mountcache partition [options]
mountcache(){
 mountpart "$1" /cache $2
 return "$?"
}

# format dev fs
format(){
 case "$2" in
  swap) mkswap -v "$1" ;;
  reiserfs) mkreiserfs -f -f  "$1" ;;
  ext2) mke2fs -m 0 "$1" ;;
  ext3) mke2fs -m 0 -j "$1" ;;
 esac
}

# partition dev1 size1 id1 bootable1 filesystem dev2 ...
partition(){
 table="# Partition Table
unit: sectors
"
 formats=""
 disk="${1%%[1-9]*}"
 while [ "$#" -ge "5" ]; do
  dev="$1"
  [ -n "$dev" ] || continue
  size=""
  [ "$2" -gt 0 ] 2>/dev/null && size="$(($2 * 2))" # Kilobytes = sectors * 2
  table="$table
,$size,$3${4:+,*}"
  [ -n "$5" ] && formats="$formats $dev,$5"
  shift 5
 done
 dd if=/dev/zero of="$disk" bs=512 count=1
 sfdisk -uS -f "$disk" <<EOT
$table
EOT
 if [ "$?" = "0" ]; then
  sleep 2
  for i in $formats; do
   format "${i%%,*}" "${i##*,}"
  done
 fi
}

# start boot root kernel initrd append
start(){
 if mountpart "$1" /mnt -r ; then
  LOADED=""
  if [ -r /mnt/"$3" ]; then
   KERNEL="/mnt/$3"
   INITRD=""
   [ -n "$4" -a -r /mnt/"$4" ] && INITRD="--initrd=/mnt/$4"
   APPEND="$5"
   if [ -n "$2" ]; then
    case "$3" in [Gg][Rr][Uu][Bb]*) ;; *) APPEND="$APPEND root=$2" ;; esac
   fi
   kexec -l $INITRD --append="$APPEND" $KERNEL && LOADED="true"
  fi
  umount /mnt
 fi
 if [ -n "$LOADED" ]; then
  # We basically do a quick shutdown here.
  echo -n "c" >/dev/console
  killall5 -15
  sleep 2
  exec kexec -e
  sleep 10
 fi
}

# mk_cloop type inputdev imagename baseimage [timestamp]
# Ending .cloop or .rsync will be added, .list for .cloop will be created.
mk_cloop(){
 local RC=1
 case "$1" in
  partition) # full partition dump
   if mountpart "$2" /mnt -w ; then
    echo "Bereite Partition $2 für Komprimierung vor..."
    dd if=/dev/zero of=/mnt/zero.tmp bs=1024k 2>/dev/null
    sync ; sync
    rm -f /mnt/zero.tmp
    ( cd /mnt/ ; find . | sed 's,^\.,,' ) > "$3".list
    umount /mnt
   fi
   echo "Starte Kompression von $2 -> $3 (ganze Partition)."
   create_compressed_fs -B 131072 -L 1 -t 2 "$2" "$3".cloop
   RC="$?"
  ;;
  incremental)
   if mountpart "$2" /mnt -r ; then
    losetup -d /dev/cloop >/dev/null 2>&1
    if losetup /dev/cloop "$4"; then
     mkdir -p /cloop
     if mountpart /dev/cloop /cloop -r ; then
      echo "Starte Kompression von $2 -> $3 (inkrementell)."
      rsync -Haz --delete --only-write-batch="$3".rsync /mnt/ /cloop
      RC="$?"
      umount /cloop
     else
      RC="$?"
     fi
     losetup -d /dev/cloop
    else
     RC="$?"
    fi
    umount /mnt
   else
    RC="$?"
   fi
  ;; 
 esac
 return "$RC"
}

# INITIAL copy, slow
# cp_cloop basefile targetdev
cp_cloop(){
 local RC=1
 modprobe cloop && sleep 1
 losetup -d /dev/cloop 2>/dev/null
 losetup /dev/cloop "$1" || return "$?"
 dd if=/dev/cloop of="$2" bs=1024k
 RC="$?"
 losetup -d /dev/cloop
 return "$RC"
}

# INCREMENTAL/Synced
# sync_cloop imagefile targetdev
sync_cloop(){
 local RC=1
 if mountpart "$2" /mnt -w ; then
  case "$1" in
   *.[Rr][Ss][Yy]*)
    rsync -Haz --stats --read-batch="$1" /mnt ; RC="$?"
   ;;
   *.[CC][Ll][Oo]*)
    modprobe cloop && sleep 1
    losetup -d /dev/cloop 2>/dev/null
    if losetup /dev/cloop "$1"; then
     mkdir -p /cloop
     if mountpart /dev/cloop /cloop -r ; then
      list="${1%.*}".list
      FROMLIST=""
      [ -r "$list" ] && FROMLIST="--files-from=$list"
      rsync -Ha --stats $FROMLIST /cloop/ /mnt ; RC="$?"
      umount /cloop
     else
      RC="$?"
     fi
     losetup -d /dev/cloop
    else
     RC="$?"
    fi
   ;;
  esac
  umount /mnt
 else
  RC="$?"
 fi
 return "$RC"
}

# restore imagefile targetdev
restore(){
 IMAGE="$1"
 COMMAND=""
 OPTIONS=""
 COMPRESSED=""
 TARGET=""
 echo "Unpacking: $IMAGE $2"
 case "$IMAGE" in *.[Gg][Zz]) COMPRESSED="-z" ;; esac
 case "$IMAGE" in
  *.[Ii][Mm][Gg]*)
   if [ -n "$COMPRESSED" ]; then
    # rsync does not support to sync from compressed files yet :-(
    COMMAND="gzip"; OPTIONS="-dc"; TARGET="$2"; COMPRESSED=""
   else
    COMMAND="rsync"; OPTIONS="--progress -Hav"; TARGET="$2"
   fi
   ;;
  *.[Tt][Aa][Rr]*)
   COMMAND="/bin/tar"; OPTIONS="-x $COMPRESSED -C /mnt -f"; TARGET=""
   mountpart "$2" "/mnt" || return 1
   ;;
  *.[Cc][Ll][Oo]*)
   COMMAND="cp_cloop"; OPTIONS=""; TARGET="$2"
   ;;
 esac
 local RC=1
 if [ -n "$COMMAND" ]; then
  if [ "$COMMAND" = "gzip" ]; then
   $COMMAND $OPTIONS "$IMAGE" | dd of="$TARGET" bs=1024k
  else
   $COMMAND $OPTIONS "$IMAGE" $TARGET
  fi
  RC="$?"
 fi
 umount "/mnt" >/dev/null 2>&1
 return "$RC"
}

# sync cachedev baseimage image bootdev rootdev kernel initrd
syncl(){
 mountcache "$1" -r || return "$?"
 cd /cache
 for i in "$2" "$3"; do
  if [ -f "$i" ]; then
   restore "$i" "$5"
  fi
 done
 cd /
 umount /cache
}

# create cachedev imagefile bootdev rootdev kernel initrd
create(){
 [ -n "$2" -a -n "$1" -a -n "$4" ] || return 1
 mountcache "$1" || return "$?"
 cd /cache
 COMPRESSED=""
 local RC="1"
 echo "Erzeuge Image '$2' von Partition '$4'..."
 case "$2" in *.[Gg][Zz]) COMPRESSED="-z" ;; esac
 case "$2" in
  *.[Tt][Aa][Rr]*)
   mountpart "$4" /mnt -r || { echo "Root-Partition nicht mountbar." 1>&2; umount /cache; return 1; }
   /bin/tar -c -C /mnt $COMPRESSED -f /cache/"$2" . ; RC="$?"
   umount /mnt
   ;;
  *.[Ii][Mm][Gg]*)
   if [ -n "$COMPRESSED" ]; then
    dd if="$4" bs=1024k | gzip -9v >/cache/"$2" ; RC="$?"
   else
    dd if="$4" bs=1024k of=/cache/"$2" ; RC="$?"
   fi
   ;;
 esac
 cd /
 umount /cache
 return "$RC"
}

MULTICAST_SUPPORTED="yes"

# download server file
download(){
 local RC
 if [ -n "$MULTICAST_SUPPORTED" ]; then
  echo "TFTP Download $1 -> $2 per Multicast..."
  atftp --option "multicast 1" --get --remote-file "/$2" --local-file "$2" "$1"
  RC="$?"
  if [ "$RC" != 0 ]; then
   echo "Fehler $RC."
   MULTICAST_SUPPORTED=""
  fi
 fi
 if [ -z "$MULTICAST_SUPPORTED" ]; then # Retry
  echo "TFTP Download $1 -> $2 (normal)..."
  atftp --option "multicast 0" --get --remote-file "/$2" --local-file "$2" "$1"
  RC="$?"
  if [ "$RC" != 0 ]; then
   echo "Fehler $RC."
  fi
 fi
 return "$RC"
}

# getinfo file key
getinfo(){
 while read line; do
  key="${line%%=*}"
  if [ "$key" = "$2" ]; then
   echo "${line#*=}"
   return 0
  fi
 done <"$1"
 return 1
}

# Download info files, compare timestamps
# download_if_newer server file
download_if_newer(){
 local RC=0
 if [ ! -r "$2" -o ! -r "$2".info ]; then # File not there, download
  download "$1" "$2".info
  download "$1" "$2"
  RC="$?"
 else
  mv -f "$2".info "$2".info.old
  download "$1" "$2".info
  if [ -f "$2".info ]; then
   ts1="$(getinfo "$2".info.old timestamp)"
   ts2="$(getinfo "$2".info timestamp)"
   if [ "$ts1" -ge "$ts2" ] >/dev/null 2>&1; then
    echo "Keine neuere Datei, überspringe $2."
   else
    download "$1" "$2".list >/dev/null 2>&1
    download "$1" "$2".rsync >/dev/null 2>&1
    download "$1" "$2".reg >/dev/null 2>&1
    download "$1" "$2"
    RC="$?"
   fi
  else
   download "$1" "$2".list >/dev/null 2>&1
   download "$1" "$2".rsync >/dev/null 2>&1
   download "$1" "$2".reg >/dev/null 2>&1
   download "$1" "$2"
   RC="$?"
   mv -f "$2".info.old "$2".info
  fi
 fi
 return "$RC"
}

# Authenticate server user password
authenticate(){
 export RSYNC_PASSWORD="$3"
 rsync "rsync://$2@$1" >/dev/null 2>&1
 return "$?"
}

# upload server user password file destination
upload(){
 export RSYNC_PASSWORD="$3"
 FILES="$4"
 [ -r "${4}".info ] && FILES="$FILES ${4}".info
 [ -r "${4}".rsync ] && FILES="$FILES ${4}".rsync
 [ -r "${4}".reg ] && FILES="$FILES ${4}".reg
 rsync -Hav $FILES "rsync://$2@$1/$5"
 return "$?"
}
 
# Sync from server
# syncr server cachedev baseimage image bootdev rootdev kernel initrd
syncr(){
 mountcache "$2" || return "$?"
 cd /cache
 for i in "$3" "$4"; do
  [ -n "$i" ] && download_if_newer "$1" "$i"
 done
 cd /
 umount /cache
 shift 
 syncl "$@"
}

initcache(){
 server="$1"
 cachedev="$2"
 mountcache "$cachedev" || return "$?"
 cd /cache
 shift; shift
 for i in "$@"; do
  if [ -n "$i" ]; then
   download "$server" "$i".list >/dev/null 2>&1
   download "$server" "$i".rsync >/dev/null 2>&1
   download "$server" "$i".reg >/dev/null 2>&1
   download "$server" "$i"
  fi
 done
 cd /
 umount /cache
 update "$server" "$cachedev"
}

update(){
 server="$1"
 cachedev="$2"
 disk="${cachedev%%[1-9]*}"
 mountcache "$cachedev" || return "$?"
 cd /cache
 download "$server" linbo
 download "$server" linbofs.gz
 cat >/etc/lilo.conf <<EOT
lba32
vga=771
backup=/dev/null
boot=$disk
root=$cachedev
compact
ignore-table
nowarn
install=menu
map=/cache/boot.map
default=linbo

image=/cache/linbo
	label=linbo
	initrd=/cache/linbofs.gz
	append="quiet loglevel=0"
	read-write
EOT
 lilo -P ignore -v </dev/null
 cd /
 umount /cache
}

### Main ###
# DEBUG linbo_gui:
# echo -n "Running: $cmd "
# count=1
# for i in "$@"; do
#  echo -n "$((count++))=$i,"
# done
# echo ""
# sleep 1

case "$cmd" in
 create) create "$@" ;;
 start) start "$@" ;;
 partition) partition "$@" ;;
 initcache) initcache "$@" ;;
 sync) syncl "$@" ;;
 syncstart) syncr "$@"; start "$5" "$6" "$7" "$8" "$9" ;;
 syncr) syncr "$@" ;;
 update) update "$@" ;;
 *) help "$cmd" "$@" ;;
esac

sleep 1
