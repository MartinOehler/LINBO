Index: README_GRUB4DOS.txt
===================================================================
--- README_GRUB4DOS.txt	(revision 60)
+++ README_GRUB4DOS.txt	(working copy)
@@ -3117,4 +3117,144 @@
 virtual cdrom drive number and try again.
 
 
+******************************************************************************
+***                  The New Command CHECKRANGE                            ***
+******************************************************************************
 
+Checkrange checks whether or not the return value of a command is in the
+specified range or ranges.
+
+Usage:		checkrange  RANGE  COMMAND
+
+Here are some examples for RANGE:
+
+	3 is a range containing only the number 3
+	3:3 is equivalent to 3
+	3:8 is a range containing the numbers 3, 4, 5, 6, 7, 8
+	3,4,5,6,7,8 is equivalent to 3:8
+	3:5,6:8 is also equivalent to 3:8
+	3,4:7,8 is also equivalent to 3:8
+
+Note: You should not insert spaces into a range.
+
+Here is an example showing where the checkrange can be used:
+
+	checkrange 0x05,0x0F,0x85 parttype (hd0,1) || hide (hd0,1)
+
+which means: if (hd0,1) is not an extended partition, then hide it.
+
+
+******************************************************************************
+***                       The New Command TPM                              ***
+******************************************************************************
+
+The "tpm --init" uses 512-byte data at 0000:7C00 as buffer to initialise TPM.
+
+Before you boot VISTA's BOOTMGR, you might have to use the "tpm --init"
+command on some machines. Normally you want to issue the "tpm --init" command
+after a CHAINLOADER command.
+
+
+******************************************************************************
+***               Delimitors or comments between titles                    ***
+******************************************************************************
+
+It is possible to use titles as delimitors or comments. A title(or menu item)
+is called unbootable if all of its menu commands are not boot-sensitive.
+
+The following commands are boot-sensitive(and others are not boot-sensitive):
+
+	boot
+	bootp
+	chainloader
+	configfile
+	embed
+	commandline
+	halt
+	install
+	kernel
+	pxe
+	quit
+	reboot
+	setup
+
+An unbootable title will be skipped when the user presses the Up Arrow or Down
+Arrow keys. Even the unbootable menu item can get accessed(and executed) by
+using the Left Arrow and/or Right Arrow keys. Examples:
+
+	title This is an UNBOOTABLE entry(so this line is also a comment)
+		pause --wait=0 This title is a comment. Nothing to do.
+		pause --wait=0 You can use non-boot-sensitive commands here
+		pause --wait=0 of any kind and as many as you would like.
+		help
+		help root
+		help chainloader
+		help parttype
+		clear
+	title ------------------------------------------------------------
+		pause --wait=0 This title is a delimitor. Nothing to do.
+		pause --wait=0 You can use non-boot-sensitive commands here
+		pause --wait=0 of any kind and as many as you would like.
+		clear
+		help
+		help boot
+	title ============================================================
+		pause --wait=0 This title is a delimitor. Nothing to do.
+		pause --wait=0 You can use non-boot-sensitive commands here
+		pause --wait=0 of any kind and as many as you would like.
+		help
+		clear
+		help pause
+	title ************************************************************
+		pause --wait=0 This title is a delimitor. Nothing to do.
+		pause --wait=0 You can use non-boot-sensitive commands here
+		pause --wait=0 of any kind and as many as you would like.
+		help kernel
+		help
+		clear
+
+Note: An unbootable menu item must contain at least one command. If there
+are no commands for a title, the title will be simply discarded and disappear.
+
+
+******************************************************************************
+***                           Bifurcate drives                             ***
+******************************************************************************
+
+Some machines apply different actions to a drive between CHS and LBA mode.
+When you read sectors using standard BIOS call int13/AH=02h, you might find
+out the drive is a floppy. But when you read sectors using extended BIOS
+call(EBIOS) int13/AH=42h, you could know the drive is a cdrom. Such a drive
+is called bifurcate.
+
+A bifurcate drive can have two drive numbers: one is the normal BIOS drive
+number between 00 and FF in hexa, and this drive uses only CHS mode disk
+access(standard BIOS int13/AH=02h); the other is the normal BIOS drive number
+(Bitwise) OR'ed by 0x100(i.e., 256 in decimal), and this drive uses only
+LBA mode disk access(EBIOS int13/AH=42h). For example, if the drive 0x00
+(i.e., the first floppy) is bifurcate, then the drive (0x00) uses CHS mode
+to access its sectors, and the drive (0x100) uses LBA (meaning EBIOS) mode
+to access its sectors.
+
+The geometry command can report the disk access mode for bifurcate drives as
+BIF instead of the conventional CHS or LBA.
+
+Known bifurcate drives. Virtual PC and some real machines are found to create
+a bifurcate floppy drive when they boot from a floppy-emulation mode bootable
+cdrom. The "geometry (fd0)" will show
+
+	drive 0x00(BIF): C/H/S=...Sector Count/Size=.../512
+
+and "geometry (0x100)" will show
+
+	drive 0x100(BIF): C/H/S=...Sector Count/Size=.../2048
+
+Actually (0x100) can access the whole cdrom, you may "ls (0x100)/" and find
+your files on the cdrom(not the files inside the booted floppy image). Of
+course "ls (fd0)/" will list the files inside the booted floppy image.
+
+Note that only some (real or virtual) machines have this action, others
+will not produce bifurcate drives.
+
+
+
Index: patch-chinese.diff
===================================================================
--- patch-chinese.diff	(revision 60)
+++ patch-chinese.diff	(working copy)
@@ -1,6 +1,6 @@
 diff -Naur grub-0.97_splash/stage2/builtins.c grub-0.97_chinese/stage2/builtins.c
---- grub-0.97_splash/stage2/builtins.c	2008-06-24 00:32:15.000000000 +0800
-+++ grub-0.97_chinese/stage2/builtins.c	2008-07-10 23:13:11.000000000 +0800
+--- grub-0.97_splash/stage2/builtins.c	2008-10-03 18:19:00.000000000 +0800
++++ grub-0.97_chinese/stage2/builtins.c	2008-10-03 18:20:15.000000000 +0800
 @@ -74,6 +74,8 @@
  int fallback_entries[MAX_FALLBACK_ENTRIES];
  /* The number of current entry.  */
@@ -8,9 +8,9 @@
 +/* graphics file */
 +char graphics_file[64];
  /* The address for Multiboot command-line buffer.  */
- static char *mb_cmdline;
- static char kernel_option_video[64];
-@@ -443,7 +445,10 @@
+ static char *mb_cmdline;// = (char *) MB_CMDLINE_BUF;
+ static char kernel_option_video[64] = {0};/* initialize the first byte to 0 */
+@@ -426,7 +428,10 @@
    blocklist_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "blocklist FILE",
@@ -22,9 +22,9 @@
  };
  
  #if ! defined(GRUB_UTIL) && ! defined (STAGE1_5)
-@@ -1048,7 +1053,9 @@
+@@ -1031,7 +1036,9 @@
    boot_func,
-   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
    "boot",
 -  "Boot the OS/chain-loader which has been loaded."
 +  "Boot the OS/chain-loader which has been loaded.",
@@ -33,7 +33,7 @@
  };
  #endif /* ! GRUB_UTIL */
  
-@@ -1095,7 +1102,10 @@
+@@ -1078,7 +1085,10 @@
    "bootp [--with-configfile]",
    "Initialize a network device via BOOTP. If the option `--with-configfile'"
    " is given, try to load a configuration file specified by the 150 vendor"
@@ -45,7 +45,7 @@
  };
  #endif /* ! GRUB_UTIL */
  #endif /* SUPPORT_NETBOOT */
-@@ -1300,6 +1310,13 @@
+@@ -1230,6 +1240,13 @@
        if (grub_isspace (c) || (c >= ' ' && c <= '~'))
  	grub_putchar (c);
        else
@@ -59,7 +59,7 @@
  	grub_putchar ('?');
  #endif
        if (quit_print)
-@@ -1317,7 +1334,9 @@
+@@ -1247,7 +1264,9 @@
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "cat [--hex] [--skip=S] [--length=L] [--locate=STRING] FILE",
    "Print the contents of the file FILE, or print the locations "
@@ -70,7 +70,7 @@
  };
  
  
-@@ -1374,7 +1393,11 @@
+@@ -1304,7 +1323,11 @@
    "cdrom --add-io-ports=P | --init | --stop",
    "Initialise/stop atapi cdroms or set additional I/O ports for a possible atapi cdrom device."
    " The high word of P specifies the base register of the control block registers, and"
@@ -83,7 +83,7 @@
  };
  #endif /* ! defined(GRUB_UTIL) && ! defined (STAGE1_5) */
  
-@@ -2326,7 +2349,19 @@
+@@ -2287,7 +2310,19 @@
    " RAM boot file format. Use --disable-a20 if you wish to turn off"
    " A20 when transferring control to the boot image."
    " SL specifies length in bytes at the beginning of the image to be"
@@ -104,8 +104,8 @@
  };
  
  
-@@ -2418,7 +2453,9 @@
-   BUILTIN_MENU | BUILTIN_CMDLINE,
+@@ -2379,7 +2414,9 @@
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "cmp FILE1 FILE2",
    "Compare the file FILE1 with the FILE2 and inform the different values"
 -  " if any."
@@ -115,7 +115,7 @@
  };
  
  
-@@ -2552,7 +2589,17 @@
+@@ -2513,7 +2550,17 @@
    " cyan, red, magenta, brown, light-gray, dark-gray, light-blue,"
    " light-green, light-cyan, light-red, light-magenta, yellow and white."
    " But only the first eight names can be used for BG. You can prefix"
@@ -134,9 +134,9 @@
  };
  
  
-@@ -2674,7 +2721,9 @@
+@@ -2635,7 +2682,9 @@
    configfile_func,
-   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
    "configfile FILE",
 -  "Load FILE as the configuration file."
 +  "Load FILE as the configuration file.",
@@ -145,7 +145,7 @@
  };
  
  
-@@ -2715,7 +2764,9 @@
+@@ -2676,7 +2725,9 @@
    debug_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "debug [on | off | normal | status | INTEGER]",
@@ -156,7 +156,7 @@
  };
  
  
-@@ -2803,7 +2854,12 @@
+@@ -2764,7 +2815,12 @@
    " the key word `saved\' is specified, or to the entry number previously"
    " saved in the specified file FILE. When FILE is specified, all subsequent"
    " `savedefault\' commands will save default entry numbers into"
@@ -170,7 +170,7 @@
  #if 0
    "default [NUM | `saved']",
    "Set the default entry to entry number NUM (if not specified, it is"
-@@ -2848,7 +2904,10 @@
+@@ -2809,7 +2865,10 @@
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "device DRIVE DEVICE",
    "Specify DEVICE as the actual drive for a BIOS drive DRIVE. This command"
@@ -182,7 +182,7 @@
  };
  #endif /* GRUB_UTIL */
  
-@@ -2868,12 +2927,13 @@
+@@ -2829,12 +2888,13 @@
    dhcp_func,
    BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
    "dhcp",
@@ -199,7 +199,7 @@
  
  #ifdef SUPPORT_GRAPHICS
  extern char splashimage[64];
-@@ -2930,7 +2990,9 @@
+@@ -2891,7 +2951,9 @@
    splashimage_func,
    BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
    "splashimage FILE",
@@ -210,7 +210,7 @@
  };
  
  
-@@ -2960,7 +3022,10 @@
+@@ -2921,7 +2983,10 @@
    BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
    "foreground RRGGBB",
    "Sets the foreground color when in graphics mode."
@@ -222,7 +222,7 @@
  };
  
  
-@@ -2989,7 +3054,10 @@
+@@ -2950,7 +3015,10 @@
    BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
    "background RRGGBB",
    "Sets the background color when in graphics mode."
@@ -234,7 +234,18 @@
  };
  
  #endif /* SUPPORT_GRAPHICS */
-@@ -3130,7 +3198,9 @@
+@@ -3029,7 +3097,9 @@
+   checkrange_func,
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+   "checkrange RANGE COMMAND",
+-  "Return true if the return value of COMMAND is in RANGE and false otherwise."
++  "Return true if the return value of COMMAND is in RANGE and false otherwise.",
++  "checkrange RANGE COMMAND",
++  "\t如果COMMAND的返回值处于RANGE当中，则返回真；否则返回假。"
+ };
+ #ifndef GRUB_UTIL
+ /* checktime */
+@@ -3167,7 +3237,9 @@
    checktime_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "checktime min hour dom month dow",
@@ -245,7 +256,7 @@
  };
  #endif
  
-@@ -3150,7 +3220,9 @@
+@@ -3187,7 +3259,9 @@
    clear_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "clear",
@@ -256,7 +267,7 @@
  };
  
  
-@@ -3192,7 +3264,9 @@
+@@ -3229,7 +3303,9 @@
    displayapm_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "displayapm",
@@ -267,7 +278,7 @@
  };
  #endif
  
-@@ -3202,22 +3276,59 @@
+@@ -3239,22 +3315,59 @@
  displaymem_func (char *arg, int flags)
  {
    if (get_eisamemsize () != -1)
@@ -300,14 +311,14 @@
 +	{
 +      grub_printf (" Address Map BIOS Interface is present\n");
 +      grub_printf (" Lower memory: %uK, "
-+	       "Upper memory (to first chipset hole): %uK\n",
-+	       saved_mem_lower, saved_mem_upper);
+ 	       "Upper memory (to first chipset hole): %uK\n",
+ 	       saved_mem_lower, saved_mem_upper);
 +	}
 +#else
 +      grub_printf (" Address Map BIOS Interface is present\n");
 +      grub_printf (" Lower memory: %uK, "
- 	       "Upper memory (to first chipset hole): %uK\n",
- 	       saved_mem_lower, saved_mem_upper);
++	       "Upper memory (to first chipset hole): %uK\n",
++	       saved_mem_lower, saved_mem_upper);
 +#endif
 +}
  
@@ -331,7 +342,7 @@
        while (end_addr > (unsigned long) map)
  	{
  	  char *str;
-@@ -3226,6 +3337,16 @@
+@@ -3263,6 +3376,16 @@
  	    str = "Usable RAM";
  	  else
  	    str = "Reserved";
@@ -348,7 +359,7 @@
  	  grub_printf ("   %s:  Base Address:  0x%x X 4GB + 0x%x,\n"
  		       "      Length:   0x%x X 4GB + 0x%x bytes\n",
  		       str,
-@@ -3233,7 +3354,15 @@
+@@ -3270,7 +3393,15 @@
  		       (unsigned long) (map->BaseAddr & 0xFFFFFFFF),
  		       (unsigned long) (map->Length >> 32),
  		       (unsigned long) (map->Length & 0xFFFFFFFF));
@@ -365,7 +376,7 @@
  	  map = ((struct AddrRangeDesc *) (((int) map) + 4 + map->size));
  	}
      }
-@@ -3248,7 +3377,9 @@
+@@ -3285,7 +3416,9 @@
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "displaymem",
    "Display what GRUB thinks the system address space map of the"
@@ -376,7 +387,7 @@
  };
  
  
-@@ -3307,7 +3438,10 @@
+@@ -3344,7 +3477,10 @@
      BUILTIN_MENU | BUILTIN_CMDLINE,
      "dump FROM TO",
      "Dump the contents of the file FROM to the file TO. FROM must be"
@@ -388,7 +399,7 @@
    };
  #endif /* GRUB_UTIL */
  
-@@ -3454,7 +3588,11 @@
+@@ -3491,7 +3627,11 @@
    "embed STAGE1_5 DEVICE",
    "Embed the Stage 1.5 STAGE1_5 in the sectors after MBR if DEVICE"
    " is a drive, or in the \"bootloader\" area if DEVICE is a FFS partition."
@@ -401,7 +412,7 @@
  };
  
  
-@@ -3555,7 +3693,10 @@
+@@ -3598,7 +3738,10 @@
    " errors, instead of waiting for the user to do anything, it"
    " immediately starts over using the NUM entry (same numbering as the"
    " `default' command). This obviously won't help if the machine"
@@ -413,8 +424,8 @@
  #endif
  };
  
-@@ -3579,7 +3720,9 @@
-   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+@@ -3622,7 +3765,9 @@
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
  #if 1
    "commandline",
 -  "Enter command-line prompt mode."
@@ -424,7 +435,7 @@
  #endif
  };
  
-@@ -3949,7 +4092,12 @@
+@@ -3965,7 +4110,12 @@
    " If the option --set-root is used and FILENAME is found on a device, then"
    " stop the find immediately and set the device as new root."
    " If the option --ignore-floppies is present, the search will bypass all"
@@ -438,7 +449,7 @@
  };
  
  
-@@ -3993,7 +4141,9 @@
+@@ -4009,7 +4159,9 @@
    fstest_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "fstest [on | off | status]",
@@ -449,7 +460,7 @@
  };
  
  
-@@ -4118,7 +4268,10 @@
+@@ -4145,7 +4297,10 @@
    " the one of the heads, the one of the sectors and the one of the total"
    " sectors are set to CYLINDER, HEAD, SECTOR and TOTAL_SECTOR,"
    " respectively. If you omit TOTAL_SECTOR, then it will be calculated based"
@@ -461,8 +472,8 @@
  };
  
  
-@@ -4142,7 +4295,10 @@
-   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+@@ -4169,7 +4324,10 @@
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
    "halt [--no-apm]",
    "Halt your system. If APM is avaiable on it, turn off the power using"
 -  " the APM BIOS, unless you specify the option `--no-apm'."
@@ -473,7 +484,7 @@
  };
  
  
-@@ -4227,13 +4383,25 @@
+@@ -4254,13 +4412,25 @@
  	      if (substring (arg, (*builtin)->name, 0) < 1)
  		{
  		  char *doc = (*builtin)->long_doc;
@@ -502,7 +513,7 @@
  		    {
  		      int len = grub_strlen (doc);
  		      //int i;
-@@ -4270,7 +4438,9 @@
+@@ -4297,7 +4467,9 @@
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "help [--all] [PATTERN ...]",
    "Display helpful information about builtin commands. Not all commands"
@@ -513,7 +524,7 @@
  };
  
  
-@@ -4318,7 +4488,10 @@
+@@ -4345,7 +4517,10 @@
    "hide [PARTITION]",
    "Hide PARTITION by setting the \"hidden\" bit in"
    " its partition type code. The default partition is the current"
@@ -525,7 +536,7 @@
  };
  
  
-@@ -4363,6 +4536,10 @@
+@@ -4390,6 +4565,10 @@
    "Hide/unhide PARTITION by setting/clearing the \"hidden\" bit in"
    " its partition type code, or report the hidden status."
    " The default partition is the current root device."
@@ -536,7 +547,7 @@
  };
  
  
-@@ -4375,7 +4552,14 @@
+@@ -4402,7 +4581,14 @@
    
    if (! eth_probe ())
      {
@@ -552,7 +563,7 @@
        errnum = ERR_DEV_VALUES;
        return 0;
      }
-@@ -4416,7 +4600,10 @@
+@@ -4443,7 +4629,10 @@
    BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
    "ifconfig [--address=IP] [--gateway=IP] [--mask=MASK] [--server=IP]",
    "Configure the IP address, the netmask, the gateway and the server"
@@ -564,7 +575,7 @@
  };
  #endif /* SUPPORT_NETBOOT */
  
-@@ -4450,7 +4637,10 @@
+@@ -4477,7 +4666,10 @@
    "impsprobe",
    "Probe the Intel Multiprocessor Specification 1.1 or 1.4"
    " configuration table and boot the various CPUs which are found into"
@@ -576,7 +587,7 @@
  };
  #endif
  
-@@ -4482,7 +4672,9 @@
+@@ -4509,7 +4701,9 @@
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "initrd FILE [ARG ...]",
    "Load an initial ramdisk FILE for a Linux format boot image and set the"
@@ -587,7 +598,7 @@
  };
  
  
-@@ -5054,7 +5246,15 @@
+@@ -5081,7 +5275,15 @@
    " patched with the configuration filename REAL_CONFIG_FILE."
    " If the option `--force-lba' is specified, disable some sanity checks"
    " for LBA mode. If the option `--stage2' is specified, rewrite the Stage"
@@ -604,18 +615,7 @@
  };
  
  
-@@ -5098,7 +5298,9 @@
-   ioprobe_func,
-   BUILTIN_MENU | BUILTIN_CMDLINE,
-   "ioprobe DRIVE",
--  "Probe I/O ports used for the drive DRIVE."
-+  "Probe I/O ports used for the drive DRIVE.",
-+  "ioprobe DRIVE",
-+  "\t侦测指定设备的 I/O 端口号。"
- };
- #endif
- 
-@@ -5212,7 +5414,13 @@
+@@ -5191,7 +5393,13 @@
    " to suggest what type of kernel to be loaded. TYPE must be either of"
    " \"netbsd\", \"freebsd\", \"openbsd\", \"linux\", \"biglinux\" and"
    " \"multiboot\". The option --no-mem-option tells GRUB not to pass a"
@@ -630,9 +630,9 @@
  };
  
  
-@@ -5235,7 +5443,9 @@
+@@ -5214,7 +5422,9 @@
    lock_func,
-   BUILTIN_MENU | BUILTIN_CMDLINE,
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "lock",
 -  "Break a command execution unless the user is authenticated."
 +  "Break a command execution unless the user is authenticated.",
@@ -641,7 +641,7 @@
  };
    
  
-@@ -5259,7 +5469,9 @@
+@@ -5238,7 +5448,9 @@
    ls_func,
    BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
    "ls [FILE_OR_DIR]",
@@ -652,7 +652,7 @@
  };
  #endif /* STAGE1_5 */
  
-@@ -5361,7 +5573,9 @@
+@@ -5340,7 +5552,9 @@
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "makeactive [--status] [PART]",
    "Activate the partition PART. PART defaults to the current root device."
@@ -663,7 +663,7 @@
  };
  
  
-@@ -7413,7 +7627,29 @@
+@@ -7398,7 +7612,29 @@
    " address RESERV in 512-byte-sectors and ending at the end of this mem"
    " block(usually the end of physical mem). RD specifies the ramdisk number,"
    " and can be a BIOS drive number. ADDR specifies the base address of the"
@@ -694,7 +694,7 @@
  };
  #endif	/* ! GRUB_UTIL */
  
-@@ -7480,7 +7716,9 @@
+@@ -7465,7 +7701,9 @@
    md5crypt_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "md5crypt",
@@ -705,7 +705,7 @@
  };
  #endif /* USE_MD5_PASSWORDS */
  
-@@ -7529,7 +7767,11 @@
+@@ -7514,7 +7752,11 @@
    " interpretation of the file contents is made, so users of this"
    " command must know what the kernel in question expects). The"
    " rest of the line is passed as the \"module command line\", like"
@@ -718,7 +718,7 @@
  };
  
  
-@@ -7559,7 +7801,9 @@
+@@ -7544,7 +7786,9 @@
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "modulenounzip FILE [ARG ...]",
    "The same as `module', except that automatic decompression is"
@@ -729,7 +729,7 @@
  };
  
  #ifdef SUPPORT_GRAPHICS
-@@ -7593,7 +7837,9 @@
+@@ -7578,7 +7822,9 @@
    outline_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "outline [on | off | status]",
@@ -740,7 +740,7 @@
  };
  #endif /* SUPPORT_GRAPHICS */
  
-@@ -7627,7 +7873,9 @@
+@@ -7612,7 +7858,9 @@
    pager_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "pager [on | off | status]",
@@ -751,7 +751,7 @@
  };
  
  
-@@ -7948,7 +8196,13 @@
+@@ -7933,7 +8181,13 @@
    " If --active is used, the new partition will be active. START can be"
    " a contiguous file that will be used as the content/data of the new"
    " partition, in which case the LEN parameter is ignored, and TYPE can"
@@ -766,7 +766,7 @@
  };
  
  
-@@ -8058,7 +8312,10 @@
+@@ -8045,7 +8299,10 @@
    "parttype [PART] [TYPE]",
    "Change the type of the partition PART to TYPE. If TYPE is omitted, return "
    "the partition type of the specified device(instead of changing it). PART "
@@ -778,7 +778,7 @@
  };
  
  
-@@ -8136,7 +8393,13 @@
+@@ -8123,7 +8380,13 @@
    " instructions.  You can also use it in the script section, in"
    " which case it will ask for the password, before continueing."
    " The option --md5 tells GRUB that PASSWD is encrypted with"
@@ -793,7 +793,7 @@
  };
  
  
-@@ -8202,7 +8465,10 @@
+@@ -8189,7 +8452,10 @@
    pause_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_NO_ECHO,
    "pause [--wait=T] [MESSAGE ...]",
@@ -805,9 +805,9 @@
  };
  
  
-@@ -8236,7 +8502,9 @@
+@@ -8223,7 +8489,9 @@
    quit_func,
-   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
    "quit",
 -  "Exit from the GRUB shell."
 +  "Exit from the GRUB shell.",
@@ -816,9 +816,9 @@
  };
  #else
  /* quit */
-@@ -8329,7 +8597,9 @@
+@@ -8316,7 +8584,9 @@
    quit_func,
-   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
    "quit [--disable-a20]",
 -  "Go back to DOS if GRUB was previously launched from DOS."
 +  "Go back to DOS if GRUB was previously launched from DOS.",
@@ -827,7 +827,7 @@
  };
  #endif /* GRUB_UTIL */
  
-@@ -8359,7 +8629,9 @@
+@@ -8346,7 +8616,9 @@
    rarp_func,
    BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
    "rarp",
@@ -838,7 +838,7 @@
  };
  #endif /* ! GRUB_UTIL */
  #endif /* SUPPORT_NETBOOT */
-@@ -8387,7 +8659,9 @@
+@@ -8374,7 +8646,9 @@
    BUILTIN_MENU | BUILTIN_CMDLINE,
    "read ADDR",
    "Read a 32-bit value from memory at address ADDR and"
@@ -849,7 +849,7 @@
  };
  
  static int
-@@ -8417,7 +8691,9 @@
+@@ -8404,7 +8678,9 @@
    write_func,
    BUILTIN_MENU | BUILTIN_CMDLINE,
    "write ADDR VAL",
@@ -860,9 +860,9 @@
  };
  
  
-@@ -8437,7 +8713,9 @@
+@@ -8424,7 +8700,9 @@
    reboot_func,
-   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
    "reboot",
 -  "Reboot your system."
 +  "Reboot your system.",
@@ -871,7 +871,7 @@
  };
  #endif /* ! GRUB_UTIL */
  
-@@ -8692,6 +8970,78 @@
+@@ -8697,6 +8975,78 @@
    return next ? 1 : (saved_drive & 0x80);
  }
  
@@ -950,7 +950,7 @@
  static int
  root_func (char *arg, int flags)
  {
-@@ -8713,7 +9063,13 @@
+@@ -8718,7 +9068,13 @@
    " optional HDBIAS parameter is a number to tell a BSD kernel"
    " how many BIOS drive numbers are on controllers before the current"
    " one. For example, if there is an IDE disk and a SCSI disk, and your"
@@ -965,7 +965,7 @@
  };
  
  
-@@ -8734,7 +9090,12 @@
+@@ -8739,7 +9095,12 @@
    " is useful for when an OS is outside of the area of the disk that"
    " GRUB can read, but setting the correct root device is still"
    " desired. Note that the items mentioned in `root' which"
@@ -979,7 +979,7 @@
  };
  
  
-@@ -9071,7 +9432,13 @@
+@@ -9076,7 +9437,13 @@
    " `fallback' is used, next fallback entry is saved."
    " If T is not 0, prompt the user to confirm the write operation by"
    " pressing the Y key, and if no key-press detected within T seconds,"
@@ -994,7 +994,7 @@
  };
  
  
-@@ -9223,7 +9590,13 @@
+@@ -9228,7 +9595,13 @@
    " PARITY is the type of parity, which is one of `no', `odd' and `even'."
    " STOP is the length of stop bit(s). The option --device can be used only"
    " in the grub shell, which specifies the file name of a tty device. The"
@@ -1009,7 +1009,7 @@
  };
  #endif /* SUPPORT_SERIAL */
  
-@@ -9475,7 +9848,18 @@
+@@ -9480,7 +9853,18 @@
    " quote, doublequote, backquote, tilde, shift, backslash, bar, comma,"
    " less, period, greater, slash, question, alt, space, capslock, FX (X"
    " is a digit), and delete. If no argument is specified, reset key"
@@ -1029,7 +1029,7 @@
  };
  
  
-@@ -9806,7 +10190,14 @@
+@@ -9811,7 +10195,14 @@
    " doesn't work in LBA mode, specify the option `--force-lba'."
    " If you install GRUB under the grub shell and you cannot unmount the"
    " partition where GRUB images reside, specify the option `--stage2'"
@@ -1045,7 +1045,7 @@
  };
  
  
-@@ -10005,7 +10396,16 @@
+@@ -10010,7 +10401,16 @@
    " If you specify --no-edit, the BASH-like editing feature will be disabled."
    " If --timeout is present, this command will wait at most for SECS"
    " seconds. The option --lines specifies the maximum number of lines."
@@ -1063,7 +1063,7 @@
  };
  #endif /* SUPPORT_SERIAL || SUPPORT_HERCULES || SUPPORT_GRAPHICS */
  
-@@ -10121,7 +10521,13 @@
+@@ -10126,7 +10526,13 @@
    "Define the capabilities of your terminal. Use this command to"
    " define escape sequences, if it is not vt100-compatible."
    " You may use \\e for ESC and ^X for a control character."
@@ -1078,7 +1078,7 @@
  };
  #endif /* SUPPORT_SERIAL */
  	  
-@@ -10210,7 +10616,13 @@
+@@ -10215,7 +10621,13 @@
    " filepos=Y' reading has X and Y equal, then it is definitely"
    " consistent, and very likely works correctly subject to a"
    " consistent offset error. If this test succeeds, then a good next"
@@ -1093,7 +1093,7 @@
  };
  
  
-@@ -10334,7 +10746,9 @@
+@@ -10339,7 +10751,9 @@
    testvbe_func,
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "testvbe MODE",
@@ -1104,18 +1104,19 @@
  };
  
  static inline unsigned long vbe_far_ptr_to_linear (unsigned long ptr)
-@@ -10476,7 +10890,9 @@
-   setvbe_func,
-   BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-   "setvbe MODE_3D",
--  "Set the VBE mode MODE_3D(which is of the form 1024x768x32) for each subsequent kernel command-line."
-+  "Set the VBE mode MODE_3D(which is of the form 1024x768x32) for each subsequent kernel command-line.",
-+  "setvbe MODE_3D",
+@@ -10489,7 +10903,10 @@
+   "setvbe [MODE_3D]",
+   "Set the VBE mode MODE_3D(which is of the form 1024x768x32) for each subsequent kernel command-line."
+   " If no argument is specified, clear(nullify, invalidate) the video option"
+-  " string setup by the previous setvbe command."
++  " string setup by the previous setvbe command.",
++  "setvbe [MODE_3D]",
 +  "\t为后续的每个 kernel 命令行设置 VBE 模式 MODE_3D(例如 1024x768x32)。"
++  "\n\t若不指定参数，则清空由先前的 setvbe 命令所设置的视频选项字符串。"
  };
  
  
-@@ -10501,7 +10917,9 @@
+@@ -10514,7 +10931,9 @@
    tftpserver_func,
    BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
    "tftpserver IPADDR",
@@ -1126,7 +1127,18 @@
  };
  #endif /* SUPPORT_NETBOOT */
  
-@@ -10574,7 +10992,10 @@
+@@ -10589,7 +11008,9 @@
+   tpm_func,
+   BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+   "tpm --init",
+-  "Initialise TPM."
++  "Initialise TPM.",
++  "tpm --init",
++  "\t初始化TPM。"
+ };
+ #endif /* ! defined(GRUB_UTIL) && ! defined (STAGE1_5) */
+ 
+@@ -10618,7 +11039,10 @@
    "unhide [PARTITION]",
    "Unhide PARTITION by clearing the \"hidden\" bit in its"
    " partition type code. The default partition is the current"
@@ -1138,7 +1150,7 @@
  };
  
  
-@@ -10597,7 +11018,10 @@
+@@ -10641,7 +11065,10 @@
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "uppermem KBYTES",
    "Force GRUB to assume that only KBYTES kilobytes of upper memory are"
@@ -1150,7 +1162,7 @@
  };
  #endif
  
-@@ -10701,7 +11125,9 @@
+@@ -10745,7 +11172,9 @@
    BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
    "vbeprobe [MODE]",
    "Probe VBE information. If the mode number MODE is specified, show only"
@@ -1161,7 +1173,7 @@
  };
    
  
-@@ -10750,6 +11176,7 @@
+@@ -10795,6 +11224,7 @@
    &builtin_fallback,
    &builtin_find,
  #ifdef SUPPORT_GRAPHICS
@@ -1170,8 +1182,8 @@
  #endif
    &builtin_fstest,
 diff -Naur grub-0.97_splash/stage2/char_io.c grub-0.97_chinese/stage2/char_io.c
---- grub-0.97_splash/stage2/char_io.c	2008-05-22 02:21:32.000000000 +0800
-+++ grub-0.97_chinese/stage2/char_io.c	2008-07-10 23:13:11.000000000 +0800
+--- grub-0.97_splash/stage2/char_io.c	2008-09-27 09:49:23.000000000 +0800
++++ grub-0.97_chinese/stage2/char_io.c	2008-10-03 18:20:15.000000000 +0800
 @@ -390,8 +390,17 @@
  {
    cls ();
@@ -1191,9 +1203,9 @@
  
  #endif
 diff -Naur grub-0.97_splash/stage2/cmdline.c grub-0.97_chinese/stage2/cmdline.c
---- grub-0.97_splash/stage2/cmdline.c	2008-05-22 01:10:24.000000000 +0800
-+++ grub-0.97_chinese/stage2/cmdline.c	2008-07-10 23:13:11.000000000 +0800
-@@ -59,10 +59,23 @@
+--- grub-0.97_splash/stage2/cmdline.c	2008-10-03 18:03:05.000000000 +0800
++++ grub-0.97_chinese/stage2/cmdline.c	2008-10-03 18:20:15.000000000 +0800
+@@ -58,10 +58,23 @@
  void
  print_cmdline_message (int forever)
  {
@@ -1218,32 +1230,26 @@
  
  /* Find the builtin whose command name is COMMAND and return the
 diff -Naur grub-0.97_splash/stage2/graphics.c grub-0.97_chinese/stage2/graphics.c
---- grub-0.97_splash/stage2/graphics.c	2008-05-27 08:40:45.000000000 +0800
-+++ grub-0.97_chinese/stage2/graphics.c	2008-07-10 23:13:11.000000000 +0800
+--- grub-0.97_splash/stage2/graphics.c	2008-09-21 12:52:24.000000000 +0800
++++ grub-0.97_chinese/stage2/graphics.c	2008-10-03 18:20:15.000000000 +0800
 @@ -1,4 +1,5 @@
  /* graphics.c - graphics mode support for GRUB */
 +/* Chinese double-byte character support by Gandalf <f22_storm@163.com> */
  /* Implemented as a terminal type by Jeremy Katz <katzj@redhat.com> based
   * on a patch by Paulo Csar Pereira de Andrade <pcpa@conectiva.com.br>
   */
-@@ -44,6 +45,7 @@
- static unsigned char *VSHADOW4 = (unsigned char *)0x3B2C00;	//unsigned char VSHADOW4[38400];
- static unsigned char *VSHADOW8 = (unsigned char *)0x3BC200;	//unsigned char VSHADOW8[38400];
+@@ -30,6 +31,10 @@
+ #include <shared.h>
+ #include <graphics.h>
  
 +#define BASE_FONT_ADDR 0x500000;  /* Raw base address for Chinese Font.*/
- /* constants to define the viewable area */
- const int x0 = 0;
- const int x1 = 80;
-@@ -54,6 +56,8 @@
-  * scroll and the like */
- static unsigned short text[80 * 30];
- 
++
 +unsigned short stg2_ptborder = 0; /* Is called from stage2 drawing the menu border? */
 +
- /* why do these have to be kept here? */
- int foreground = (63 << 16) | (63 << 8) | (63), background = 0, border = 0;
+ static int saved_videomode = 0;
+ static unsigned char *font8x16 = 0;
  
-@@ -61,6 +65,9 @@
+@@ -62,6 +67,9 @@
  static int fontx = 0;
  static int fonty = 0;
  
@@ -1253,7 +1259,7 @@
  /* global state so that we don't try to recursively scroll or cursor */
  static int no_scroll = 0;
  
-@@ -117,11 +124,41 @@
+@@ -122,11 +130,41 @@
          saved_videomode = set_videomode (0x12);
      }
  
@@ -1298,7 +1304,7 @@
      }
  
      font8x16 = (unsigned char *) graphics_get_font (); /* code in asm.S */
-@@ -132,7 +169,7 @@
+@@ -137,7 +175,7 @@
      graphics_highlight_color = ((graphics_normal_color >> 4) | 
  				((graphics_normal_color & 0xf) << 4));
  
@@ -1307,7 +1313,7 @@
  }
  
  /* Leave graphics mode */
-@@ -143,6 +180,7 @@
+@@ -148,6 +186,7 @@
      {
          set_videomode (saved_videomode);
          graphics_inited = 0;
@@ -1315,7 +1321,7 @@
      }
  }
  
-@@ -514,25 +552,92 @@
+@@ -519,25 +558,92 @@
  
  static unsigned char chr[16 << 2];
  static unsigned char mask[16];
@@ -1348,7 +1354,7 @@
 +
      ch = text[fonty * 80 + fontx] & 0xff;
      if (ch != ' ' || ! disable_space_highlight)
- 	invert = (text[fonty * 80 + fontx] & 0xff00) != 0;
+ 	invert = (text[fonty * 80 + fontx] & /*0xff00*/ 0xffff0000) != 0;
 +
      pat = font8x16 + (ch << 4);
 +	
@@ -1409,7 +1415,7 @@
      if (set)
      {
          MapMask(15);
-@@ -621,6 +726,17 @@
+@@ -626,6 +732,17 @@
      }
  
      MapMask(15);
@@ -1428,9 +1434,9 @@
  
  #endif /* SUPPORT_GRAPHICS */
 diff -Naur grub-0.97_splash/stage2/shared.h grub-0.97_chinese/stage2/shared.h
---- grub-0.97_splash/stage2/shared.h	2008-06-07 08:13:28.000000000 +0800
-+++ grub-0.97_chinese/stage2/shared.h	2008-07-10 23:13:11.000000000 +0800
-@@ -395,6 +395,12 @@
+--- grub-0.97_splash/stage2/shared.h	2008-10-03 17:33:03.000000000 +0800
++++ grub-0.97_chinese/stage2/shared.h	2008-10-03 18:20:15.000000000 +0800
+@@ -399,6 +399,12 @@
   *  Below this should be ONLY defines and other constructs for C code.
   */
  
@@ -1443,7 +1449,7 @@
  /* multiboot stuff */
  
  #include "mb_header.h"
-@@ -979,6 +985,10 @@
+@@ -983,6 +989,10 @@
    char *short_doc;
    /* The long version of the documentation.  */
    char *long_doc;
@@ -1455,9 +1461,9 @@
  
  /* All the builtins are registered in this.  */
 diff -Naur grub-0.97_splash/stage2/stage2.c grub-0.97_chinese/stage2/stage2.c
---- grub-0.97_splash/stage2/stage2.c	2008-07-10 23:11:38.000000000 +0800
-+++ grub-0.97_chinese/stage2/stage2.c	2008-07-10 23:13:11.000000000 +0800
-@@ -281,6 +281,8 @@
+--- grub-0.97_splash/stage2/stage2.c	2008-10-03 18:16:44.000000000 +0800
++++ grub-0.97_chinese/stage2/stage2.c	2008-10-03 18:20:15.000000000 +0800
+@@ -284,6 +284,8 @@
    
    gotoxy (MENU_BOX_X - 2, y);
  
@@ -1466,7 +1472,7 @@
    grub_putchar (DISP_UL);
    for (i = 0; i < MENU_BOX_W + 1; i++)
      grub_putchar (DISP_HORIZ);
-@@ -306,6 +308,8 @@
+@@ -309,6 +311,8 @@
      grub_putchar (DISP_HORIZ);
    grub_putchar (DISP_LR);
  
@@ -1475,7 +1481,7 @@
    if (current_term->setcolorstate)
      current_term->setcolorstate (COLOR_STATE_STANDARD);
  }
-@@ -380,8 +384,14 @@
+@@ -535,8 +539,14 @@
  	      grub_timeout--;
  	      
  	      /* Print a message.  */
@@ -1492,7 +1498,7 @@
  	    }
  	}
      }
-@@ -397,27 +407,57 @@
+@@ -552,27 +562,57 @@
        else
  	print_border (MENU_BOX_Y - 1, MENU_BOX_H);
  
@@ -1560,7 +1566,7 @@
        else
  	print_entries (first_entry, entryno, menu_entries);
      }
-@@ -443,15 +483,27 @@
+@@ -598,15 +638,27 @@
  	  time2 = time1;
  
  	  if (current_term->flags & TERM_DUMB)
@@ -1593,7 +1599,7 @@
  	  
  	  grub_timeout--;
  	}
-@@ -467,7 +519,14 @@
+@@ -622,7 +674,14 @@
  	     since we're comming in here also on GRUB_TIMEOUT == -1 and
  	     hang in GETKEY */
  	  if (current_term->flags & TERM_DUMB)
Index: stage2/cmdline.c
===================================================================
--- stage2/cmdline.c	(revision 60)
+++ stage2/cmdline.c	(working copy)
@@ -26,7 +26,6 @@
 #endif
 
 //grub_jmp_buf restart_cmdline_env;
-void init_cmdline (void);
 
 /* Find the next word from CMDLINE and return the pointer. If
    AFTER_EQUAL is non-zero, assume that the character `=' is treated as
@@ -103,22 +102,9 @@
   return 0;
 }
 
-/* Initialize the data for the command-line.  */
-void
-init_cmdline (void)
-{
-  /* Initialization.  */
-  saved_drive = boot_drive;
-  saved_partition = install_partition;
-  current_drive = GRUB_INVALID_DRIVE;
-  count_lines = -1;
-  
-  /* Initialize the data for the builtin commands.  */
-  init_builtins ();
-  errnum = 0;
-}
-
 extern int commandline_func (char *arg, int flags);
+extern int errnum_func (char *arg, int flags);
+extern int checkrange_func (char *arg, int flags);
 
 /* Enter the command-line interface. HEAP is used for the command-line
    buffer. Return only if FOREVER is nonzero and get_cmdline returns
@@ -126,13 +112,16 @@
 void
 enter_cmdline (char *heap, int forever)
 {
-  if (debug == 0)
-      debug = 1;
+  if (! debug)
+      debug++;
 
   //grub_setjmp (restart_cmdline_env);
 
   /* Initialize the data and print a message.  */
-  init_cmdline ();
+  current_drive = GRUB_INVALID_DRIVE;
+  count_lines = -1;
+  kernel_type = KERNEL_TYPE_NONE;
+  errnum = 0;
   init_page ();
 #ifdef SUPPORT_DISKLESS
   print_network_configuration ();
@@ -144,9 +133,12 @@
     {
       struct builtin *builtin;
       char *arg;
+      grub_error_t errnum_old;
 
+      errnum_old = errnum;
       *heap = 0;
-      print_error ();
+      if (errnum && errorcheck)
+	print_error ();
       errnum = ERR_NONE;
 
       /* Get the command-line with the minimal BASH-like interface.  */
@@ -155,7 +147,10 @@
       echo_char = 0;
       readline = 1;
       if (get_cmdline (heap))
-	return;
+	{
+	  kernel_type = KERNEL_TYPE_NONE;
+	  return;
+	}
 
       /* If there was no command, grab a new one. */
       if (! heap[0])
@@ -181,6 +176,9 @@
       if (use_pager)
 	count_lines = 0;
       
+      if ((builtin->func) == errnum_func || (builtin->func) == checkrange_func)
+	errnum = errnum_old;
+
       /* find && and || */
 
       for (arg = skip_to (0, heap); *arg != 0; arg = skip_to (0, arg))
@@ -206,8 +204,11 @@
 		if (ret)
 		{
 			arg = skip_to (1, arg);
+			if ((builtin1->func) != errnum_func && (builtin1->func) != checkrange_func)
+				errnum = 0;
 			(builtin1->func) (arg, BUILTIN_CMDLINE);
-		}
+		} else
+			errnum = 0;
 		goto next;
 	} else if (*arg == '|' && arg[1] == '|' && (arg[2] == ' ' || arg[2] == '\t'))
 	{
@@ -226,8 +227,11 @@
 		if (! ret)
 		{
 			arg = skip_to (1, arg);
+			if ((builtin1->func) != errnum_func && (builtin1->func) != checkrange_func)
+				errnum = 0;
 			(builtin1->func) (arg, BUILTIN_CMDLINE);
-		}
+		} else
+			errnum = 0;
 		goto next;
 	}
       }
@@ -240,140 +244,3 @@
       count_lines = -1;
     }
 }
-
-/* Run an entry from the script SCRIPT. HEAP is used for the
-   command-line buffer. If an error occurs, return non-zero, otherwise
-   return zero.  */
-int
-run_script (char *script, char *heap)
-{
-  char *old_entry = 0;
-  char *cur_entry = script;
-  struct builtin *builtin = 0;
-  char *arg;
-
-  /* Initialize the data.  */
-  init_cmdline ();
-
-  errnum = 0;
-
-  while (1)
-    {
-      if (errnum && errorcheck)
-	break;
-
-      /* Copy the first string in CUR_ENTRY to HEAP.  */
-      errnum = ERR_NONE;
-      old_entry = cur_entry;
-      while (*cur_entry++)
-	;
-
-      grub_memmove (heap, old_entry, (int) cur_entry - (int) old_entry);
-      if (! *heap)
-	{
-	  /* If there is no more command in SCRIPT...  */
-
-	  /* If any kernel is not loaded, just exit successfully.  */
-	  if (kernel_type == KERNEL_TYPE_NONE)
-	    return 0;	/* return to main menu. */
-
-	  /* Otherwise, the command boot is run implicitly.  */
-	  grub_memmove (heap, "boot", 5);
-	}
-
-      /* Find a builtin.  */
-      builtin = find_command (heap);
-      if (! builtin)
-	{
-	  grub_printf ("%s\n", old_entry);
-	  continue;
-	}
-/* now command echoing is considered no use for a successful command. */
-//      if (! (builtin->flags & BUILTIN_NO_ECHO))
-//	grub_printf ("%s\n", old_entry);
-
-      /* If BUILTIN cannot be run in the command-line, skip it.  */
-      if (! (builtin->flags & BUILTIN_CMDLINE))
-	{
-	  errnum = ERR_UNRECOGNIZED;
-	  continue;
-	}
-
-      /* Invalidate the cache, because the user may exchange removable
-	 disks.  */
-      buf_drive = -1;
-
-      /* find && and || */
-
-      for (arg = skip_to (0, heap); *arg != 0; arg = skip_to (0, arg))
-      {
-	struct builtin *builtin1;
-	int ret;
-	char *arg1;
-	arg1 = arg;
-        if (*arg == '&' && arg[1] == '&' && (arg[2] == ' ' || arg[2] == '\t'))
-        {
-		/* handle the AND operator */
-		arg = skip_to (0, arg);
-		builtin1 = find_command (arg);
-		if (! builtin1 || ! (builtin1->flags & BUILTIN_CMDLINE))
-		{
-			errnum = ERR_UNRECOGNIZED;
-			goto next;
-		}
-
-		*arg1 = 0;
-		ret = (builtin->func) (skip_to (1, heap), BUILTIN_SCRIPT);
-		*arg1 = '&';
-		if (ret)
-		{
-			arg = skip_to (1, arg);
-			(builtin1->func) (arg, BUILTIN_SCRIPT);
-		}
-		goto next;
-	} else if (*arg == '|' && arg[1] == '|' && (arg[2] == ' ' || arg[2] == '\t'))
-	{
-		/* handle the OR operator */
-		arg = skip_to (0, arg);
-		builtin1 = find_command (arg);
-		if (! builtin1 || ! (builtin1->flags & BUILTIN_CMDLINE))
-		{
-			errnum = ERR_UNRECOGNIZED;
-			goto next;
-		}
-
-		*arg1 = 0;
-		ret = (builtin->func) (skip_to (1, heap), BUILTIN_SCRIPT);
-		*arg1 = '|';
-		if (! ret)
-		{
-			arg = skip_to (1, arg);
-			(builtin1->func) (arg, BUILTIN_SCRIPT);
-		}
-		goto next;
-	}
-      }
-
-	/* Run BUILTIN->FUNC.  */
-	arg = (builtin->func) == commandline_func ? heap : skip_to (1, heap);
-	(builtin->func) (arg, BUILTIN_SCRIPT);
-next:
-      if (! *old_entry)	/* HEAP holds the implicit BOOT command */
-	break;
-    } /* while (1) */
-
-  /* If a fallback entry is defined, don't prompt a user's intervention.  */
-  
-  if (fallback_entryno < 0)
-    {
-      if (! (builtin->flags & BUILTIN_NO_ECHO))
-	grub_printf ("%s\n", heap);
-      print_error ();
-
-      grub_printf ("\nPress any key to continue...");
-      (void) getkey ();
-    }
-	  
-  errnum = ERR_NONE;
-  return 1;	/* use fallback. */
-}
Index: stage2/bios.c
===================================================================
--- stage2/bios.c	(revision 60)
+++ stage2/bios.c	(working copy)
@@ -32,6 +32,7 @@
 				  unsigned long *sectors);
 
 extern struct drive_map_slot hooked_drive_map[DRIVE_MAP_SIZE + 1];
+extern int drive_map_slot_empty (struct drive_map_slot item);
 
 /* Read/write NSEC sectors starting from SECTOR in DRIVE disk with GEOMETRY
    from/into SEGMENT segment. If READ is BIOSDISK_READ, then read it,
@@ -45,7 +46,7 @@
   int err;
   
   /* first, use EBIOS if possible */
-  if (geometry->flags & BIOSDISK_FLAG_LBA_EXTENSION)
+  if ((geometry->flags & BIOSDISK_FLAG_LBA_EXTENSION) && (! (geometry->flags & BIOSDISK_FLAG_BIFURCATE) || (drive & 0xFFFFFF00) == 0x100))
     {
       struct disk_address_packet
       {
@@ -92,7 +93,9 @@
       dap->reserved = 0;
       dap->buffer = segment << 16;
       
-      if (!(err = biosdisk_int13_extensions ((read + 0x42) << 8, drive, dap)))
+      err = biosdisk_int13_extensions ((read + 0x42) << 8, (unsigned char)drive, dap);
+
+      if (!err)
 	return 0;	/* success */
 
       /* bootable CD-ROM specification has no standard CHS-mode call */
@@ -105,6 +108,9 @@
 	return err;
       }
 
+      if (geometry->flags & BIOSDISK_FLAG_BIFURCATE)
+	return err;
+
     } /* if (geometry->flags & BIOSDISK_FLAG_LBA_EXTENSION) */
 
    /* try the standard CHS mode */
@@ -120,9 +126,6 @@
       head_offset = head % geometry->heads;
       cylinder_offset = head / geometry->heads;
       
-//      if (cylinder_offset >= geometry->cylinders)
-//	return BIOSDISK_ERROR_GEOMETRY;
-
       err = biosdisk_standard (read + 0x02, drive,
 			       cylinder_offset, head_offset, sector_offset,
 			       nsec, segment);
@@ -131,9 +134,7 @@
   return err;
 }
 
-/* Check bootable CD-ROM emulation status.  
- * Return 0 on failure. 
- */
+/* Check bootable CD-ROM emulation status. Return 0 on failure. */
 int
 get_cdinfo (int drive, struct geometry *geometry)
 {
@@ -161,6 +162,7 @@
   cdrp = (struct iso_spec_packet *)0x580;
   grub_memset (cdrp, 0, sizeof (struct iso_spec_packet));
   cdrp->size = sizeof (struct iso_spec_packet) - 16;
+
 #ifndef STAGE1_5
   if (debug > 1)
 	grub_printf (" int13/4B01(%X),", drive);
@@ -171,40 +173,29 @@
 	grub_printf ("err=%X,drive=%X, ", err, drive);
 #endif
 
-  if (drive == 0x7F && drive < cdrp->drive_no)
+  if (drive == 0x7F && drive < (unsigned long)(cdrp->drive_no))
 	drive = cdrp->drive_no;
 
   if (! err && cdrp->drive_no == drive && !(cdrp->media_type & 0x0F))
     {
-//    if ((cdrp.media_type & 0x0F) == 0)
-//	{
-          /* No-emulation mode bootable CD-ROM */
-          geometry->flags = BIOSDISK_FLAG_LBA_EXTENSION | BIOSDISK_FLAG_CDROM;
-          geometry->cylinders = 65536; // 0;
-          geometry->heads = 255; //1;
-          geometry->sectors = 15;
-          geometry->sector_size = 2048;
-          geometry->total_sectors = 65536 * 255 * 15; //MAXINT;
-	  return drive;
-//	}
-//    else
-//	{
-//	  /* Floppy or hard-disk emulation */
-//	  geometry->cylinders
-//	    = ((unsigned int) cdrp.cylinders
-//	       + (((unsigned int) (cdrp.sectors & 0xC0)) << 2));
-//	  geometry->heads = cdrp.heads;
-//	  geometry->sectors = cdrp.sectors & 0x3F;
-//	  geometry->sector_size = SECTOR_SIZE;
-//	  geometry->total_sectors = (geometry->cylinders
-//				     * geometry->heads
-//				     * geometry->sectors);
-//	  return -1;
-//	}
+	/* No-emulation mode bootable CD-ROM */
+	geometry->flags = BIOSDISK_FLAG_LBA_EXTENSION | BIOSDISK_FLAG_CDROM;
+	geometry->cylinders = 65536;
+	geometry->heads = 255;
+	geometry->sectors = 15;
+	geometry->sector_size = 2048;
+	geometry->total_sectors = 65536 * 255 * 15;
+	return drive;
     }
   return 0;	/* failure */
 }
 
+static unsigned long flags;
+static unsigned long cylinders;
+static unsigned long heads;
+static unsigned long sectors;
+
+
 /* Return the geometry of DRIVE in GEOMETRY. If an error occurs, return
    non-zero, otherwise zero.  */
 int
@@ -213,12 +204,7 @@
   int err;
   int version;
   unsigned long long total_sectors = 0, tmp = 0;
-  unsigned long flags;
-      
-  struct drive_parameters *drp;
 
-  drp = (struct drive_parameters *)0x580;
-
   if (drive == 0xffff)	/* memory disk */
     {
       unsigned long long total_mem_bytes;
@@ -275,7 +261,7 @@
 #if defined(GRUB_UTIL) || defined(STAGE1_5)
   if (drive == cdrom_drive)
 #else
-  if (drive == cdrom_drive || (drive >= min_cdrom_id && drive < min_cdrom_id + atapi_dev_count))
+  if (drive == cdrom_drive || (drive >= (unsigned char)min_cdrom_id && drive < (unsigned char)(min_cdrom_id + atapi_dev_count)))
 #endif
   {
 	/* No-emulation mode bootable CD-ROM */
@@ -290,17 +276,17 @@
 
   /* Clear the flags.  */
   flags = 0;
-  
+
 #ifdef GRUB_UTIL
 #define FIND_DRIVES 8
 #else
 #define FIND_DRIVES (*((char *)0x475))
 #endif
-      if (drive >= 0x80 + FIND_DRIVES /* || (version && (drive & 0x80)) */ )
+      if (((unsigned char)drive) >= 0x80 + FIND_DRIVES /* || (version && (drive & 0x80)) */ )
 #undef FIND_DRIVES
 	{
 	  /* Possible CD-ROM - check the status.  */
-	  if (get_cdinfo (drive, geometry))
+	  if (get_cdinfo ((unsigned char)drive, geometry))
 	    return 0;
 	}
       
@@ -310,14 +296,20 @@
 	unsigned long d;
 
 	/* check if the drive is virtual. */
-	d = drive;
+	d = (unsigned char)drive;
 	j = DRIVE_MAP_SIZE;		/* real drive */
 	if (! unset_int13_handler (1))
 	    for (j = 0; j < DRIVE_MAP_SIZE; j++)
 	    {
-		if (drive != hooked_drive_map[j].from_drive)
+		if (drive_map_slot_empty (hooked_drive_map[j]))
+		{
+			j = DRIVE_MAP_SIZE;	/* real drive */
+			break;
+		}
+
+		if (((unsigned char)drive) != hooked_drive_map[j].from_drive)
 			continue;
-		if ((hooked_drive_map[j].max_sector & 0x3F) == 1 && hooked_drive_map[j].start_sector == 0 && hooked_drive_map[j].sector_count <= 1)
+		if ((hooked_drive_map[j].max_sector & 0x3E) == 0 && hooked_drive_map[j].start_sector == 0 && hooked_drive_map[j].sector_count <= 1)
 		{
 			/* this is a map for the whole drive. */
 			d = hooked_drive_map[j].to_drive;
@@ -334,6 +326,18 @@
 		if (hd_geom[d].sector_size == 512 && hd_geom[d].sectors > 0 && hd_geom[d].sectors <= 63 && hd_geom[d].heads <= 256)
 		{
 			geometry->flags = hd_geom[d].flags;
+			if ((geometry->flags & BIOSDISK_FLAG_BIFURCATE) && (drive & 0xFFFFFF00) == 0x100)
+			{
+				if (geometry->flags & BIOSDISK_FLAG_CDROM)
+				{
+					geometry->cylinders = 65536;
+					geometry->heads = 255;
+					geometry->sectors = 15;
+					geometry->sector_size = 2048;
+					geometry->total_sectors = 65536 * 255 * 15;
+					return 0;
+				}
+			}
 			geometry->sector_size = hd_geom[d].sector_size;
 			geometry->total_sectors = hd_geom[d].total_sectors;
 			geometry->heads = hd_geom[d].heads;
@@ -345,6 +349,18 @@
 		if (fd_geom[d].sector_size == 512 && fd_geom[d].sectors > 0 && fd_geom[d].sectors <= 63 && fd_geom[d].heads <= 256)
 		{
 			geometry->flags = fd_geom[d].flags;
+			if ((geometry->flags & BIOSDISK_FLAG_BIFURCATE) && (drive & 0xFFFFFF00) == 0x100)
+			{
+				if (geometry->flags & BIOSDISK_FLAG_CDROM)
+				{
+					geometry->cylinders = 65536;
+					geometry->heads = 255;
+					geometry->sectors = 15;
+					geometry->sector_size = 2048;
+					geometry->total_sectors = 65536 * 255 * 15;
+					return 0;
+				}
+			}
 			geometry->sector_size = fd_geom[d].sector_size;
 			geometry->total_sectors = fd_geom[d].total_sectors;
 			geometry->heads = fd_geom[d].heads;
@@ -358,84 +374,121 @@
 #endif
 
 #ifndef STAGE1_5
-      if (debug > 1)      
-	grub_printf (" int13/41(%X),", drive);
+	if (debug > 1)      
+		grub_printf (" int13/41(%X),", drive);
 #endif
-      version = check_int13_extensions (drive);
+	version = check_int13_extensions ((unsigned char)drive);
 #ifndef STAGE1_5
-      if (debug > 1)      
-	grub_printf ("version=%X, ", version);
+	if (debug > 1)      
+		grub_printf ("version=%X, ", version);
 #endif
 
-//      err = 1;
-      
-      /* It is safe to clear out DRP.  */
-      grub_memset (drp, 0, sizeof (struct drive_parameters));
+	/* Set the LBA flag.  */
+	if (version & 1) /* support functions 42h-44h, 47h-48h */
+	{
+		flags = BIOSDISK_FLAG_LBA_EXTENSION;
+	}
+	total_sectors = 0;
 
-      /* Buggy KT133A(AWARD BIOS 6.00PG) does not return valid version.
-       * So we don't check version for now. - Tinybit
-       */
-
-      /* PhoenixBIOS 4.0 Revision 6.0 for ZF Micro might understand the
-	 greater buffer size for the "get drive parameters" int 13 call in 
-	 its own way.  Supposedly the BIOS assumes even bigger space is
-	 available and thus corrupts the stack. This is why we specify the  
-	 exactly necessary size of 0x42 bytes. */
-      drp->size = sizeof (struct drive_parameters) - 16;
-	  
 #ifndef STAGE1_5
-	  if (drive & 0x80)
-	  if (debug > 1)
-		grub_printf (" int13/48(%X),", drive);
+	if (debug > 1)
+		grub_printf (" int13/08(%X),", drive);
 #endif
-#if 1
-	  if (drive & 0x80)
-	    err = biosdisk_int13_extensions (0x4800, drive, drp);
-	  else
-#endif
-	    err = 0;
+
+	version = get_diskinfo_standard ((unsigned char)drive, &cylinders, &heads, &sectors);
+
 #ifndef STAGE1_5
-	  if (drive & 0x80)
-	  if (debug > 1)
-		grub_printf ("err=%X, C/H/S=%d/%d/%d, Sector Count/Size=%d/%d, ", err, drp->cylinders, drp->heads, drp->sectors, drp->total_sectors, drp->bytes_per_sector);
+	if (debug > 1)
+		grub_printf ("version=%X, C/H/S=%d/%d/%d, ", version, cylinders, heads, sectors);
 #endif
-	  if (! err)
-	    {
-		/* Set the LBA flag.  */
-		if (version & 1) /* support functions 42h-44h, 47h-48h */
-		{
-			flags = BIOSDISK_FLAG_LBA_EXTENSION;
-	      
-			/* Set the CDROM flag.  */
-			if (drp->bytes_per_sector == ISO_SECTOR_SIZE)
-				flags |= BIOSDISK_FLAG_CDROM;
-		}
-		total_sectors = drp->total_sectors;
-	    }
 
-
 #ifndef STAGE1_5
 	if (debug > 1)
-		grub_printf (" int13/08(%X),", drive);
+		grub_printf (" int13/02(%X),", drive);
 #endif
-	/* Don't pass GEOMETRY directly, but pass each element instead,
-		 so that we can change the structure easily.  */
-	version = get_diskinfo_standard ((unsigned char)drive, &geometry->cylinders, &geometry->heads, &geometry->sectors);
+
+	/* read the boot sector: int 13, AX=0x201, CX=1, DH=0 */
+	err = biosdisk_standard (0x02, (unsigned char)drive, 0, 0, 1, 1, 0x5F00/*SCRATCHSEG*/);
+
 #ifndef STAGE1_5
 	if (debug > 1)
-		grub_printf ("version=%X, C/H/S=%d/%d/%d, ", version, geometry->cylinders, geometry->heads, geometry->sectors);
+		grub_printf ("err=%X, ", err);
 #endif
-	if (version && err)
+
+	//version = 0;
+
+	/* try again using LBA */
+	if (flags & BIOSDISK_FLAG_LBA_EXTENSION)
+	{
+		struct disk_address_packet
+		{
+			unsigned char length;
+			unsigned char reserved;
+			unsigned short blocks;
+			unsigned long buffer;
+			unsigned long long block;
+
+			unsigned char dummy[16];
+		} __attribute__ ((packed)) *dap;
+
+		dap = (struct disk_address_packet *)0x580;
+
+		dap->length = 0x10;
+		dap->reserved = 0;
+		dap->blocks = 1;
+		dap->buffer = 0x5F80/*SCRATCHSEG*/ << 16;
+		dap->block = 0;
+
+		/* set a known value */
+		grub_memset ((char *)0x5F800, 0xEC, 0x800);
+		version = biosdisk_int13_extensions (0x4200, (unsigned char)drive, dap);
+		/* see if it is a big sector */
+		{
+			char *p;
+			for (p = (char *)0x5FA00; p < (char *)0x60000; p++)
+			{
+				if ((*p) != (char)0xEC)
+				{
+					flags |= BIOSDISK_FLAG_CDROM;
+					if (! err)
+						flags |= BIOSDISK_FLAG_BIFURCATE;
+					break;
+				}
+			}
+		}
+		if ((! version) && (! err))
+		{
+			if (grub_memcmp ((char *)0x5F000, (char *)0x5F800, 0x200))
+			{
+				flags |= BIOSDISK_FLAG_BIFURCATE;
+			}
+		}
+		if (err && ! (flags & BIOSDISK_FLAG_BIFURCATE) && !(flags & BIOSDISK_FLAG_CDROM))
+		{
+			grub_memmove ((char *)0x5F000, (char *)0x5F800, 0x200);
+		}
+
+	} /* if (geometry->flags & BIOSDISK_FLAG_LBA_EXTENSION) */
+
+	if (err && version)
 		return err; /* When we return with ERROR, we should not change the geometry!! */
-      
+
 	geometry->flags = flags;
-	geometry->sector_size = (drp->bytes_per_sector ? drp->bytes_per_sector : SECTOR_SIZE);
-	if (geometry->cylinders < drp->cylinders)
-	    geometry->cylinders = drp->cylinders;
-	if (geometry->heads < drp->heads)
-	    geometry->heads = drp->heads;
-	if (geometry->sectors < drp->sectors)
-	    geometry->sectors = drp->sectors;
+
+	if (err && (flags & BIOSDISK_FLAG_CDROM))
+	{
+		geometry->cylinders = 65536;
+		geometry->heads = 255;
+		geometry->sectors = 15;
+		geometry->sector_size = 2048;
+		geometry->total_sectors = 65536 * 255 * 15;
+		return 0;
+	}
+
+	geometry->cylinders = cylinders;
+	geometry->heads = heads;
+	geometry->sectors = sectors;
+	geometry->sector_size = SECTOR_SIZE;
 	if (geometry->heads > 256)
 	    geometry->heads = 256;
 	if (geometry->sectors * geometry->sector_size > 63 * 512)
@@ -447,88 +500,23 @@
 	    total_sectors = tmp;
 	geometry->total_sectors = total_sectors;
 
-#ifndef STAGE1_5
-	if (geometry->sector_size != SECTOR_SIZE) /* CD */
-		return 0;
-
-	/* workaround for buggy USB-bootable board QDI 848E.
-	 * try a further probe in the boot sector.
-	 */
-	if (debug > 1)
-		grub_printf (" int13/02(%X),", drive);
-	/* read the boot sector: int 13, AX=0x201, CX=1, DH=0 */
-	err = biosdisk_standard (0x02, drive, 0, 0, 1, 1, SCRATCHSEG);
-	if (debug > 1)
-		grub_printf ("err=%X, ", err);
-	if (err)
-	{
-		/* try again using LBA */
-		if (geometry->flags & BIOSDISK_FLAG_LBA_EXTENSION)
-		{
-			struct disk_address_packet
-			{
-				unsigned char length;
-				unsigned char reserved;
-				unsigned short blocks;
-				unsigned long buffer;
-				unsigned long long block;
-
-				unsigned char dummy[16];
-			} __attribute__ ((packed)) *dap;
-
-			dap = (struct disk_address_packet *)0x580;
-
-			dap->length = 0x10;
-			dap->reserved = 0;
-			dap->blocks = 1;
-			dap->buffer = SCRATCHSEG << 16;
-			dap->block = 0;
-
-			err = biosdisk_int13_extensions (0x4200, drive, dap);
-		} /* if (geometry->flags & BIOSDISK_FLAG_LBA_EXTENSION) */
-	}
-
-	if (err)
-		goto failure_probe_boot_sector;
-
 	/* successfully read boot sector */
 
+#ifndef STAGE1_5
 	if (drive & 0x80)
 	{
 		/* hard disk */
-		if ((err = probe_mbr((struct master_and_dos_boot_sector *)SCRATCHADDR, 0, total_sectors, 0)))
+		if ((err = probe_mbr((struct master_and_dos_boot_sector *)0x5F000/*SCRATCHADDR*/, 0, total_sectors, 0)))
 		{
-			if (debug > 0)
+			if (debug > 1)
 				grub_printf ("\nWarning: Unrecognized partition table for drive %X. Please rebuild it using\na Microsoft-compatible FDISK tool(err=%d). Current C/H/S=%d/%d/%d\n", drive, err, geometry->cylinders, geometry->heads, geometry->sectors);
 			goto failure_probe_boot_sector;
 		}
 		err = (int)"MBR";
 	}else{
 		/* floppy */
-		if (probe_bpb((struct master_and_dos_boot_sector *)SCRATCHADDR))
+		if (probe_bpb((struct master_and_dos_boot_sector *)0x5F000/*SCRATCHADDR*/))
 		{
-#if 0
-			/* try INT13/AH=48h here. This could hang on some buggy USB BIOSes. */
-
-			/* It is safe to clear out DRP.  */
-			grub_memset (drp, 0, sizeof (struct drive_parameters));
-			drp->size = sizeof (struct drive_parameters) - 16;
-
-			if (debug > 0)
-				grub_printf ("\nBPB geometry probe failed, so try int13/48(%X), but this could hang on buggy USB BIOSes...", drive);
-			err = biosdisk_int13_extensions (0x4800, drive, drp);
-			if (debug > 0)
-				grub_printf (" err=%X, C/H/S=%d/%d/%d, Sector Count/Size=%d/%d.\n", err, drp->cylinders, drp->heads, drp->sectors, drp->total_sectors, drp->bytes_per_sector);
-			if (drp->heads > 0 && drp->heads <= 256 && drp->sectors > 0 && drp->sectors <= 63)
-			{
-				geometry->sectors = drp->sectors;
-				geometry->heads = drp->heads;
-				geometry->cylinders = drp->cylinders;
-				geometry->total_sectors = drp->cylinders * drp->heads * drp->sectors;
-			}
-			if (geometry->total_sectors < drp->total_sectors)
-			    geometry->total_sectors = drp->total_sectors;
-#endif
 			goto failure_probe_boot_sector;
 		}
 
@@ -638,14 +626,20 @@
 	unsigned long d;
 
 	/* check if the drive is virtual. */
-	d = drive;
+	d = (unsigned char)drive;
 	j = DRIVE_MAP_SIZE;		/* real drive */
 	if (! unset_int13_handler (1))
 	    for (j = 0; j < DRIVE_MAP_SIZE; j++)
 	    {
-		if (drive != hooked_drive_map[j].from_drive)
+		if (drive_map_slot_empty (hooked_drive_map[j]))
+		{
+			j = DRIVE_MAP_SIZE;	/* real drive */
+			break;
+		}
+
+		if (((unsigned char)drive) != hooked_drive_map[j].from_drive)
 			continue;
-		if ((hooked_drive_map[j].max_sector & 0x3F) == 1 && hooked_drive_map[j].start_sector == 0 && hooked_drive_map[j].sector_count <= 1)
+		if ((hooked_drive_map[j].max_sector & 0x3E) == 0 && hooked_drive_map[j].start_sector == 0 && hooked_drive_map[j].sector_count <= 1)
 		{
 			/* this is a map for the whole drive. */
 			d = hooked_drive_map[j].to_drive;
@@ -681,6 +675,17 @@
 	    }
 	}
     }
+	if ((geometry->flags & BIOSDISK_FLAG_BIFURCATE) && (drive & 0xFFFFFF00) == 0x100)
+	{
+		if (geometry->flags & BIOSDISK_FLAG_CDROM)
+		{
+			geometry->cylinders = 65536;
+			geometry->heads = 255;
+			geometry->sectors = 15;
+			geometry->sector_size = 2048;
+			geometry->total_sectors = 65536 * 255 * 15;
+		}
+	}
 #endif
 
   return 0;
Index: stage2/fsys_ntfs.c
===================================================================
--- stage2/fsys_ntfs.c	(revision 60)
+++ stage2/fsys_ntfs.c	(working copy)
@@ -1041,15 +1041,16 @@
           (valueat(cur_pos,ofs,unsigned long)==0x490024) &&
           (valueat(cur_pos,ofs+4,unsigned long)==0x300033))
         {
-          if ((get_aflag(AF_ALST)) && (cur_pos[8]==0))
-            {
-              dbg_printf("$BITMAP should be non-resident when in attribute list\n");
-              goto error;
-            }
           if (cur_pos[8]==0)
             {
-              bitmap=(unsigned char*)(cur_pos+valueat(cur_pos,0x14,unsigned short));
               bitmap_len=valueat(cur_pos,0x10,unsigned long);
+              if (bitmap_len>4096)
+                {
+                  dbg_printf("Resident $BITMAP too large\n");
+                  goto error;
+                }
+              bitmap=(unsigned char*)cbuf;
+              memcpy((char *)bitmap,(char *)(cur_pos+valueat(cur_pos,0x14,unsigned short)),bitmap_len);
               break;
             }
           if (valueat(cur_pos,0x28,unsigned long)>4096)
Index: stage2/stage2.c
===================================================================
--- stage2/stage2.c	(revision 60)
+++ stage2/stage2.c	(working copy)
@@ -44,10 +44,8 @@
 /* preset_menu is defined in asm.S */
 #endif /* GRUB_UTIL */
 
-#if 1 || defined(PRESET_MENU_STRING) || defined(SUPPORT_DISKLESS)
+static unsigned long preset_menu_offset;
 
-static int preset_menu_offset;
-
 static int
 open_preset_menu (void)
 {
@@ -81,21 +79,6 @@
   return len;
 }
 
-static void
-close_preset_menu (void)
-{
-  /* Disable the preset menu.  */
-  preset_menu = 0;
-}
-
-#else /* ! PRESET_MENU_STRING && ! SUPPORT_DISKLESS */
-
-#define open_preset_menu()	0
-#define read_from_preset_menu(buf, max_len)	0
-#define close_preset_menu()
-
-#endif /* ! PRESET_MENU_STRING && ! SUPPORT_DISKLESS */
-
 #ifdef GRUB_UTIL
 #undef	DISP_UL		//218
 #undef	DISP_UR		//191
@@ -162,6 +145,7 @@
 print_entry (int y, int highlight, char *entry)
 {
   int x;
+  unsigned char c = (unsigned char)*entry;
 
   if (current_term->setcolorstate)
     current_term->setcolorstate (highlight ? COLOR_STATE_HIGHLIGHT : COLOR_STATE_NORMAL);
@@ -179,17 +163,26 @@
 #endif /* SUPPORT_GRAPHICS */
   for (x = MENU_BOX_X; x < MENU_BOX_E; x++)
     {
-      if (*entry && x <= MENU_BOX_W)
+      if (c && x <= MENU_BOX_W)
 	{
 	  if (x == MENU_BOX_W)
 	    grub_putchar (DISP_RIGHT);
 	  else
-	    grub_putchar (*entry++);
+	  {
+	    while (c && (c <= 0x0F))
+	      c = *(++entry);
+	    if (! c)
+		goto space_no_highlight;
+	    grub_putchar (c);
+	    c = *(++entry);
+	  }
 	}
       else
       {
+space_no_highlight:
 #ifdef SUPPORT_GRAPHICS
-	disable_space_highlight = 1;
+	if (! disable_space_highlight)
+	      disable_space_highlight = 1;
 #endif /* SUPPORT_GRAPHICS */
 	grub_putchar (' ');
       }
@@ -225,11 +218,19 @@
     {
       print_entry (MENU_BOX_Y + i, entryno == i, menu_entries);
 
+#if 1
+      if (*menu_entries)
+	while (*(menu_entries++));
+#else
+      /* find the ending nul of the entry. */
       while (*menu_entries)
 	menu_entries++;
 
+      /* 2 nul chars end the array, we continue to print the empty entry
+       * without increasing the MENU_ENTRIES pointer. */
       if (*(menu_entries - 1))
 	menu_entries++;
+#endif
     }
 
   gotoxy (MENU_BOX_E, MENU_BOX_Y - 1 + MENU_BOX_H/*size*/);
@@ -252,6 +253,7 @@
 print_entries_raw (int size, int first, char *menu_entries)
 {
   int i;
+  char *p;
 
   for (i = 0; i < MENU_BOX_W; i++)
     grub_putchar ('-');
@@ -260,9 +262,10 @@
   for (i = first; i < size; i++)
     {
       /* grub's printf can't %02d so ... */
-      if (i < 10)
-	grub_putchar (' ');
-      grub_printf ("%d: %s\n", i, get_entry (menu_entries, i, 0));
+      //if (i < 10)
+	//grub_putchar (' ');
+      p = get_entry (menu_entries, i, 0);
+      grub_printf ("%02d: %s\n", i, (((*p) & 0xF0) ? p : ++p));
     }
 
   for (i = 0; i < MENU_BOX_W; i++)
@@ -310,9 +313,169 @@
     current_term->setcolorstate (COLOR_STATE_STANDARD);
 }
 
+extern int commandline_func (char *arg1, int flags);
+extern int errnum_func (char *arg1, int flags);
+extern int checkrange_func (char *arg1, int flags);
+
+/* Run an entry from the script SCRIPT. HEAP is used for the
+   command-line buffer. If an error occurs, return non-zero, otherwise
+   return zero.  */
+static int
+run_script (char *script, char *heap)
+{
+  char *old_entry = 0;
+  char *cur_entry = script;
+  struct builtin *builtin = 0;
+  char *arg;
+  grub_error_t errnum_old;
+
+  /* Initialize the data.  */
+  //saved_drive = boot_drive;
+  //saved_partition = install_partition;
+  current_drive = GRUB_INVALID_DRIVE;
+  count_lines = -1;
+  
+  /* Initialize the data for the builtin commands.  */
+  kernel_type = KERNEL_TYPE_NONE;
+  errnum = 0;
+
+  while (1)
+    {
+      if (errnum && errorcheck)
+	break;
+
+      errnum_old = errnum;
+      /* Copy the first string in CUR_ENTRY to HEAP.  */
+      errnum = ERR_NONE;
+      old_entry = cur_entry;
+      while (*cur_entry++)
+	;
+
+      grub_memmove (heap, old_entry, (int) cur_entry - (int) old_entry);
+      if (! *heap)
+	{
+	  /* If there is no more command in SCRIPT...  */
+
+	  /* If any kernel is not loaded, just exit successfully.  */
+	  if (kernel_type == KERNEL_TYPE_NONE)
+	    return 0;	/* return to main menu. */
+
+	  /* Otherwise, the command boot is run implicitly.  */
+	  grub_memmove (heap, "boot", 5);
+	}
+
+      /* Find a builtin.  */
+      builtin = find_command (heap);
+      if (! builtin)
+	{
+	  grub_printf ("%s\n", old_entry);
+	  continue;
+	}
+/* now command echoing is considered no use for a successful command. */
+//      if (! (builtin->flags & BUILTIN_NO_ECHO))
+//	grub_printf ("%s\n", old_entry);
+
+      /* If BUILTIN cannot be run in the command-line, skip it.  */
+      if (! (builtin->flags & BUILTIN_CMDLINE))
+	{
+	  errnum = ERR_UNRECOGNIZED;
+	  continue;
+	}
+
+      /* Invalidate the cache, because the user may exchange removable
+	 disks.  */
+      buf_drive = -1;
+
+      if ((builtin->func) == errnum_func || (builtin->func) == checkrange_func)
+	errnum = errnum_old;
+
+      /* find && and || */
+
+      for (arg = skip_to (0, heap); *arg != 0; arg = skip_to (0, arg))
+      {
+	struct builtin *builtin1;
+	int ret;
+	char *arg1;
+	arg1 = arg;
+        if (*arg == '&' && arg[1] == '&' && (arg[2] == ' ' || arg[2] == '\t'))
+        {
+		/* handle the AND operator */
+		arg = skip_to (0, arg);
+		builtin1 = find_command (arg);
+		if (! builtin1 || ! (builtin1->flags & BUILTIN_CMDLINE))
+		{
+			errnum = ERR_UNRECOGNIZED;
+			goto next;
+		}
+
+		*arg1 = 0;
+		ret = (builtin->func) (skip_to (1, heap), BUILTIN_SCRIPT);
+		*arg1 = '&';
+		if (ret)
+		{
+			arg = skip_to (1, arg);
+			if ((builtin1->func) != errnum_func && (builtin1->func) != checkrange_func)
+				errnum = 0;
+			(builtin1->func) (arg, BUILTIN_SCRIPT);
+		} else
+			errnum = 0;
+		goto next;
+	} else if (*arg == '|' && arg[1] == '|' && (arg[2] == ' ' || arg[2] == '\t'))
+	{
+		/* handle the OR operator */
+		arg = skip_to (0, arg);
+		builtin1 = find_command (arg);
+		if (! builtin1 || ! (builtin1->flags & BUILTIN_CMDLINE))
+		{
+			errnum = ERR_UNRECOGNIZED;
+			goto next;
+		}
+
+		*arg1 = 0;
+		ret = (builtin->func) (skip_to (1, heap), BUILTIN_SCRIPT);
+		*arg1 = '|';
+		if (! ret)
+		{
+			arg = skip_to (1, arg);
+			if ((builtin1->func) != errnum_func && (builtin1->func) != checkrange_func)
+				errnum = 0;
+			(builtin1->func) (arg, BUILTIN_SCRIPT);
+		} else
+			errnum = 0;
+		goto next;
+	}
+      }
+
+	/* Run BUILTIN->FUNC.  */
+	arg = (builtin->func) == commandline_func ? heap : skip_to (1, heap);
+	(builtin->func) (arg, BUILTIN_SCRIPT);
+next:
+      if (! *old_entry)	/* HEAP holds the implicit BOOT command */
+	break;
+    } /* while (1) */
+
+  kernel_type = KERNEL_TYPE_NONE;
+
+  /* If a fallback entry is defined, don't prompt a user's intervention.  */
+  
+  if (fallback_entryno < 0)
+    {
+      if (! (builtin->flags & BUILTIN_NO_ECHO))
+	grub_printf ("%s\n", heap);
+      print_error ();
+
+      grub_printf ("\nPress any key to continue...");
+      (void) getkey ();
+    }
+	  
+  errnum = ERR_NONE;
+  return 1;	/* use fallback. */
+}
+
+static int fallbacked_entries;
+
 static void
-run_menu (char *menu_entries, char *config_entries, int num_entries,
-	  char *heap, int entryno)
+run_menu (char *menu_entries, char *config_entries, int num_entries, char *heap, int entryno)
 {
   int c, time1, time2 = -1, first_entry = 0;
   char *cur_entry = 0;
@@ -328,19 +491,11 @@
      invariant for TERM_DUMB: first_entry == 0  */
   if (! (current_term->flags & TERM_DUMB))
     {
-#if 0
-      while (entryno > 11)
-	{
-	  first_entry++;
-	  entryno--;
-	}
-#else
       if (entryno > MENU_BOX_H - 1)
 	{
 	  first_entry += entryno - (MENU_BOX_H - 1);
 	  entryno = MENU_BOX_H - 1;
 	}
-#endif
     }
 
   /* If the timeout was expired or wasn't set, force to show the menu
@@ -486,7 +641,7 @@
 
 	  /* We told them above (at least in SUPPORT_SERIAL) to use
 	     '^' or 'v' so accept these keys.  */
-	  if (c == KEY_UP/*16*/ || ((char)c) == '^')
+	  if (c == KEY_UP/*16*/ || c == KEY_LEFT || ((char)c) == '^')
 	    {
 	      temp_entryno = 0;
 	      if (current_term->flags & TERM_DUMB)
@@ -496,17 +651,29 @@
 		}
 	      else
 		{
+		  if (c == KEY_UP && num_entries > 0)
+		  {
+		      temp_entryno = first_entry + entryno;
+		      for (;;)
+		      {
+		          temp_entryno = (temp_entryno + num_entries - 1) % num_entries;
+		          if (temp_entryno == first_entry + entryno)
+			      goto done_key_handling;
+		          cur_entry = get_entry (menu_entries, temp_entryno, 0);
+		          if (*cur_entry != 0x08)
+		              goto check_update;
+		      }
+		  }
+
 		  if (entryno > 0)
 		    {
-		      print_entry (MENU_BOX_Y + entryno, 0,
-				   get_entry (menu_entries,
-					      first_entry + entryno,
-					      0));
+		      cur_entry = get_entry (menu_entries, first_entry + entryno, 0);
+		      /* un-highlight the current entry */
+		      print_entry (MENU_BOX_Y + entryno, 0, cur_entry);
 		      entryno--;
-		      print_entry (MENU_BOX_Y + entryno, 1,
-				   get_entry (menu_entries,
-					      first_entry + entryno,
-					      0));
+		      cur_entry = get_entry (menu_entries, first_entry + entryno, 0);
+		      /* highlight the previous entry */
+		      print_entry (MENU_BOX_Y + entryno, 1, cur_entry);
 		    }
 		  else if (first_entry > 0)
 		    {
@@ -520,7 +687,7 @@
 		    }
 		}
 	    }
-	  else if ((c == KEY_DOWN/*14*/ || ((char)c) == 'v')
+	  else if ((c == KEY_DOWN/*14*/ || c == KEY_RIGHT || ((char)c) == 'v')
 		   /* && first_entry + entryno + 1 < num_entries */)
 	    {
 	      temp_entryno = 0;
@@ -531,6 +698,20 @@
 		}
 	      else
 		{
+		  if (c == KEY_DOWN && num_entries > 0)
+		  {
+		      temp_entryno = first_entry + entryno;
+		      for (;;)
+		      {
+		          temp_entryno = (temp_entryno + 1) % num_entries;
+		          if (temp_entryno == first_entry + entryno)
+			      goto done_key_handling;
+		          cur_entry = get_entry (menu_entries, temp_entryno, 0);
+		          if (*cur_entry != 0x08)
+		              goto check_update;
+		      }
+		  }
+
 		  if (first_entry + entryno + 1 >= num_entries)
 		    {
 		      temp_entryno = 0;	/* loop backward to HOME */
@@ -538,15 +719,13 @@
 		    }
 		  if (entryno < MENU_BOX_H - 1)
 		    {
-		      print_entry (MENU_BOX_Y + entryno, 0,
-				   get_entry (menu_entries,
-					      first_entry + entryno,
-					      0));
+		      cur_entry = get_entry (menu_entries, first_entry + entryno, 0);
+		      /* un-highlight the current entry */
+		      print_entry (MENU_BOX_Y + entryno, 0, cur_entry);
 		      entryno++;
-		      print_entry (MENU_BOX_Y + entryno, 1,
-				   get_entry (menu_entries,
-					      first_entry + entryno,
-					      0));
+		      cur_entry = get_entry (menu_entries, first_entry + entryno, 0);
+		      /* highlight the next entry */
+		      print_entry (MENU_BOX_Y + entryno, 1, cur_entry);
 		    }
 		  else if (num_entries > MENU_BOX_H + first_entry)
 		    {
@@ -622,10 +801,14 @@
 	  else
 	      temp_entryno = 0;
 
+done_key_handling:
+
 	  gotoxy (MENU_BOX_E - 8, MENU_BOX_Y - 2);
 	  grub_printf ("%d  ", first_entry + entryno);
 	  gotoxy (MENU_BOX_E, MENU_BOX_Y + entryno);
 
+	  cur_entry = NULL;
+
 	  if (config_entries)
 	    {
 	      if ((((char)c) == '\n') || (((char)c) == '\r') || (((char)c) == 'b'/*6*/))
@@ -637,9 +820,7 @@
 		{
 		  if (! (current_term->flags & TERM_DUMB))
 		    print_entry (MENU_BOX_Y + entryno, 0,
-				 get_entry (menu_entries,
-					    first_entry + entryno,
-					    0));
+				 get_entry (menu_entries, first_entry + entryno, 0));
 
 		  /* insert after is almost exactly like insert before */
 		  if (((char)c) == 'o')
@@ -654,14 +835,11 @@
 		      c = 'O';
 		    }
 
-		  cur_entry = get_entry (menu_entries,
-					 first_entry + entryno,
-					 0);
+		  cur_entry = get_entry (menu_entries, first_entry + entryno, 0);
 
 		  if (((char)c) == 'O')
 		    {
-		      grub_memmove (cur_entry + 2, cur_entry,
-				    ((int) heap) - ((int) cur_entry));
+		      grub_memmove (cur_entry + 2, cur_entry, ((int) heap) - ((int) cur_entry));
 
 		      cur_entry[0] = ' ';
 		      cur_entry[1] = 0;
@@ -672,12 +850,9 @@
 		    }
 		  else if (num_entries > 0)
 		    {
-		      char *ptr = get_entry(menu_entries,
-					    first_entry + entryno + 1,
-					    0);
+		      char *ptr = get_entry(menu_entries, first_entry + entryno + 1, 0);
 
-		      grub_memmove (cur_entry, ptr,
-				    ((int) heap) - ((int) ptr));
+		      grub_memmove (cur_entry, ptr, ((int) heap) - ((int) ptr));
 		      heap -= (((int) ptr) - ((int) cur_entry));
 
 		      num_entries--;
@@ -691,8 +866,7 @@
 		  if (current_term->flags & TERM_DUMB)
 		    {
 		      grub_printf ("\n\n");
-		      print_entries_raw (num_entries, first_entry,
-					 menu_entries);
+		      print_entries_raw (num_entries, first_entry, menu_entries);
 		      grub_printf ("\n");
 		    }
 		  else
@@ -777,17 +951,13 @@
 		  if (config_entries)
 		    {
 		      new_heap = heap;
-		      cur_entry = get_entry (config_entries,
-					     first_entry + entryno,
-					     1);
+		      cur_entry = get_entry (config_entries, first_entry + entryno, 1);
 		    }
 		  else
 		    {
 		      /* safe area! */
 		      new_heap = heap + NEW_HEAPSIZE + 1;
-		      cur_entry = get_entry (menu_entries,
-					     first_entry + entryno,
-					     0);
+		      cur_entry = get_entry (menu_entries, first_entry + entryno, 0);
 		    }
 
 		  do
@@ -801,7 +971,7 @@
 		     but it doesn't hurt to do it always */
 		  *(new_heap++) = 0;
 
-		  if (config_entries)
+		  if (config_entries && new_num_entries)
 		    run_menu (heap, NULL, new_num_entries, new_heap, 0);
 		  else
 		    {
@@ -834,8 +1004,7 @@
 			    }
 
 			  /* align rest of commands properly */
-			  grub_memmove (cur_entry + j, cur_entry + i,
-					(int) heap - ((int) cur_entry + i));
+			  grub_memmove (cur_entry + j, cur_entry + i, (int) heap - ((int) cur_entry + i));
 
 			  /* copy command to correct area */
 			  grub_memmove (cur_entry, new_heap, j);
@@ -877,14 +1046,19 @@
 ////      (*current_term->shutdown)();
 ////      current_term = term_table; /* assumption: console is first */
 ////    }
-  
+
+  fallbacked_entries = 0;
   while (1)
     {
       if (debug > 0)
       {
 	if (config_entries)
-		printf ("  Booting \'%s\'\n\n",
-			get_entry (menu_entries, first_entry + entryno, 0));
+	{
+		char *p;
+
+		p = get_entry (menu_entries, first_entry + entryno, 0);
+		printf ("  Booting \'%s\'\n\n", (((*p) & 0xF0) ? p : ++p));
+	}
 	else
 		printf ("  Booting command-list\n\n");
       }
@@ -895,23 +1069,23 @@
       /* Set CURRENT_ENTRYNO for the command "savedefault".  */
       current_entryno = first_entry + entryno;
       
-      if (run_script (cur_entry, heap))
-	{
-	  if (fallback_entryno >= 0)
-	    {
-	      cur_entry = NULL;
-	      first_entry = 0;
-	      entryno = fallback_entries[fallback_entryno];
-	      fallback_entryno++;
-	      if (fallback_entryno >= MAX_FALLBACK_ENTRIES
-		  || fallback_entries[fallback_entryno] < 0)
-		fallback_entryno = -1;
-	    }
-	  else
-	    break;
-	}
-      else
+      if (! run_script (cur_entry, heap))
 	break;
+      if (fallback_entryno < 0)
+	break;
+      cur_entry = NULL;
+      first_entry = 0;
+      entryno = fallback_entries[fallback_entryno];
+      fallback_entryno++;
+      if (fallback_entryno >= MAX_FALLBACK_ENTRIES || fallback_entries[fallback_entryno] < 0)
+	fallback_entryno = -1;
+      fallbacked_entries++;
+      if (fallbacked_entries > num_entries)
+      {
+	printf ("\nEndless fallback loop detected(entry=%d)! Press any key to exit...", current_entryno);
+	(void) getkey ();
+	break;
+      }
     }
 
 //  /* if we get back here, we should go back to what our term was before */
@@ -927,77 +1101,144 @@
 
 
 static int
-get_line_from_config (char *cmdline, int max_len, int read_from_file)
+get_line_from_config (char *cmdline, int max_len, int preset)
 {
-  int pos = 0, literal = 0, comment = 0;
-  char c;  /* since we're loading it a byte at a time! */
+    unsigned long pos = 0, info = 0;//literal = 0, comment = 0;
+    char c;  /* since we're loading it a byte at a time! */
   
-  while (1)
+    while (1)
     {
-      if (read_from_file)
+#if 0
+	/* Skip UTF-8 Byte Order Mark: EF BB BF */
 	{
-	  if (! grub_read (&c, 1))
-	    break;
+	    unsigned long menu_offset;
+
+	    menu_offset = read_from_file ? filepos : preset_menu_offset;
+	    if (menu_offset == 0)
+	    {
+		/* read 3 bytes, check UTF-8 Byte Order Mark: EF BB BF */
+		if (read_from_file)
+		{
+			if (3 != grub_read (&menu_offset, 3))
+			{
+				filepos = 0;
+				break;
+			}
+			if (menu_offset != 0xBFBBEF)
+			{
+				filepos = 0;
+			}
+		}
+		else
+		{
+			if (3 != read_from_preset_menu (&menu_offset, 3))
+			{
+				preset_menu_offset = 0;
+				break;
+			}
+			if (menu_offset != 0xBFBBEF)
+			{
+				preset_menu_offset = 0;
+			}
+		}
+	    }
 	}
-      else
+#endif
+
+	if (preset)
 	{
-	  if (! read_from_preset_menu (&c, 1))
-	    break;
+	    if (! read_from_preset_menu (&c, 1))
+		break;
 	}
+	else
+	{
+	    if (! grub_read (&c, 1))
+		break;
+	}
 
-      /* Skip all carriage returns.  */
-      if (c == '\r')
-	continue;
+	///* Skip UTF-8 Byte Order Mark: EF BB BF */
+	//if ((c & 0x80) && pos < 3)
+	//    continue;
 
-      /* Replace tabs with spaces.  */
-      if (c == '\t')
-	c = ' ';
+	/* Replace CR with LF.  */
+	if (c == '\r')
+	    c = '\n';
 
-      /* The previous is a backslash, then...  */
-      if (literal)
+	/* Replace tabs with spaces.  */
+	if (c == '\t')//( || c == '\f' || c == '\v')
+	    c = ' ';
+
+	/* all other non-printable chars are illegal. */
+	if (c != '\n' && (unsigned char)c < ' ')
+	    break;
+
+	/* The previous is a backslash, then...  */
+	if (info & 1)	/* bit 0 for literal */
 	{
-	  /* If it is a newline, replace it with a space and continue.  */
-	  if (c == '\n')
+	    /* If it is a newline, replace it with a space and continue.  */
+	    if (c == '\n')
 	    {
-	      c = ' ';
-	      
-	      /* Go back to overwrite a backslash.  */
-	      if (pos > 0)
-		pos--;
+		c = ' ';
+
+		/* Go back to overwrite a backslash.  */
+		if (pos > 0)
+		    pos--;
 	    }
-	    
-	  literal = 0;
+
+	    info &= 0xFFFFFFFE;	//literal = 0;
 	}
-	  
-      /* translate characters first! */
-      if (c == '\\' && ! literal)
-	literal = 1;
 
-      if (comment)
+	///* Replace semi-colon with LF.  */
+	//if (c == ';')
+	//    c = '\n';
+
+	/* translate characters first! */
+	if (c == '\\')
+	    info |= 1;	//literal = 1;
+
+	if (info & 2)	/* bit 1 for comment */
 	{
-	  if (c == '\n')
-	    comment = 0;
+	    if (c == '\n')
+		info &= 0xFFFFFFFD;	//comment = 0;
+	    /* Skip all comment chars upto end of line. */
 	}
-      else if (! pos)
+	else if (! pos)
 	{
-	  if (c == '#')
-	    comment = 1;
-	  else if ((c != ' ') && (c != '\n'))
-	    cmdline[pos++] = c;
+	    /* At the very beginning of the line... */
+	    if (c == '#')
+	    {
+		info |= 2;	//comment = 1;
+		/* Skip the comment char. */
+	    }
+	    else
+	    {
+		/* Skip non-printable chars, including the UTF-8 Byte Order Mark: EF BB BF */
+		if ((unsigned char)c > ' ' && (unsigned char)c <= 0x7F) //((c != ' ') && (c != '\t') && (c != '\n') && (c != '\r'))
+		    cmdline[pos++] = c;
+	    }
 	}
-      else
+	else
 	{
-	  if (c == '\n')
-	    break;
+	    if (c == '\n')
+		break;
 
-	  if (pos < max_len)
-	    cmdline[pos++] = c;
+	    if (!(info & 4) && ((c & 0x80) || pos > 31))	/* bit 2 for argument */
+		break;
+
+	    if (pos < max_len)
+	    {
+		if (!(info & 4) && c == '=')
+		    c = ' ';
+		if (c == ' ')
+		    info |= 4;	//argument = 1;
+		cmdline[pos++] = c;
+	    }
 	}
     }
 
-  cmdline[pos] = 0;
+    cmdline[pos] = 0;
 
-  return pos;
+    return pos;
 }
 
 //void
@@ -1014,438 +1255,443 @@
   num_entries = 0;
   config_entries = (char *) init_free_mem_start;//mbi.drives_addr + mbi.drives_length;
   cur_entry = config_entries;
-  menu_entries = (char *) MENU_BUF;
-  init_config ();
+
+  /* Initialize the data for the configuration file.  */
+  default_entry = 0;
+  password = 0;
+  fallback_entryno = -1;
+  fallback_entries[0] = -1;
+  grub_timeout = -1;
 }
   
+extern int use_config_file;
+static unsigned long attr = 0;
 
 /* This is the starting function in C.  */
 void
 cmain (void)
 {
-  char *kill_buf = (char *) KILL_BUF;
-
 #ifdef GRUB_UTIL
-  /* Initialize the environment for restarting Stage 2.  */
-  grub_setjmp (restart_env);
+    /* Initialize the environment for restarting Stage 2.  */
+    grub_setjmp (restart_env);
 #endif /* GRUB_UTIL */
   
-  /* Initialize the kill buffer.  */
-  *kill_buf = 0;
-
 #ifndef GRUB_UTIL
-  debug = debug_boot + 1;
-  pxe_detect();
+    debug = debug_boot + 1;
+    pxe_detect();
 #endif /* ! GRUB_UTIL */
   
-  /* Never return.  */
-  for (;;)
+    /* Never return.  */
+restart:
+    reset ();
+      
+    /* Here load the configuration file.  */
+      
+    if (! use_config_file)
+	goto done_config_file;
+
+    /* Get a saved default entry if possible.  */
+    saved_entryno = 0;
+    if (*config_file)
     {
-      extern int use_config_file;
-      int is_opened, is_preset;
-      int i;
+	char *default_file = (char *) DEFAULT_FILE_BUF;
 
-      reset ();
-      
-      /* Here load the configuration file.  */
-      
-//#ifdef GRUB_UTIL
-      if (use_config_file)
-//#endif /* GRUB_UTIL */
+	*default_file = 0;	/* initialise default_file */
+	grub_strncat (default_file, config_file, DEFAULT_FILE_BUFLEN);
 	{
-	  char *default_file = (char *) DEFAULT_FILE_BUF;
-	  
-	  /* Get a saved default entry if possible.  */
-	  saved_entryno = 0;
-	  if (*config_file)
-	  {
-	    *default_file = 0;	/* initialise default_file */
-	    grub_strncat (default_file, config_file, DEFAULT_FILE_BUFLEN);
+	    int i;
 	    for (i = grub_strlen (default_file); i >= 0; i--)
-	      if (default_file[i] == '/')
-	        {
-		  //i++;
-		  break;
-	        }
+		if (default_file[i] == '/')
+			break;
 	    default_file[++i] = 0;
 	    grub_strncat (default_file + i, "default", DEFAULT_FILE_BUFLEN - i);
+	}
+	if (debug > 1)
+	    grub_printf("Open %s ... ", default_file);
+	DEBUG_SLEEP
+
+	if (grub_open (default_file))
+	{
+	    char buf[10]; /* This is good enough.  */
+	    char *p = buf;
+	    int len;
+	  
 	    if (debug > 1)
-		grub_printf("Open %s ... ", default_file);
-//	i=grub_open (default_file);
-//	printf("default_file ok=%s\n", default_file);
-//	for (;;);
-      DEBUG_SLEEP
+		grub_printf("Read file: ", default_file);
+	    len = grub_read (buf, sizeof (buf));
+	    if (debug > 1)
+		grub_printf("len=%d\n", len);
+	    if (len > 0)
+	    {
+		buf[sizeof (buf) - 1] = 0;
+		safe_parse_maxint (&p, &saved_entryno);
+	    }
 
-	    if (grub_open (default_file))
-	      {
-	        char buf[10]; /* This is good enough.  */
-	        char *p = buf;
-	        int len;
-	      
-		if (debug > 1)
-			grub_printf("Read file: ", default_file);
-	        len = grub_read (buf, sizeof (buf));
-		if (debug > 1)
-			grub_printf("len=%d\n", len);
-	        if (len > 0)
-		  {
-		    buf[sizeof (buf) - 1] = 0;
-		    safe_parse_maxint (&p, &saved_entryno);
-		  }
+	    grub_close ();
+	}
+	else if (debug > 1)
+	    grub_printf("failure.\n", default_file);
+	DEBUG_SLEEP
+    }
+    errnum = ERR_NONE;
 
-	        grub_close ();
-	      }
-	    else if (debug > 1)
-		grub_printf("failure.\n", default_file);
-      DEBUG_SLEEP
-	  }
-	  errnum = ERR_NONE;
+    {
+	/* STATE 0:  Before any title command.
+	   STATE 1:  In a title command.
+	   STATE >1: In a entry after a title command.  */
+	int state = 0, prev_config_len = 0, prev_menu_len = 0;
+	char *cmdline;
+	int is_preset;
+
+	{
+	    int is_opened;
+
+	    is_preset = is_opened = 0;
+	    /* Try command-line menu first if it is specified. */
+	    if (preset_menu == (char *)0x0800 && ! *config_file)
+	    {
+		is_opened = is_preset = open_preset_menu ();
+	    }
+	    if (! is_opened)
+	    {
+		/* Try config_file */
+		if (*config_file)
+			is_opened = grub_open (config_file);
+	    }
+	    errnum = ERR_NONE;
+	    if (! is_opened)
+	    {
+		/* Try the preset menu. This will succeed at most once,
+		 * because the preset menu will be disabled(see below).  */
+		is_opened = is_preset = open_preset_menu ();
+	    }
+
+	    if (! is_opened)
+		goto done_config_file;
+	}
+
+	/* This is necessary, because the menu must be overrided.  */
+	reset ();
+	menu_entries = (char *) MENU_BUF;
+	cmdline = (char *) CMDLINE_BUF;
 	  
-#ifdef GRUB_UTIL
-	  do
-#endif /* GRUB_UTIL */
+	while (get_line_from_config (cmdline, NEW_HEAPSIZE, is_preset))
+	{
+	    struct builtin *builtin;
+	  
+	    /* Get the pointer to the builtin structure.  */
+	    builtin = find_command (cmdline);
+	    errnum = 0;
+	    if (! builtin)
+		/* Unknown command. Just skip now.  */
+		continue;
+	  
+	    if (builtin->flags & BUILTIN_TITLE)	/* title command */
 	    {
-	      /* STATE 0:  Before any title command.
-		 STATE 1:  In a title command.
-		 STATE >1: In a entry after a title command.  */
-	      int state = 0, prev_config_len = 0, prev_menu_len = 0;
-	      char *cmdline;
-
-	      is_preset = is_opened = 0;
-	      /* Try command-line menu first if it is specified. */
-	      if (preset_menu == (char *)0x0800 && ! *config_file)
+		/* the command "title" is specially treated.  */
+		if (state > 1)
 		{
-		  is_opened = is_preset = open_preset_menu ();
+		    /* The next title is found.  */
+		    num_entries++;
+		    config_entries[config_len++] = 0;
+		    prev_menu_len = menu_len;
+		    prev_config_len = config_len;
 		}
-	      if (! is_opened)
+		else
 		{
-		  /* Try config_file */
-		  if (*config_file)
-			is_opened = grub_open (config_file);
+		    /* The first title is found.  */
+		    menu_len = prev_menu_len;
+		    config_len = prev_config_len;
 		}
-	      errnum = ERR_NONE;
-	      if (! is_opened)
-		{
-		  /* Try the preset menu. This will succeed at most once,
-		   * because close_preset_menu disables the preset menu.  */
-		  is_opened = is_preset = open_preset_menu ();
-		}
 
-	      if (! is_opened)
-		break;
+		/* Reset the state.  */
+		state = 1;
 
-	      /* This is necessary, because the menu must be overrided.  */
-	      reset ();
-	      
-	      cmdline = (char *) CMDLINE_BUF;
-	      while (get_line_from_config (cmdline, NEW_HEAPSIZE,
-					   ! is_preset))
+		/* Copy title into menu area.  */
 		{
-		  struct builtin *builtin;
-		  
-		  /* Get the pointer to the builtin structure.  */
-		  builtin = find_command (cmdline);
-		  errnum = 0;
-		  if (! builtin)
-		    /* Unknown command. Just skip now.  */
+		    char *ptr = skip_to (1, cmdline);
+		    attr = menu_len;
+		    menu_entries[menu_len++] = 0x08;	/* attribute byte */
+		    while ((menu_entries[menu_len++] = *(ptr++)) != 0);
+		}
+	    }
+	    else if (! state)			/* menu init command */
+	    {
+		if (builtin->flags & BUILTIN_MENU)
+		{
+		    char *ptr = cmdline;
+		    /* Copy menu-specific commands to config area.  */
+		    while ((config_entries[config_len++] = *ptr++) != 0);
+		    prev_config_len = config_len;
+		}
+		else
+		    /* Ignored.  */
 		    continue;
-		  
-		  if (builtin->flags & BUILTIN_TITLE)
-		    {
-		      char *ptr;
-		      
-		      /* the command "title" is specially treated.  */
-		      if (state > 1)
-			{
-			  /* The next title is found.  */
-			  num_entries++;
-			  config_entries[config_len++] = 0;
-			  prev_menu_len = menu_len;
-			  prev_config_len = config_len;
-			}
-		      else
-			{
-			  /* The first title is found.  */
-			  menu_len = prev_menu_len;
-			  config_len = prev_config_len;
-			}
-		      
-		      /* Reset the state.  */
-		      state = 1;
-		      
-		      /* Copy title into menu area.  */
-		      ptr = skip_to (1, cmdline);
-		      while ((menu_entries[menu_len++] = *(ptr++)) != 0)
-			;
-		    }
-		  else if (! state)
-		    {
-		      /* Run a command found is possible.  */
-		      if (builtin->flags & BUILTIN_MENU)
-			{
-#if 0
-			  extern int commandline_func (char *arg, int flags);
-			  char *arg = (builtin->func) == commandline_func ? cmdline : skip_to (1, cmdline);
-			  (builtin->func) (arg, BUILTIN_MENU);
-			  errnum = 0;
-#endif
-			  char *ptr = cmdline;
-			  /* Copy menu-specific commands to config area.  */
-			  while ((config_entries[config_len++] = *ptr++) != 0);
-			  prev_config_len = config_len;
-			}
-		      else
-			/* Ignored.  */
-			continue;
-		    }
-		  else
-		    {
-		      char *ptr = cmdline;
-		      
-		      /* state == 1 means it is immediately after a TITLE, and
-		       * num_entries == 0 means the TITLE is the first one.  */
-		      if (num_entries == 0 && state == 1)
-			{
-			  /* Finish the menu-specific commands.  */
-			  config_entries[config_len++] = 0;
-			}
-		      state++;
-		      /* Copy config file data to config area.  */
-		      while ((config_entries[config_len++] = *ptr++) != 0)
-			;
-		    }
-		} /* while */
-	      
-	      /* file must be closed here, because the menu-specific commands
-	       * below may also use the GRUB_OPEN command.  */
-	      if (is_preset)
-		close_preset_menu ();
-	      else
-		grub_close ();
-	      
-	      if (state > 1)
+	    }
+	    else				/* menu item command */
+	    {
+		/* state == 1 means it is immediately after a TITLE, and
+		 * num_entries == 0 means the TITLE is the first one.  */
+		if (num_entries == 0 && state == 1)
 		{
-		  /* Finish the last entry.  */
-		  num_entries++;
-		  config_entries[config_len++] = 0;
+		    /* Finish the menu-specific commands.  */
+		    config_entries[config_len++] = 0;
 		}
-	      else// if (state)
+		state++;
+
+		/* Copy config file data to config area.  */
 		{
-		  menu_len = prev_menu_len;
-		  config_len = prev_config_len;
+		    char *ptr = cmdline;
+		    while ((config_entries[config_len++] = *ptr++) != 0);
 		}
-	      //else
-		///* Finish the menu-specific commands.  */
-		//config_entries[config_len++] = 0;
-	      
-	      menu_entries[menu_len++] = 0;
-	      config_entries[config_len++] = 0;
-	      grub_memmove (config_entries + config_len, menu_entries,
-			    menu_len);
-	      menu_entries = config_entries + config_len;
+		menu_entries[attr] |= !!(builtin->flags & BUILTIN_BOOTING);
+	    }
+	} /* while (get_line_from_config()) */
 
-      /* Run menu-specific commands before any other menu entry commands.  */
-      
-{
-  char *old_entry;
-  char *heap = menu_entries + menu_len;
+	/* file must be closed here, because the menu-specific commands
+	 * below may also use the GRUB_OPEN command.  */
+	if (is_preset)
+	    preset_menu = 0;	/* Disable the preset menu.  */
+	else
+	    grub_close ();
 
-#ifndef GRUB_UTIL
-  int old_debug = 1;
-#endif /* ! GRUB_UTIL */
-      
-  /* Initialize the data.  */
-  extern void init_cmdline (void);
-  init_cmdline ();
+	if (state > 1)
+	{
+	    /* Finish the last entry.  */
+	    num_entries++;
+	    config_entries[config_len++] = 0;
+	}
+	else// if (state)
+	{
+	    menu_len = prev_menu_len;
+	    config_len = prev_config_len;
+	}
+	//else
+	///* Finish the menu-specific commands.  */
+	//config_entries[config_len++] = 0;
+	  
+	menu_entries[menu_len++] = 0;
+	config_entries[config_len++] = 0;
+	grub_memmove (config_entries + config_len, menu_entries, menu_len);
+	menu_entries = config_entries + config_len;
+	/* old MENU_BUF is not used any more. So MENU_BUF is a temp area,
+	 * and can be moved to elsewhere. */
 
-  while (1)
-    {
-      struct builtin *builtin;
-      char *arg;
+	/* config_entries contains these:
+	 * 1. The array of menu init commands.
+	 * 2. The array of menu item commands.
+	 * 3. The array of titles, i.e., menu_entries.
+	 */
 
-      /* Copy the first string in CUR_ENTRY to HEAP.  */
-      old_entry = cur_entry;
-      while (*cur_entry++)
-	;
+	/* Run menu-specific commands before any other menu entry commands.  */
 
-      grub_memmove (heap, old_entry, (int) cur_entry - (int) old_entry);
-      if (! *heap)
 	{
-	  /* If there is no more command in SCRIPT...  */
+	    char *old_entry;
+	    char *heap = menu_entries + menu_len;
 
-	  /* If no kernel is loaded, just exit successfully.  */
-	  if (kernel_type == KERNEL_TYPE_NONE)
-	    break;
+#ifndef GRUB_UTIL
+	    int old_debug = 1;
+#endif /* ! GRUB_UTIL */
 
-	  /* Otherwise, the command boot is run implicitly.  */
-	  grub_memmove (heap, "boot", 5);
-	}
+	    /* Initialize the data.  */
+	    //saved_drive = boot_drive;
+	    //saved_partition = install_partition;
+	    current_drive = GRUB_INVALID_DRIVE;
+	    count_lines = -1;
+  
+	    kernel_type = KERNEL_TYPE_NONE;
+	    errnum = 0;
 
-      /* Find a builtin.  */
-      builtin = find_command (heap);
-      if (! builtin)
-	{
-	  grub_printf ("%s\n", old_entry);
-	  continue;
-	}
+	    while (1)
+	    {
+		struct builtin *builtin;
+		char *arg;
+		grub_error_t errnum_old;
 
-/* now we do not echo menu-specific commands */
-//      if (! (builtin->flags & BUILTIN_NO_ECHO))
-//	grub_printf ("%s\n", old_entry);
+		errnum_old = errnum;
+		errnum = 0;
 
-      /* If BUILTIN cannot be run in the menu, skip it.  */
-      if (! (builtin->flags & BUILTIN_MENU))
-	{
-	  continue;
-	}
+		/* Copy the first string in CUR_ENTRY to HEAP.  */
+		old_entry = cur_entry;
+		while (*cur_entry++);
 
-#if 0
-      /* Invalidate the cache, because the user may exchange removable
-	 disks.  */
-      buf_drive = -1;
-#endif
+		grub_memmove (heap, old_entry, (int) cur_entry - (int) old_entry);
+		if (! *heap)
+		{
+		    /* If there is no more command in SCRIPT...  */
 
-      /* find && and || */
+		    /* If no kernel is loaded, just exit successfully.  */
+		    if (kernel_type == KERNEL_TYPE_NONE)
+			break;
 
-      for (arg = skip_to (0, heap); *arg != 0; arg = skip_to (0, arg))
-      {
-	struct builtin *builtin1;
-	int ret;
-	char *arg1;
-	arg1 = arg;
-        if (*arg == '&' && arg[1] == '&' && (arg[2] == ' ' || arg[2] == '\t'))
-        {
-		/* handle the AND operator */
-		arg = skip_to (0, arg);
-		builtin1 = find_command (arg);
-		if (! builtin1 || ! (builtin1->flags & BUILTIN_MENU))
+		    /* Otherwise, the command boot is run implicitly.  */
+		    grub_memmove (heap, "boot", 5);
+		}
+
+		/* Find a builtin.  */
+		builtin = find_command (heap);
+		if (! builtin)
 		{
-			errnum = ERR_UNRECOGNIZED;
-			goto next;
+		    grub_printf ("%s\n", old_entry);
+		    continue;
 		}
 
-		*arg1 = 0;
-		ret = (builtin->func) (skip_to (1, heap), BUILTIN_MENU);
-		*arg1 = '&';
-		if (ret)
+		/* If BUILTIN cannot be run in the menu, skip it.  */
+		if (! (builtin->flags & BUILTIN_MENU))
 		{
-			arg = skip_to (1, arg);
-			(builtin1->func) (arg, BUILTIN_MENU);
+		    continue;
 		}
-		goto next;
-	} else if (*arg == '|' && arg[1] == '|' && (arg[2] == ' ' || arg[2] == '\t'))
-	{
-		/* handle the OR operator */
-		arg = skip_to (0, arg);
-		builtin1 = find_command (arg);
-		if (! builtin1 || ! (builtin1->flags & BUILTIN_MENU))
+
+		if ((builtin->func) == errnum_func && (builtin->func) == checkrange_func)
+		    errnum = errnum_old;
+
+		/* find && and || */
+
+		for (arg = skip_to (0, heap); *arg != 0; arg = skip_to (0, arg))
 		{
-			errnum = ERR_UNRECOGNIZED;
+		    struct builtin *builtin1;
+		    int ret;
+		    char *arg1;
+		    arg1 = arg;
+		    if (*arg == '&' && arg[1] == '&' && (arg[2] == ' ' || arg[2] == '\t'))
+		    {
+			/* handle the AND operator */
+			arg = skip_to (0, arg);
+			builtin1 = find_command (arg);
+			if (! builtin1 || ! (builtin1->flags & BUILTIN_MENU))
+			{
+				errnum = ERR_UNRECOGNIZED;
+				goto next;
+			}
+
+			*arg1 = 0;
+			ret = (builtin->func) (skip_to (1, heap), BUILTIN_MENU);
+			*arg1 = '&';
+			if (ret)
+			{
+				arg = skip_to (1, arg);
+				if ((builtin1->func) != errnum_func && (builtin1->func) != checkrange_func)
+					errnum = 0;
+				(builtin1->func) (arg, BUILTIN_MENU);
+			} else
+				errnum = 0;
 			goto next;
-		}
+		    } else if (*arg == '|' && arg[1] == '|' && (arg[2] == ' ' || arg[2] == '\t'))
+		    {
+			/* handle the OR operator */
+			arg = skip_to (0, arg);
+			builtin1 = find_command (arg);
+			if (! builtin1 || ! (builtin1->flags & BUILTIN_MENU))
+			{
+				errnum = ERR_UNRECOGNIZED;
+				goto next;
+			}
 
-		*arg1 = 0;
-		ret = (builtin->func) (skip_to (1, heap), BUILTIN_MENU);
-		*arg1 = '|';
-		if (! ret)
-		{
-			arg = skip_to (1, arg);
-			(builtin1->func) (arg, BUILTIN_MENU);
+			*arg1 = 0;
+			ret = (builtin->func) (skip_to (1, heap), BUILTIN_MENU);
+			*arg1 = '|';
+			if (! ret)
+			{
+				arg = skip_to (1, arg);
+				if ((builtin1->func) != errnum_func && (builtin1->func) != checkrange_func)
+					errnum = 0;
+				(builtin1->func) (arg, BUILTIN_MENU);
+			} else
+				errnum = 0;
+			goto next;
+		    }
 		}
-		goto next;
-	}
-      }
       
-      /* Run BUILTIN->FUNC.  */
-      extern int commandline_func (char *arg1, int flags);
-      arg = (builtin->func) == commandline_func ? heap : skip_to (1, heap);
-      (builtin->func) (arg, BUILTIN_MENU);
+		/* Run BUILTIN->FUNC.  */
+		arg = (builtin->func) == commandline_func ? heap : skip_to (1, heap);
+		(builtin->func) (arg, BUILTIN_MENU);
 
-      /* if the INSERT key was pressed at startup, debug is not allowed to be turned off. */
+		/* if the INSERT key was pressed at startup, debug is not allowed to be turned off. */
 #ifndef GRUB_UTIL
-      if (debug_boot)
-	if ((unsigned int)debug < 2)	/* debug == 0 or 1 */
-	{
-	    old_debug = debug;	/* save the new debug in old_debug */
-	    debug = 2;
-	}
+		if (debug_boot)
+		    if ((unsigned int)debug < 2)	/* debug == 0 or 1 */
+		    {
+			old_debug = debug;	/* save the new debug in old_debug */
+			debug = 2;
+		    }
 #endif /* ! GRUB_UTIL */
 
 next:
-      DEBUG_SLEEP
-      if (! *old_entry)
-	break;
-    }
-  //config_entries = cur_entry; /* config file data begins here */
+		DEBUG_SLEEP
+		if (! *old_entry)
+		    break;
+	    } /* while (1) */
+
+	    kernel_type = KERNEL_TYPE_NONE;
+
+	    //config_entries = cur_entry; /* config file data begins here */
 #ifndef GRUB_UTIL
-    if (debug_boot)
-    {
-	debug = old_debug;
-	grub_printf ("\n\nEnd of menu init commands. Press any key to enter command-line or run menu...", old_entry);
-    }
+	    if (debug_boot)
+	    {
+		debug = old_debug;
+		grub_printf ("\n\nEnd of menu init commands. Press any key to enter command-line or run menu...", old_entry);
+	    }
 #endif /* ! GRUB_UTIL */
-      DEBUG_SLEEP
-}
-		errnum = 0;
+	    DEBUG_SLEEP
+	}
 
-	      /* Make sure that all fallback entries are valid.  */
-	      if (fallback_entryno >= 0)
-		{
-		  for (i = 0; i < MAX_FALLBACK_ENTRIES; i++)
-		    {
-		      if (fallback_entries[i] < 0)
-			break;
-		      if (fallback_entries[i] >= num_entries)
-			{
-			  grub_memmove (fallback_entries + i,
-					fallback_entries + i + 1,
-					((MAX_FALLBACK_ENTRIES - i - 1)
-					 * sizeof (int)));
-			  i--;
-			}
-		    }
+	/* End of menu-specific commands.  */
 
-		  if (fallback_entries[0] < 0)
-		    fallback_entryno = -1;
-		}
-	      /* Check if the default entry is present. Otherwise reset
-		 it to fallback if fallback is valid, or to DEFAULT_ENTRY 
-		 if not.  */
-	      if (default_entry >= num_entries)
+	errnum = 0;
+
+	/* Make sure that all fallback entries are valid.  */
+	if (fallback_entryno >= 0)
+	{
+	    int i;
+
+	    for (i = 0; i < MAX_FALLBACK_ENTRIES; i++)
+	    {
+		if (fallback_entries[i] < 0)
+		    break;
+		if (fallback_entries[i] >= num_entries)
 		{
-		  if (fallback_entryno >= 0)
-		    {
-		      default_entry = fallback_entries[0];
-		      fallback_entryno++;
-		      if (fallback_entryno >= MAX_FALLBACK_ENTRIES
-			  || fallback_entries[fallback_entryno] < 0)
-			fallback_entryno = -1;
-		    }
-		  else
-		    default_entry = 0;
+		    grub_memmove (fallback_entries + i, fallback_entries + i + 1, ((MAX_FALLBACK_ENTRIES - i - 1) * sizeof (int)));
+		    i--;
 		}
 	    }
-#ifdef GRUB_UTIL
-	  while (is_preset);
-#endif /* GRUB_UTIL */
+
+	    if (fallback_entries[0] < 0)
+		fallback_entryno = -1;
 	}
 
-      /* go ahead and make sure the terminal is setup */
-      if (current_term->startup)
-	(*current_term->startup)();
-
-      if (! num_entries)
+	/* Check if the default entry is present. Otherwise reset it to
+	   fallback if fallback is valid, or to DEFAULT_ENTRY if not.  */
+	if (default_entry >= num_entries)
 	{
-	  /* If no acceptable config file, goto command-line, starting
-	     heap from where the config entries would have been stored
-	     if there were any.  */
-	  enter_cmdline (config_entries, 1);
+	    if (fallback_entryno >= 0)
+	    {
+		default_entry = fallback_entries[0];
+		fallback_entryno++;
+		if (fallback_entryno >= MAX_FALLBACK_ENTRIES || fallback_entries[fallback_entryno] < 0)
+		    fallback_entryno = -1;
+	    }
+	    else
+		default_entry = 0;
 	}
-      else
-	{
-	  /* Run menu interface.  */
-	  run_menu (menu_entries, cur_entry, num_entries,
-		    menu_entries + menu_len, default_entry);
-	}
     }
+
+done_config_file:
+
+    /* go ahead and make sure the terminal is setup */
+    if (current_term->startup)
+	(*current_term->startup)();
+
+    if (! num_entries)
+    {
+	/* no config file, goto command-line, starting heap from where the
+	   config entries would have been stored if there were any.  */
+	enter_cmdline (config_entries, 1);
+    }
+    else
+    {
+	/* Run menu interface.  */
+	run_menu (menu_entries, cur_entry, num_entries,
+		  menu_entries + menu_len, default_entry);
+    }
+    goto restart;
 }
Index: stage2/graphics.c
===================================================================
--- stage2/graphics.c	(revision 60)
+++ stage2/graphics.c	(working copy)
@@ -39,10 +39,15 @@
 char splashimage[64];
 
 #define VSHADOW VSHADOW1
+/* 8x16 dot array, total chars = 80*30. plano size = 80*30*16 = 38400 bytes */
 static unsigned char *VSHADOW1 = (unsigned char *)0x3A0000;	//unsigned char VSHADOW1[38400];
 static unsigned char *VSHADOW2 = (unsigned char *)0x3A9600;	//unsigned char VSHADOW2[38400];
 static unsigned char *VSHADOW4 = (unsigned char *)0x3B2C00;	//unsigned char VSHADOW4[38400];
 static unsigned char *VSHADOW8 = (unsigned char *)0x3BC200;	//unsigned char VSHADOW8[38400];
+/* text buffer has to be kept around so that we can write things as we
+ * scroll and the like */
+//static unsigned short text[80 * 30];
+static unsigned long *text = (unsigned long *)0x3C5800; // length in bytes = 80*30*4
 
 /* constants to define the viewable area */
 const int x0 = 0;
@@ -50,10 +55,6 @@
 const int y0 = 0;
 const int y1 = 30;
 
-/* text buffer has to be kept around so that we can write things as we
- * scroll and the like */
-static unsigned short text[80 * 30];
-
 /* why do these have to be kept here? */
 int foreground = (63 << 16) | (63 << 8) | (63), background = 0, border = 0;
 
@@ -112,6 +113,10 @@
 int
 graphics_init (void)
 {
+    /* graphics mode will corrupt the extended memory. so we should
+     * invalidate the kernel_type. */
+    kernel_type = KERNEL_TYPE_NONE;
+
     if (! graphics_inited)
     {
         saved_videomode = set_videomode (0x12);
@@ -172,7 +177,7 @@
     text[fonty * 80 + fontx] = ch;
     text[fonty * 80 + fontx] &= 0x00ff;
     if (graphics_current_color & 0xf0)
-        text[fonty * 80 + fontx] |= 0x100;
+        text[fonty * 80 + fontx] |= 0x10000;//0x100;
 
     graphics_cursor(0);
 
@@ -528,7 +533,7 @@
     offset = cursorY * 80 + fontx;
     ch = text[fonty * 80 + fontx] & 0xff;
     if (ch != ' ' || ! disable_space_highlight)
-	invert = (text[fonty * 80 + fontx] & 0xff00) != 0;
+	invert = (text[fonty * 80 + fontx] & /*0xff00*/ 0xffff0000) != 0;
     pat = font8x16 + (ch << 4);
 
     mem = (unsigned char*)VIDEOMEM + offset;
Index: stage2/char_io.c
===================================================================
--- stage2/char_io.c	(revision 60)
+++ stage2/char_io.c	(working copy)
@@ -694,8 +694,6 @@
   int c;
   /* The index for the history.  */
   int history = -1;
-  /* The kill buffer.  */
-  char *kill_buf = (char *) KILL_BUF;
   
   buf = (char *) CMDLINE_BUF;
   plen = grub_strlen (prompt);
@@ -720,10 +718,7 @@
       /* If READLINE is non-zero, handle readline-like key bindings.  */
       if (readline)
 	{
-	  //switch (c)
-	  //  {
-	  if ((char)c == 9)
-	    //case 9:		/* TAB lists completions */
+	  if ((char)c == 9)	/* TAB lists completions */
 	      {
 		int i;
 		/* POS points to the first space after a command.  */
@@ -752,10 +747,6 @@
 		    }
 
 		/* Find the position of the first character in this word.  */
-#if 0
-		for (i = lpos; i > 0 && buf[i - 1] != ' '; i--)
-		  ;
-#else
 		for (i = lpos; i > 0; i--)
 		{
 		    if (buf[i - 1] == ' ')
@@ -771,7 +762,6 @@
 				break;
 		    }
 		}
-#endif
 
 		/* Invalidate the cache, because the user may exchange
 		   removable disks.  */
@@ -806,65 +796,27 @@
 		if (ret)
 		  cl_init ();
 	      }
-	      //break;
-	  else if (c == KEY_HOME || (char)c == 1)
-	    //case 1:		/* C-a go to beginning of line */
+	  else if (c == KEY_HOME/* || (char)c == 1*/)	/* C-a beginning */
+		/* Home= 0x4700 for BIOS, 0x0106 for Linux */
 	      cl_backward (lpos);
-	      //break;
-	  else if (c == KEY_END || (char)c == 5)
-	    //case 5:		/* C-e go to end of line */
+	  else if (c == KEY_END/* || (char)c == 5*/)	/* C-e end */
+		/* End= 0x4F00 for BIOS, 0x0168 for Linux */
 	      cl_forward (llen - lpos);
-	      //break;
-	  else if (c == KEY_RIGHT || (char)c == 6)
-	    //case 6:		/* C-f forward one character */
+	  else if (c == KEY_RIGHT/* || (char)c == 6*/)	/* C-f forward */
+		/* Right= 0x4D00 for BIOS, 0x0105 for Linux */
 	      {
 		if (lpos < llen)
 		  cl_forward (1);
 	      }
-	      //break;
-	  else if (c == KEY_LEFT || (char)c == 2)
-	    //case 2:		/* C-b backward one character */
+	  else if (c == KEY_LEFT/* || (char)c == 2*/)	/* C-b backward */
+		/* Left= 0x4B00 for BIOS, 0x0104 for Linux */
 	      {
 		if (lpos > 0)
 		  cl_backward (1);
 	      }
-	      //break;
-	  else if ((char)c == 21)
-	    //case 21:		/* C-u kill to beginning of line */
+	  else if (c == KEY_UP/* || (char)c == 16*/)	/* C-p previous */
+		/* Up= 0x4800 for BIOS, 0x0153 for Linux */
 	      {
-		if (lpos)
-		{
-		  int count;
-		  
-		  /* Copy the string being deleted to KILL_BUF.  */
-		  grub_memmove (kill_buf, buf, lpos);
-		  kill_buf[lpos] = 0;
-		  
-		  /* XXX: Not very clever.  */
-		  count = lpos;
-		  cl_backward (lpos);
-		  cl_delete (count);
-		}
-	      }
-	      //break;
-	  else if ((char)c == 11)
-	    //case 11:		/* C-k kill to end of line */
-	      {
-		if (lpos != llen)
-		{
-		  /* Copy the string being deleted to KILL_BUF.  */
-		  grub_memmove (kill_buf, buf + lpos, llen - lpos + 1);
-		  cl_delete (llen - lpos);
-		}
-	      }
-	      //break;
-	  else if ((char)c == 25)
-	    //case 25:		/* C-y yank the kill buffer */
-	      cl_insert (kill_buf);
-	      //break;
-	  else if (c == KEY_UP || (char)c == 16)
-	    //case 16:		/* C-p fetch the previous command */
-	      {
 		char *p;
 
 		if (history < 0)
@@ -889,9 +841,8 @@
 		    cl_refresh (1, 0);
 		  }
 	      }
-	      //break;
-	  else if (c == KEY_DOWN || (char)c == 14)
-	    //case 14:		/* C-n fetch the next command */
+	  else if (c == KEY_DOWN/* || (char)c == 14*/)	/* C-n next command */
+		/* Down= 0x5000 for BIOS, 0x0152 for Linux */
 	      {
 		char *p;
 
@@ -912,32 +863,26 @@
 		    cl_refresh (1, 0);
 		  }
 	      }
-	      //break;
-	    //}
 	}
 
       /* ESC, C-d and C-h are always handled. Actually C-d is not
 	 functional if READLINE is zero, as the cursor cannot go
 	 backward, but that's ok.  */
-      //switch (c)
-	//{
-	if ((char)c == 27)
-	//case 27:	/* ESC immediately return 1 */
+
+		/* Ins= 0x5200 for BIOS, 0x014B for Linux */
+		/* PgUp= 0x4900 for BIOS, 0x0153 for Linux */
+		/* PgDn= 0x5100 for BIOS, 0x0152 for Linux */
+
+	if ((char)c == 27)	/* ESC immediately return 1 */
 	  return 1;
-	else if (c == KEY_DC || (char)c == 4)
-	//case 4:	/* C-d delete character under cursor */
+	else if (c == KEY_DC/* || (char)c == 4*/)	/* C-d delete */
+		/* Del= 0x5300 for BIOS, 0x014A for Linux */
 	  {
 	    if (lpos != llen)
 	      cl_delete (1);
 	  }
-	  //break;
-	else if ((char)c == 8 || c == KEY_BACKSPACE
-	//case 8:		/* C-h backspace */
-# ifdef GRUB_UTIL
-			|| (char)c == 127
-	//case KEY_BACKSPACE/*127*/:	/* also backspace */
-# endif
-		)
+	else if (c == KEY_BACKSPACE || (char)c == 8)	/* C-h backspace */
+		/* Backspace= 0x0E08 for BIOS, 0x0107 for Linux */
 	  {
 	    if (lpos > 0)
 	    {
@@ -945,10 +890,17 @@
 	      cl_delete (1);
 	    }
 	  }
-	  //break;
-	else
-	//default:		/* insert printable character into line */
+	else		/* insert printable character into line */
 	  {
+#ifdef GRUB_UTIL
+	    if (c >= ' ' && c <= '~')
+	    {
+	      char str[2];
+
+	      *(short *)str = (short)c;
+	      cl_insert (str);
+	    }
+#else
 	    if ((char)c >= ' ' && (char)c <= '~')
 	    {
 	      char str[2];
@@ -957,8 +909,8 @@
 	      str[1] = 0;
 	      cl_insert (str);
 	    }
+#endif
 	  }
-	//}
     }
 
   grub_putchar ('\n');
@@ -1147,7 +1099,7 @@
   return 0;
 }
 
-#if !defined(STAGE1_5) || defined(FSYS_ISO9660)
+//#if !defined(STAGE1_5) || defined(FSYS_ISO9660)
 int
 grub_memcmp (const char *s1, const char *s2, int n)
 {
@@ -1164,7 +1116,7 @@
 
   return 0;
 }
-#endif /* ! STAGE1_5 || FSYS_ISO9660 */
+//#endif /* ! STAGE1_5 || FSYS_ISO9660 */
 
 #ifndef STAGE1_5
 int
Index: stage2/disk_io.c
===================================================================
--- stage2/disk_io.c	(revision 60)
+++ stage2/disk_io.c	(working copy)
@@ -288,8 +288,7 @@
 #endif
 
       /* Sectors that need to read */
-      slen = ((byte_offset + byte_len + buf_geom.sector_size - 1)
-	      >> sector_size_bits);
+      slen = ((byte_offset + byte_len + buf_geom.sector_size - 1) >> sector_size_bits);
 
       /* Eliminate a buffer overflow.  */
       if ((buf_geom.sectors << sector_size_bits) > BUFFERLEN)
@@ -297,11 +296,6 @@
       else
 	sectors_per_vtrack = buf_geom.sectors;
 
-//  if (*(unsigned long *)0 == 0)
-//  {
-//printf("CHS=%X/%X/%X, sectors_per_vtrack=%X, total sectors=%X, flags=%X\n", buf_geom.cylinders, buf_geom.heads, buf_geom.sectors, sectors_per_vtrack, buf_geom.total_sectors, buf_geom.flags);
-//for (i=0;i<0x40000000;i++);
-//  }
       /* Get the first sector number in the track.  */
       soff = sector % sectors_per_vtrack;
 
@@ -312,8 +306,7 @@
       num_sect = sectors_per_vtrack - soff;
 
       /* Read data into the track buffer; Not all sectors in the track would be filled in. */
-      bufaddr = ((char *) BUFFERADDR
-		 + (soff << sector_size_bits) + byte_offset);
+      bufaddr = ((char *) BUFFERADDR + (soff << sector_size_bits) + byte_offset);
 
       if (track != buf_track)
 	{
@@ -336,8 +329,7 @@
 	      bufaddr = (char *) BUFFERADDR + byte_offset;
 	    }
 
-	  bios_err = biosdisk (BIOSDISK_READ, drive, &buf_geom,
-			       read_start, read_len, BUFFERSEG);
+	  bios_err = biosdisk (BIOSDISK_READ, drive, &buf_geom, read_start, read_len, BUFFERSEG);
 	  if (bios_err)
 	    {
 	      buf_track = -1;	/* invalidate the buffer */
@@ -370,30 +362,6 @@
 		  //bufaddr = (char *) BUFFERADDR + byte_offset;
 		}
 	    }
-
-#if 0
-	  if ((buf_track == 0 || sector == 0)
-	      && (PC_SLICE_TYPE (BUFFERADDR, 0) == PC_SLICE_TYPE_EZD
-		  || PC_SLICE_TYPE (BUFFERADDR, 1) == PC_SLICE_TYPE_EZD
-		  || PC_SLICE_TYPE (BUFFERADDR, 2) == PC_SLICE_TYPE_EZD
-		  || PC_SLICE_TYPE (BUFFERADDR, 3) == PC_SLICE_TYPE_EZD))
-	    {
-	      /* This is a EZD disk map sector 0 to sector 1 */
-	      if (buf_track == 0 || slen >= 2)
-		{
-		  /* We already read the sector 1, copy it to sector 0 */
-		  memmove ((char *) BUFFERADDR,
-			   (char *) BUFFERADDR + buf_geom.sector_size,
-			   buf_geom.sector_size);
-		}
-	      else
-		{
-		  if (biosdisk (BIOSDISK_READ, drive, &buf_geom,
-				1, 1, BUFFERSEG))
-		    errnum = ERR_READ;
-		}
-	    }
-#endif
 	} /* if (track != buf_track) */
 
       if (size > (num_sect << sector_size_bits) - byte_offset)
@@ -460,9 +428,7 @@
    *  Check partition boundaries
    */
 //grub_printf ("sector=%x, byte_offset=%x, byte_len=%x, buf=%x, part_length=%x\n", sector, byte_offset, byte_len, buf, part_length);
-  if (//sector < 0 ||
-      ((unsigned long)(sector + ((byte_offset + byte_len - 1) >> sector_size_bits))
-	  >= part_length) && part_start /* != 0 */)
+  if (((unsigned long)(sector + ((byte_offset + byte_len - 1) >> sector_size_bits)) >= part_length) && part_start)
     {
       errnum = ERR_OUTSIDE_PART;
       return 0;
@@ -490,8 +456,7 @@
    *            of the disk.
    *    --  It doesn't handle offsets across the sector boundary.
    */
-  return rawread (current_drive, part_start + sector, byte_offset,
-		  byte_len, buf);
+  return rawread (current_drive, part_start + sector, byte_offset, byte_len, buf);
 }
 
 
@@ -505,23 +470,6 @@
 int
 rawwrite (unsigned long drive, unsigned long sector, char *buf)
 {
-#if 0
-  if (sector == 0)
-    {
-      if (biosdisk (BIOSDISK_READ, drive, &buf_geom, 0, 1, SCRATCHSEG))
-	{
-	  errnum = ERR_WRITE;
-	  return 0;
-	}
-
-      if (PC_SLICE_TYPE (SCRATCHADDR, 0) == PC_SLICE_TYPE_EZD
-	  || PC_SLICE_TYPE (SCRATCHADDR, 1) == PC_SLICE_TYPE_EZD
-	  || PC_SLICE_TYPE (SCRATCHADDR, 2) == PC_SLICE_TYPE_EZD
-	  || PC_SLICE_TYPE (SCRATCHADDR, 3) == PC_SLICE_TYPE_EZD)
-	sector = 1;
-    }
-#endif
-
   /* skip the write if possible. */
   if (biosdisk (BIOSDISK_READ, drive, &buf_geom, sector, 1, SCRATCHSEG))
     {
@@ -567,8 +515,7 @@
 	 embed a Stage 1.5 into a partition instead of a MBR, use system
 	 calls directly instead of biosdisk, because of the bug in
 	 Linux. *sigh*  */
-      return write_to_partition (device_map, current_drive, current_partition,
-				 sector, sector_count, buf);
+      return write_to_partition (device_map, current_drive, current_partition, sector, sector_count, buf);
     }
   else
 #endif /* GRUB_UTIL && __linux__ */
@@ -577,10 +524,8 @@
 
       for (i = 0; i < sector_count; i++)
 	{
-	  if (! rawwrite (current_drive, part_start + sector + i,
-			  buf + (i << SECTOR_BITS)))
+	  if (! rawwrite (current_drive, part_start + sector + i, buf + (i << SECTOR_BITS)))
 	      return 0;
-
 	}
       return 1;
     }
@@ -594,11 +539,12 @@
 {
   int j;
 
+  if (kernel_type != KERNEL_TYPE_FREEBSD && kernel_type != KERNEL_TYPE_NETBSD)
+	return 0;
   /* Copy the boot partition information to 0x7be-0x7fd for chain-loading.  */
   if ((saved_drive & 0x80) && cur_part_addr)
     {
-      if (rawread (saved_drive, cur_part_offset,
-		   0, SECTOR_SIZE, (char *) SCRATCHADDR))
+      if (rawread (saved_drive, cur_part_offset, 0, SECTOR_SIZE, (char *) SCRATCHADDR))
 	{
 	  char *dst, *src;
 
@@ -638,9 +584,7 @@
   if (saved_drive & 0x80)
     j = bsd_evil_hack;
 
-  return MAKEBOOTDEV (j, (i >> 4), (i & 0xF),
-		      ((saved_drive - hdbias) & 0x7F),
-		      ((saved_partition >> 8) & 0xFF));
+  return MAKEBOOTDEV (j, (i >> 4), (i & 0xF), ((saved_drive - hdbias) & 0x7F), ((saved_partition >> 8) & 0xFF));
 }
 #endif /* STAGE1_5 */
 
@@ -1020,9 +964,6 @@
 	  errnum = ERR_NO_DISK;
 	  return 0;
 	}
-#ifndef STAGE1_5
-//if (debug == -2) grub_printf ("real_open_partition: get_diskinfo: ok!\n");
-#endif
       buf_drive = current_drive;
       buf_track = -1;
     }
@@ -1329,7 +1270,7 @@
 		  //  if (cdrom_drives[current_drive] != GRUB_INVALID_DRIVE)
 		  //	    current_drive = cdrom_drives[current_drive];
 		  //}
-		  else if (ch == 'c' && atapi_dev_count && current_drive < atapi_dev_count)
+		  else if (ch == 'c' && atapi_dev_count && current_drive < (unsigned long)atapi_dev_count)
 		  {
 		    current_drive += min_cdrom_id;
 		  }
@@ -1688,7 +1629,7 @@
 #ifndef GRUB_UTIL
 	      if (atapi_dev_count  && (!ptr || *(ptr-1) == '(' || (*(ptr-1) == 'd' && *(ptr-2) == 'c')))
 	      {
-		for (j = 0; j < atapi_dev_count; j++)
+		for (j = 0; j < (unsigned long)atapi_dev_count; j++)
 		  if (disk_choice || min_cdrom_id + j == current_drive)
 		    {
 			char dev_name[8];
Index: stage2/dosstart.S
===================================================================
--- stage2/dosstart.S	(revision 60)
+++ stage2/dosstart.S	(working copy)
@@ -3326,7 +3326,7 @@
 
 	/* first, move command line to CS:0081 */
 
-	cli
+	//cli			/* marked off 2008-08-04 */
 
 	cld			/* move upward */
 	movw	$0x80, %si
@@ -3345,8 +3345,8 @@
 _dos_start1:
 	/* At here DS=ES=CS=SS */
 
-	//sti
-	cli			/* disable interrupt for usb keyboard hack */
+	sti			/* added 2008-08-04, and marked off cli */
+	//cli			/* disable interrupt for usb keyboard hack */
 
 	/* XXX: Maybe we should better mask off all IRQs
 	 * and disable NMI here
@@ -6941,7 +6941,7 @@
 
 	call	sleep_5_seconds
 
-	cli				/* the clock is not used any more */
+	//cli	/*2008-08-04*/		/* the clock is not used any more */
 
 	je	1f			/* desired hot-key pressed */
 	jb	message_exit1		/* another key pressed */
@@ -6970,7 +6970,7 @@
 	 */
 
 
-	cli
+	//cli				/* marked off 2008-08-04 */
 
 	movw	$0x00ff, %cx		# try so many times on failure
 	movw	$0x0101, %dx		# with a20 debug on
@@ -6987,7 +6987,18 @@
 	//jz	exit_no_message		/* A20 disabled */
 #endif
 
+#if 0	/* marked off 2008-08-04 */
+	//pushw	ABS_PSP(time_out)
+	movw	$1, ABS_PSP(time_out)	/* sleep 1 second after A20 control */
 
+	sti				/* for sleep_5_seconds to work. */
+
+	call	sleep_5_seconds
+
+	//cli	/*2008-08-04*/		/* the clock is not used any more */
+	//popw	ABS_PSP(time_out)
+#endif
+
 #if 0
 	/* now A20 is on */
 	decl	ABS_PSP(a20_status)	# let it be 0xFFFFFFFF
@@ -7138,6 +7149,7 @@
 	//jmp	1b
 	//movw	%bx, %es	# restore ES from BX
 	//movw	%bx, %ds	# restore DS from BX
+	sti			/* added 2008-08-04 */
 	popal
 	popw	%es
 	popw	%ds
@@ -7186,15 +7198,17 @@
 	 */
 
 	/* overwrite 1 sector of IVT with the new bios_interrupt_vector_table */
-	cli
 	movw	%cs, %ax
 	movw	%ax, %ds
 	movw	$ABS_START(bios_interrupt_vector_table), %si
 	xorw	%di, %di		/* ES:DI=0000:0000 */
 	movw	%di, %es
 	movw	$0x80, %cx
+
+	cli
 	cld
 	repz movsl
+	sti				/* added 2008-08-04 */
 
 #if 0					/* marked out in 2008-05-07 */
 	/* restore int 13 and int 15 for disk emulation */
@@ -7322,32 +7336,32 @@
 	movw	$ABS_START(probe_int_hang_string), %si
 	call	prtstr
 
-	/* check the int 13 vector high word */
-	cmpw	$0xC000, ABS_START(bios_interrupt_vector_table) + 0x4E
-	jb	2f
+//	/* check the int 13 vector high word */
+//	cmpw	$0xC000, ABS_START(bios_interrupt_vector_table) + 0x4E
+//	jb	2f
+//
+//	cmpw	$0xF000, ABS_START(bios_interrupt_vector_table) + 0x4E
+//	jna	3f	/* int 13 points to ROM */
+//2:
+//	/* int 13 service routine was not in ROM */
+//	/* clear tmp_int13_vector and tmp_int15_vector */
+////	xorl	%eax, %eax		/* marked out in 2008-05-07 */
+////	movl	%eax, ABS_START(tmp_int13_vector)
+////	movl	%eax, ABS_START(tmp_int15_vector)
+//3:
+//	/* check the int 15 vector high word */
+//	cmpw	$0xC000, ABS_START(bios_interrupt_vector_table) + 0x56
+//	jb	2f
+//
+//	cmpw	$0xF000, ABS_START(bios_interrupt_vector_table) + 0x56
+//	jna	3f	/* int 15 points to ROM */
+//2:
+//	/* int 15 service routine was not in ROM */
+//	/* clear tmp_int15_vector */
+////	xorl	%eax, %eax		/* marked out in 2008-05-07 */
+////	movl	%eax, ABS_START(tmp_int15_vector)
+//3:
 
-	cmpw	$0xF000, ABS_START(bios_interrupt_vector_table) + 0x4E
-	jna	3f	/* int 13 points to ROM */
-2:
-	/* int 13 service routine was not in ROM */
-	/* clear tmp_int13_vector and tmp_int15_vector */
-//	xorl	%eax, %eax		/* marked out in 2008-05-07 */
-//	movl	%eax, ABS_START(tmp_int13_vector)
-//	movl	%eax, ABS_START(tmp_int15_vector)
-3:
-	/* check the int 15 vector high word */
-	cmpw	$0xC000, ABS_START(bios_interrupt_vector_table) + 0x56
-	jb	2f
-
-	cmpw	$0xF000, ABS_START(bios_interrupt_vector_table) + 0x56
-	jna	3f	/* int 15 points to ROM */
-2:
-	/* int 15 service routine was not in ROM */
-	/* clear tmp_int15_vector */
-//	xorl	%eax, %eax		/* marked out in 2008-05-07 */
-//	movl	%eax, ABS_START(tmp_int15_vector)
-3:
-
 	movw	$ABS_START(bios_interrupt_vector_table), %si
 	movw	%si, %di
 	xorw	%cx, %cx
@@ -7556,14 +7570,14 @@
 	cmpw	$ABS_START(bios_interrupt_vector_table) + 0x10, %di	/* int 04 */
 	je	3f
 	cmpw	$ABS_START(bios_interrupt_vector_table) + 0x14, %di	/* int 05 */
-//	jne	8f
-	je	3f
+	jne	8f
+//	je	3f
 
 	/* qemu sets this to dummy. */
 
-//	call	restore_vector
-//	jc	3f
-//	jmp	2f
+	call	restore_vector
+	jc	3f
+	jmp	2f
 8:
 	cmpw	$ABS_START(bios_interrupt_vector_table) + 0x18, %di	/* int 06 */
 	jne	8f
@@ -7665,11 +7679,19 @@
 	jne	7f
 
 	/* later PS/2s - GET A20 GATE STATUS */
-//	call	print_cl
 	movw	$0x2402, %ax
 	call	restore_vector
-	jc	9f
-	jmp	2f
+	jnc	2f
+	/* BIOS - JOYSTICK SUPPORT (XT after 1982/11/8, AT, XT286, PS) */
+	movw	$0x8400, %ax
+	movw	$0x0000, %dx	/* subfunction: read joystick switches */
+	call	restore_vector
+	jnc	2f
+	/* SYSTEM - GET CONFIGURATION (XT >1986/1/10, AT mdl 3x9, CONV, XT286, PS) */
+	movw	$0xC000, %ax
+	call	restore_vector
+	jnc	2f
+	jmp	9f
 
 7:
 	cmpw	$ABS_START(bios_interrupt_vector_table) + 0x58, %di	/* int 16, KEYBOARD */
@@ -8492,6 +8514,7 @@
 	 */
 
 	pushfw		/* additional PUSHF */
+	cli		/* added 2008-08-04 */
 	pushfw		/* PUSHF here together with LCALL below form an INT */
 
 	/* set the TF flag */
@@ -8505,6 +8528,7 @@
 
 	lcall	*(%di)	/* PUSHF above together with LCALL here form an INT */
 
+	sti		/* added 2008-08-04 */
 	popfw		/* additional POPF */
 
 	/* TF is cleared here automatically */
@@ -8520,6 +8544,7 @@
 	pushl	$0
 	popfl			#; CLD, CLI, Clear TF and many more...
 
+	sti		/* added 2008-08-04 */
 	/* restore the original int 00 - 1F vectors */
 	pushw	%cs
 	popw	%ds		/* DS=CS */
@@ -8534,8 +8559,12 @@
 	xorw	%di, %di
 	movw	%di, %es	/* ES:DI=0000:0000 */
 	movw	$32, %cx
+
+	cli		/* added 2008-08-04 */
 	cld
 	repz movsl
+	sti		/* added 2008-08-04 */
+
 	popw	%cx
 	popw	%si
 	popw	%di
@@ -8721,6 +8750,7 @@
 	/* It could hang when we call int 02 on some machines, so we end it. */
 	/* It could hang when we call int 08 on some machines, so we end it. */
 	/* It could hang when we call int 76 on some machines, so we end it. */
+	/* It could hang when we call int 05 on some machines, so we end it. */
 
 	/* %cs:ABS_START(tmp_vector) stores DI which points to the current vector */ 
 
@@ -8734,9 +8764,11 @@
 	cmpl	$ABS_START(bios_interrupt_vector_table) + 0x20, %eax
 	je	fault_recovery_handler	/* it is int 08, stop now */
 	cmpl	$ABS_START(bios_interrupt_vector_table) + 0x1D8, %eax
-	je	fault_recovery_handler	/* it is int 08, stop now */
+	je	fault_recovery_handler	/* it is int 76, stop now */
+	cmpl	$ABS_START(bios_interrupt_vector_table) + 0x14, %eax
+	je	fault_recovery_handler	/* it is int 05, stop now */
 
-	/* not int 02, 08, 76 continue */
+	/* not int 02, 08, 76, 05 continue */
 
 4:
 
@@ -8882,10 +8914,13 @@
 	movw	%cs:ABS_START(original_registers) + 8, %ss
 	movl	%cs:ABS_START(original_registers) + 12, %esp
 
+	/* stack is available, so we can push and pop. */
+
 	pushl	$0
 	popfl			#; CLD, CLI, Clear TF and many more...
 
-	cli
+	//cli		/* marked off 2008-08-04 */
+	sti		/* added 2008-08-04 */
 	movw	%cs:ABS_START(original_registers), %ds
 	movw	%cs:ABS_START(original_registers) + 4, %es
 	//movw	%cs:ABS_START(original_registers) + 8, %ss
@@ -8898,8 +8933,6 @@
 	movl	%cs:ABS_START(original_registers) + 36, %edi
 	movl	%cs:ABS_START(original_registers) + 40, %ebp
 
-	/* stack is available, so we can push and pop. */
-
 	pushw	$ABS_START(restore_int_00_1F)	/* return address */
 	ret
 
@@ -9102,20 +9135,6 @@
 
 move_stage2_image:
 
-#if 0
-	/* open video */
-	
-	movw	$0x1200, %ax
-	movb	$0x32, %bl
-	int	$0x10
-
-	movb	$0x0f, %ah	/* get current display mode */
-	int	$0x10
-	
-	xorb	%ah, %ah
-	andb	$0x7f, %al
-#endif
-
 #if 1
 
 	/* The Chinese DOS display systems are in graphics mode and cause
@@ -9129,96 +9148,10 @@
 #endif
 
 	movw	%cs, %ax
-	movw	%ax, %ds
-
-#if 0
-	/* restore mapped int13 */
-	
-	movw	$ABS_START(mapped_int13_vector_BIOS), %si
-	
-	xorw	%ax, %ax
-	movw	%ax, %es	#; ES=0
-	lodsl
-	movl	%eax, %ecx
-	lodsl
-	testl	%eax, %eax
-	jz	1f
-	movw	$0x004c, %di	/* int13 */
-	movl	%es:(%di), %ebx
-	testw	%bx, %bx
-	jnz	1f
-	shrl	$16, %ebx
-	cmpw	%cx, %bx
-	jnz	1f
-	stosl			/* write to 0000:004c */
-	shrl	$16, %ecx
-	movw	$0x0413, %di
-	movw	%cx, %ax
-	stosw			/* write to 0000:0413 */
-
-	/* restore int15 */
-	movw	$0x0054, %di	/* int15 */
-	cmpw	%es:2(%di), %bx	#; Is int15 routine in the same segment? 
-	jne	1f		#; no, needn't restore int15
-
-	movw	%es:(%di), %di
-//	cmpw	$0x0c00, %di	/* 3K = 0x0c00 */
-//	jnb	1f
-	movw	%di, %ax
-	shrw	$4, %ax
-	addw	%bx, %ax	#; AX=linear address by paragraphs of int15 service routine
-	cmpw	$0xA000, %ax	#; exceeds 640K ?
-	jnb	1f		#; yes, fail to restore int15
-	
-	movw	%bx, %es		#; ES=segment of int13 service routine
-	movl	%es:-4(%di), %eax	/* ROM_int15 */
-	cmpl	$0xc0000000, %eax	#; a ROM vector?
-	jb	1f			#; no, fail to restore int15
-
-	movw	%es:-6(%di), %cx	#; CH=harddrives byte, CL=floppies byte
-
-	xorw	%bx, %bx
-	movw	%bx, %es		#; ES=0
-
-	movw	$0x0054, %di	/* int15 */
-	stosl
-	
-	movb	%cl, %es:0x0410	/* floppies byte */
-	movb	%ch, %es:0x0475	/* harddrives byte */
-1:
-	/* original floppy parameter table */
-
-	/* it is safe to call int13 here, since int13 vector has been
-	 * restored.
-	 */
-	movb	$8, %ah
-	movb	$0, %dl
-	stc
-	int	$0x13
-	jc	1f
-	orw	%bx, %ax
-	orw	%cx, %ax
-	jz	1f
-	movw	%es, %ax
-	testw	%ax, %ax
-	jz	1f
-	movw	%es, %bx
-	xorw	%ax, %ax
-	movw	%ax, %es
-	movw	%es:0x007a, %ax		/* int1e segment */
-	cmpw	$0xc000, %ax
-	jnb	1f
-	movw	%bx, %es:0x007a
-	movw	%di, %es:0x0078
-1:
-#endif
-
-	movw	%cs, %ax
 	movw	%ax, %ds		/* DS=CS */
 	xorw	%ax, %ax
 	movw	%ax, %es		/* ES=0 */
 
-#if 1
 	/* move command-line menu from CS:0081 to 0000:0800 */
 	movw	$0x0081, %si		/* DS=CS */
 	movw	$0x0800, %di		/* ES=0 */
@@ -9226,8 +9159,17 @@
 	cld
 	repz movsl
 	stosb				/* end in NULL */
-#endif
 
+	/* the stack 0000:2000 is safe because this is where the dos kernel
+	 * code was living, and dos cannot load grub.exe below 0000:2000.
+	 */
+
+	cli			/* added 2008-08-04 */
+	xorw	%ax, %ax
+	movw	%ax, %ss
+	movw	$0x2000, %sp
+	sti			/* added 2008-08-04 */
+
 	movw	$ABS_START(stage2_64K_pages), %si
 	movw	(%si), %cx
 
@@ -9236,6 +9178,7 @@
 	movw	%ax, %bx	/* save the final stage2 segment to BX */
 	cmpw	$0x0800, %ax
 	ja	2f		/* move from higher at BX:0000 to lower at 0800:0000 */
+
 	/* move from lower at BX:0000 to higher at 0800:0000 */
 1:
 	xorw	%ax, %ax
@@ -9280,14 +9223,6 @@
 //////////////////////////////////////////////////////////////////////////////
 
 	/* The final sector begins here! */
-#if 1
-	/* update: the address of the commandline embedded preset menu has
-	 * changed to physical address 0x800.
-	 */
-#else
-	/* room for the new preset menu (only 0x80 byte needed) */
-	. = . + 0x80
-#endif
 
 2:
 	/* move from higher at BX:0000 to lower at 0800:0000.
@@ -9312,10 +9247,7 @@
 	movw	%bx, %ds
 	movw	%cx, %dx	/* save %cx to %dx */
 	movw	$0x0100, %cx	/* move the sector containing this code */
-	cli
-//	xorw	%ax, %ax
-//	movw	%ax, %ss
-//	movw	$0x2000, %sp
+	//cli			/* marked off 2008-08-04 */
 	cld
 	repz movsw
 	movw	%dx, %cx	/* restore %cx from %dx */
@@ -9327,17 +9259,6 @@
 
 	ljmp	$0x07e0, $ABS_FINAL(1f)
 
-#if 1	
-	/* update: our stack has changed to dos_stack. */
-#else
-	. = 2b + 0x80
-
-	/* room for stack, 0x80 bytes */
-	. = . + 0x80
-
-#endif
-
-//just_here:
 1:
 	/* from here on, code must be in the FINAL sector */
 	movw	$0x0800, %ax
@@ -9359,36 +9280,21 @@
 
 launch_stage2_code:
 
-	cli
 	cld
 	xorw	%ax, %ax
 	movw	%ax, %ds
 	movw	%ax, %es
+	cli
 	movw	%ax, %ss
 	movw	$0x2000, %sp
+	sti			/* added 2008-08-04 */
 	xchgb	%al, 0x820B	# AL=boot_drive, and clear the byte at 0x820B
 	xchgw	%ax, %dx	# DL=boot_drive
 	xorl	%ebp, %ebp
 	xorl	%esi, %esi
-	/* for usb keyborad hack here, disable interrupt */
-	//sti		/* safe now, just before transferring control */
+
 	ljmp	$0, $0x8200
 	
-#if 0
-	/* print ASCIZ string CS:SI (modifies AX BX SI) */
-3:
-	xorw	%bx, %bx	/* video page 0 */
-	movb	$0x0e, %ah	/* print char in AL */
-	int	$0x10		/* via TTY mode */
-
-print_message_dos:
-
-	lodsb	%cs:(%si), %al	/* get token */
-	cmpb	$0, %al		/* end of string? */
-	jne	3b
-	ret
-#endif
-
 	. = 2b + 0x200
 #-----------------------------------------------------------------------------
 #			EXE code ends here
Index: stage2/builtins.c
===================================================================
--- stage2/builtins.c	(revision 60)
+++ stage2/builtins.c	(working copy)
@@ -55,7 +55,7 @@
 kernel_t kernel_type;
 static kernel_t kernel_type_orig;
 /* The boot device.  */
-static int bootdev;
+static int bootdev = 0;
 #if 0
 /* True when the debug mode is turned on, and false
    when it is turned off.  */
@@ -75,8 +75,8 @@
 /* The number of current entry.  */
 int current_entryno;
 /* The address for Multiboot command-line buffer.  */
-static char *mb_cmdline;
-static char kernel_option_video[64];
+static char *mb_cmdline;// = (char *) MB_CMDLINE_BUF;
+static char kernel_option_video[64] = {0};/* initialize the first byte to 0 */
 /* The password.  */
 char *password;
 /* The password type.  */
@@ -121,6 +121,7 @@
 /* The BIOS drive map.  */
 extern struct drive_map_slot   bios_drive_map[DRIVE_MAP_SIZE + 1];
 extern struct drive_map_slot hooked_drive_map[DRIVE_MAP_SIZE + 1];
+int drive_map_slot_empty (struct drive_map_slot item);
 
 /* backup of original BIOS floppy-count byte in 0x410 */
 extern char floppies_orig;
@@ -169,13 +170,15 @@
 static int is_raw_orig = 0;
 static int is_isolinux = 0;
 static int is_isolinux_orig = 0;
+static int is_io = 0;
+static int is_io_orig = 0;
 static char chainloader_file[256];
 static char chainloader_file_orig[256];
 
 static const char *warning_defaultfile = "# WARNING: If you want to edit this file directly, do not remove any line";
 
 #ifndef GRUB_UTIL
-static int
+int
 drive_map_slot_empty (struct drive_map_slot item)
 {
 	unsigned long *array = (unsigned long *)&item;
@@ -218,29 +221,9 @@
 //static int real_open_partition (int flags);
 //static int open_partition (void);
 int commandline_func (char *arg, int flags);
+int errnum_func (char *arg, int flags);
+int checkrange_func (char *arg, int flags);
 
-/* Initialize the data for builtins.  */
-void
-init_builtins (void)
-{
-  kernel_type = KERNEL_TYPE_NONE;
-  /* BSD and chainloading evil hacks!  */
-  bootdev = set_bootdev (0);
-  mb_cmdline = (char *) MB_CMDLINE_BUF;
-  *kernel_option_video = 0; /* initialize the string to be empty. */
-}
-
-/* Initialize the data for the configuration file.  */
-void
-init_config (void)
-{
-  default_entry = 0;
-  password = 0;
-  fallback_entryno = -1;
-  fallback_entries[0] = -1;
-  grub_timeout = -1;
-}
-
 /* Check a password for correctness.  Returns 0 if password was
    correct, and a value != 0 for error, similarly to strcmp. */
 int
@@ -1046,7 +1029,7 @@
 {
   "boot",
   boot_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "boot",
   "Boot the OS/chain-loader which has been loaded."
 };
@@ -1091,7 +1074,7 @@
 {
   "bootp",
   bootp_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
+  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "bootp [--with-configfile]",
   "Initialize a network device via BOOTP. If the option `--with-configfile'"
   " is given, try to load a configuration file specified by the 150 vendor"
@@ -1209,11 +1192,6 @@
     //j = skip;
     for (j = skip; j - skip < length && (len = grub_read ((char *)(SCRATCHADDR + 16), 16)); j += 16)
     {
-      //if (j == skip)
-      //{
-	//grub_memmove ((char *)SCRATCHADDR, (char *)(SCRATCHADDR + 16), 16);
-	//continue;
-      //}
       if (j != skip)
       for (i = 0; i < 16; i++)
 	if (! grub_memcmp ((char *)&s, (char *)(SCRATCHADDR + i), len1))
@@ -1235,60 +1213,12 @@
 
   }else if (Hex == 1)
   {
-#if 0
     for (j = skip; j - skip < length && (len = grub_read ((char *)&s, 16)); j += 16)
     {
-      /* print line number */
-      if (j < 0x00000010)
-        grub_printf ("0000000%X  ", j);
-      else if (j < 0x00000100)
-        grub_printf ("000000%X  ", j);
-      else if (j < 0x00001000)
-        grub_printf ("00000%X  ", j);
-      else if (j < 0x00010000)
-        grub_printf ("0000%X  ", j);
-      else if (j < 0x00100000)
-        grub_printf ("000%X  ", j);
-      else if (j < 0x01000000)
-        grub_printf ("00%X  ", j);
-      else if (j < 0x10000000)
-        grub_printf ("0%X  ", j);
-      else
-	grub_printf ("%X  ", j);
-      
-      /* print the hex values */
-      for (i = 0; i < 16; i++)
-      {
-	if (i < len && j + i - skip < length)
-	  grub_printf ("%X%X ", (s[i] >> 4), (s[i] & 0x0f));
-	else
-	  grub_printf ("   ");
-      }
-      
-      grub_putchar (' ');
-      
-      /* print the ascii values */
-      for (i = 0; i < 16; i++)
-      {
-	if (i >= len || j + i - skip >= length)
-	  s[i] = ' ';
-	if (s[i] < ' ' || s[i] >= 127)
-	  s[i] = '.';
-        grub_putchar (s[i]);
-      }
-      grub_putchar ('\n');
-      if (quit_print)
-	break;
-      //grub_printf ("%s\n", s);
-    }
-#else
-    for (j = skip; j - skip < length && (len = grub_read ((char *)&s, 16)); j += 16)
-    {
       hexdump(j,(char*)&s,(len>length+skip-j)?(length+skip-j):len);
       if (quit_print)
         break;
     }
-#endif
   }else
     for (j = 0; j < length && grub_read ((char *)&c, 1); j++)
     {
@@ -1326,13 +1256,13 @@
 static int
 cdrom_func (char *arg, int flags)
 {
-  char *p;
-  unsigned long tmp;
-  
   for (;;)
   {
     if (grub_memcmp (arg, "--add-io-ports=", 15) == 0)
       {
+	char *p;
+	unsigned long tmp;
+
 	p = arg + 15;
 	if (! safe_parse_maxint (&p, (int *)(void *)&tmp))
 		return 0;
@@ -1403,6 +1333,7 @@
   is_sdi_orig = is_sdi;
   is_raw_orig = is_raw;
   is_isolinux_orig = is_isolinux;
+  is_io_orig = is_io;
   kernel_type_orig = kernel_type;
   grub_memmove ((char *)chainloader_file_orig, (char *)chainloader_file, sizeof(chainloader_file));
 
@@ -1419,6 +1350,7 @@
   chainloader_disable_A20 = 0;
   is_sdi = is_raw = 0;
   is_isolinux = 0;
+  is_io = 0;
   kernel_type = KERNEL_TYPE_CHAINLOADER;
 
   for (;;)
@@ -1583,9 +1515,16 @@
   if ((is_sdi) || (is_raw))
     return 1;
 
+//  if (debug > 0)
+//	printf ("Debug: chainloader_func: set_device(%s) ...", arg);
+
   /* Get the drive number.  */
   filename = set_device (arg);
 
+//  if (debug > 0)
+//	/* wipe out debug message. */
+//	printf ("\r                                                                             \r");
+
   if (errnum) {
 	/* No device specified. Default to the root device. */
 	current_drive = saved_drive;
@@ -2026,13 +1965,33 @@
   }
 #endif /* ! GRUB_UTIL */
 
+//  if (debug > 0)
+//	printf ("Debug: chainloader_func: grub_open(%s)...", arg);
+
   /* Open the file.  */
-  if (! grub_open (arg))
+  grub_open (arg);
+
+//  if (debug > 0)
+//	/* wipe out debug message. */
+//	printf ("\r                                                                             \r");
+
+  if (errnum)
 	goto failure;
 
+//  if (debug > 0)
+//	printf ("Debug: chainloader_func: grub_read(512 bytes)...");
+
   /* Read the first block.  */
-  if (grub_read ((char *) SCRATCHADDR, 512) != 512)
+  {
+    unsigned long len;
+    len = grub_read ((char *) SCRATCHADDR, 512);
+//    if (debug > 0)
+//	/* wipe out debug message. */
+//	printf ("\r                                                                             \r");
+
+    if (len != 512)
 	goto failure_exec_format;
+  }
 
   if (chainloader_skip_length > filemax)
   {
@@ -2178,6 +2137,7 @@
 	if (grub_read ((char *) SCRATCHADDR, 512) != 512)
 		goto failure_exec_format;
 
+	is_io = 1;
 	/* modify the hidden sectors */
 	/* FIXME: Does the boot drive number also need modifying? */
 	
@@ -2300,6 +2260,7 @@
   is_sdi = is_sdi_orig;
   is_raw = is_raw_orig;
   is_isolinux = is_isolinux_orig;
+  is_io = is_io_orig;
   kernel_type = kernel_type_orig;
   force = errnum;	/* backup the errnum */
   grub_memmove ((char *)chainloader_file, (char *)chainloader_file_orig, sizeof(chainloader_file));
@@ -2312,7 +2273,7 @@
 {
   "chainloader",
   chainloader_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "chainloader [--force] [--load-segment=LS] [--load-offset=LO]"
   "\n[--load-length=LL] [--skip-length=SL] [--boot-cs=CS] [--boot-ip=IP]"
   "\n[--ebx=EBX] [--edx=EDX] [--sdi] [--disable-a20] FILE",
@@ -2415,7 +2376,7 @@
 {
   "cmp",
   cmp_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
   "cmp FILE1 FILE2",
   "Compare the file FILE1 with the FILE2 and inform the different values"
   " if any."
@@ -2672,7 +2633,7 @@
 {
   "configfile",
   configfile_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "configfile FILE",
   "Load FILE as the configuration file."
 };
@@ -2994,6 +2955,82 @@
 
 #endif /* SUPPORT_GRAPHICS */
 
+static int
+in_range (char *range, int val)
+{
+  int start_num;
+  int end_num;
+
+  for (;;)
+  {
+    if (! safe_parse_maxint (&range, &start_num))
+	break;
+    if (val == start_num)
+	return 1;
+    if (*range == ',')
+    {
+	range++;
+	continue;
+    }
+    if (*range != ':')
+	break;
+
+    range++;
+    if (! safe_parse_maxint (&range, &end_num))
+	break;
+    if (val > start_num && val <= end_num)
+	return 1;
+    if ((unsigned)val > (unsigned)start_num && (unsigned)val <= (unsigned)end_num)
+	return 1;
+    if (*range != ',')
+	break;
+
+    range++;
+  }
+
+  errnum = 0;
+  return 0;
+}
+
+/* checkrange */
+int
+checkrange_func(char *arg, int flags)
+{
+  struct builtin *builtin1;
+  int ret;
+  char *arg1;
+
+  arg1 = skip_to (0, arg);	/* the command */
+
+  builtin1 = find_command (arg1);
+
+  if (! builtin1 || ! (builtin1->flags & flags))
+  {
+	errnum = ERR_UNRECOGNIZED;
+	return 0;
+  }
+
+  arg1 = skip_to (1, arg1);	/* get argument of command */
+  if ((builtin1->func) != errnum_func && (builtin1->func) != checkrange_func)
+	errnum = 0;
+  ret = (builtin1->func) (arg1, flags);
+
+  if ((builtin1->func) == errnum_func /*|| (builtin1->func) == checkrange_func*/)
+	errnum = 0;
+  if (errnum)
+	return 0;
+
+  return in_range (arg, ret);
+}
+
+static struct builtin builtin_checkrange =
+{
+  "checkrange",
+  checkrange_func,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "checkrange RANGE COMMAND",
+  "Return true if the return value of COMMAND is in RANGE and false otherwise."
+};
 #ifndef GRUB_UTIL
 /* checktime */
 static int
@@ -3450,7 +3487,7 @@
 {
   "embed",
   embed_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "embed STAGE1_5 DEVICE",
   "Embed the Stage 1.5 STAGE1_5 in the sectors after MBR if DEVICE"
   " is a drive, or in the \"bootloader\" area if DEVICE is a FFS partition."
@@ -3459,9 +3496,11 @@
 
 
 /* errnum */
-static int
+int
 errnum_func (char *arg, int flags)
 {
+  if (debug > 0 && flags == BUILTIN_CMDLINE)
+      grub_printf (" ERRNUM is %d\n", errnum);
   return errnum;
 }
 
@@ -3482,7 +3521,11 @@
 
   /* If ARG is empty, toggle the flag.  */
   if (! *arg)
+  {
     errorcheck = ! errorcheck;
+    if (debug > 0 && flags == BUILTIN_CMDLINE)
+      grub_printf (" Error check is toggled now to be %s\n", errorcheck ? "on" : "off");
+  }
   else if (grub_memcmp (arg, "on", 2) == 0)
     errorcheck = 1;
   else if (grub_memcmp (arg, "off", 3) == 0)
@@ -3576,7 +3619,7 @@
 {
   "commandline",
   commandline_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
 #if 1
   "commandline",
   "Enter command-line prompt mode."
@@ -3838,33 +3881,6 @@
     for (drive = 0; drive < 0 + FIND_DRIVES; drive++)
 #undef FIND_DRIVES
     {
-      extern int biosdisk_standard (int ah, int drv, int coff, int hoff, int soff, int nsec, int segment);
-      
-#if 0
-#ifndef GRUB_UTIL
-      /* Check if the media is present using int13/ah=04h (verify sectors) */
-      if (flags != BUILTIN_CMDLINE)
-      {
-	/* if boot device is not floppy, don't search floppy. */
-	if ((unsigned char)boot_drive >= 0x80 || install_partition != 0xFFFFFF)
-	  continue;
-	
-	/* if floppy is not inserted at boot time, ignore it. */
-	if (floppy_not_inserted[drive])
-	  continue;
-      }else{
-	floppy_not_inserted[drive] = 0;
-      }
-      if (biosdisk_standard (0x04, drive, 0, 0, 1, 1, SCRATCHSEG))
-      {
-	/* floppy not inserted */
-	if (flags != BUILTIN_CMDLINE)
-	  floppy_not_inserted[drive] = 1;
-	continue;
-      }
-#endif
-#endif
-      
       current_drive = drive;
       current_partition = 0xFFFFFF;
       
@@ -4032,13 +4048,21 @@
       return 0;
     }
 
+#if 0
+	/* The situation described as follows should never occur. So comment
+	 * out. Another reson to comment out: the SCRATCHSEG has only 512
+	 * byte room and it cannot hold a large 2048-byte cdrom sector.
+	 *
+	 *		Commented out 2008-09-30 by Tinybit.
+	 */
+
   /* Attempt to read the first sector, because some BIOSes turns out not
      to support LBA even though they set the bit 0 in the support
      bitmap, only after reading something actually.  */
 #ifdef GRUB_UTIL
   if (current_drive != cdrom_drive)
 #else
-  if (current_drive != cdrom_drive && (current_drive < min_cdrom_id || current_drive >= min_cdrom_id + atapi_dev_count))
+  if (current_drive != cdrom_drive && (current_drive < (unsigned char)min_cdrom_id || current_drive >= (unsigned char)(min_cdrom_id + atapi_dev_count)))
 #endif /* GRUB_UTIL */
   {
     if (biosdisk (BIOSDISK_READ, current_drive, &tmp_geom, 0, 1, SCRATCHSEG))
@@ -4050,6 +4074,7 @@
 //	return 0;
     }
   }
+#endif
 
 #ifdef GRUB_UTIL
   arg/*ptr*/ = skip_to (0, arg/*device*/);
@@ -4086,7 +4111,9 @@
 #ifdef GRUB_UTIL
   msg = device_map[current_drive];
 #else
-  if (tmp_geom.flags & BIOSDISK_FLAG_LBA_EXTENSION)
+  if (tmp_geom.flags & BIOSDISK_FLAG_BIFURCATE)
+    msg = "BIF";
+  else if (tmp_geom.flags & BIOSDISK_FLAG_LBA_EXTENSION)
     msg = "LBA";
   else
     msg = "CHS";
@@ -4099,7 +4126,7 @@
 #ifdef GRUB_UTIL
   if (current_drive != cdrom_drive)
 #else
-  if (current_drive != cdrom_drive && (current_drive < min_cdrom_id || current_drive >= min_cdrom_id + atapi_dev_count))
+  if (current_drive != cdrom_drive && (current_drive < (unsigned char)min_cdrom_id || current_drive >= (unsigned char)(min_cdrom_id + atapi_dev_count)))
 #endif /* GRUB_UTIL */
     if (current_drive & 0x80)
       real_open_partition (1);
@@ -4139,7 +4166,7 @@
 {
   "halt",
   halt_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "halt [--no-apm]",
   "Halt your system. If APM is avaiable on it, turn off the power using"
   " the APM BIOS, unless you specify the option `--no-apm'."
@@ -5039,7 +5066,7 @@
 {
   "install",
   install_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "install [--stage2=STAGE2_FILE] [--force-lba] STAGE1 [d] DEVICE\n STAGE2 [ADDR] [p] [CONFIG_FILE] [REAL_CONFIG_FILE]",
   "Install STAGE1 on DEVICE, and install a blocklist for loading STAGE2"
   " as a Stage 2. If the option `d' is present, the Stage 1 will always"
@@ -5058,51 +5085,6 @@
 };
 
 
-#if 0
-/* ioprobe */
-static int
-ioprobe_func (char *arg, int flags)
-{
-#ifdef GRUB_UTIL
-  
-  errnum = ERR_UNRECOGNIZED;
-  return 0;
-  
-#else /* ! GRUB_UTIL */
-  
-  unsigned short *port;
-  
-  /* Get the drive number.  */
-  set_device (arg);
-  if (errnum)
-    return 0;
-
-  /* Clean out IO_MAP.  */
-  grub_memset ((char *) io_map, 0, IO_MAP_SIZE * sizeof (unsigned short));
-
-  /* Track the int13 handler.  */
-  track_int13 (current_drive);
-  
-  /* Print out the result.  */
-  for (port = io_map; *port != 0; port++)
-    grub_printf (" 0x%x", (unsigned int) *port);
-
-  return 1;
-  
-#endif /* ! GRUB_UTIL */
-}
-
-static struct builtin builtin_ioprobe =
-{
-  "ioprobe",
-  ioprobe_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE,
-  "ioprobe DRIVE",
-  "Probe I/O ports used for the drive DRIVE."
-};
-#endif
-
-
 /* is64bit */
 static int
 is64bit_func (char *arg, int flags)
@@ -5183,9 +5165,6 @@
       return 0;
     }
 
-  ///* Copy the command-line to MB_CMDLINE.  */
-  //grub_memmove (mb_cmdline, arg, len + 1);
-
   /* Copy the command-line to MB_CMDLINE and append the kernel_option_video
    * which might have been set by `setvbe'.
    */
@@ -5204,7 +5183,7 @@
 {
   "kernel",
   kernel_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "kernel [--no-mem-option] [--type=TYPE] FILE [ARG ...]",
   "Attempt to load the primary boot image from FILE. The rest of the"
   " line is passed verbatim as the \"kernel command line\".  Any modules"
@@ -5233,7 +5212,7 @@
 {
   "lock",
   lock_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
   "lock",
   "Break a command execution unless the user is authenticated."
 };
@@ -6323,8 +6302,8 @@
 	filename_bak = filename;
 	
 	/* read the first sector of drive TO */
-	grub_sprintf (/*(char *)SCRATCHADDR*/buf, "(%d)+1", to);
-	if (! grub_open (/*(char *)SCRATCHADDR*/buf))
+	grub_sprintf (buf, "(%d)+1", to);
+	if (! grub_open (buf))
 		return 0;
 
 	if (grub_read ((char *)SCRATCHADDR, SECTOR_SIZE) != SECTOR_SIZE)
@@ -6451,11 +6430,12 @@
     {
       if (mem != -1)
       {
+	char buf[32];
+
 	grub_close ();
-	/* Use SCRATCHADDR instead of BS, since BS holds the sector data. */
 	sector_count = part_length;
-        grub_sprintf ((char *)SCRATCHADDR, "(%d)%d+%d", to, part_start, part_length);
-        if (! grub_open ((char *)SCRATCHADDR))
+        grub_sprintf (buf, "(%d)%d+%d", to, part_start, part_length);
+        if (! grub_open (buf))
 		return 0;
         filepos = SECTOR_SIZE;
       } else if (part_start) {
@@ -7274,11 +7254,16 @@
   bios_drive_map[i].max_head = disable_chs_mode | (heads_per_cylinder - 1);
   bios_drive_map[i].max_sector = (disable_chs_mode ? 0 : in_situ ? 1 : sectors_per_track) | ((read_Only | fake_write) << 7) | (disable_lba_mode << 6);
 
+  /* bit 12 is for "TO drive is bifurcate" */
+
   if (! in_situ)
-	bios_drive_map[i].to_cylinder = ((tmp_geom.flags & BIOSDISK_FLAG_LBA_EXTENSION) << 15) |
-					((tmp_geom.sector_size == 2048) << 14) |
-					((from >= 0xA0) << 13) |	/* assume cdrom if from_drive is 0xA0 or greater */
-					((tmp_geom.cylinders - 1 > 0x3FF) ? 0x3FF : (tmp_geom.cylinders - 1));
+	bios_drive_map[i].to_cylinder =
+		((tmp_geom.flags & BIOSDISK_FLAG_BIFURCATE) ? ((to & 0x100) >> 1) :
+		((tmp_geom.flags & BIOSDISK_FLAG_LBA_EXTENSION) << 15)) |
+		((tmp_geom.sector_size == 2048) << 14) |
+		((from >= 0xA0) << 13) |	/* assume cdrom if from_drive is 0xA0 or greater */
+		((!!(tmp_geom.flags & BIOSDISK_FLAG_BIFURCATE)) << 12) |
+		((tmp_geom.cylinders - 1 > 0x3FF) ? 0x3FF : (tmp_geom.cylinders - 1));
   
   bios_drive_map[i].to_head = tmp_geom.heads - 1;
 
@@ -8028,7 +8013,7 @@
 	  {
 		new_type = PC_SLICE_TYPE (mbr, entry1);
 		if (debug > 0)
-			printf ("Partition type for (hd%d,%d) is 0x%X\n", (current_drive & 0x7F), (current_partition >> 16), new_type);
+			printf ("Partition type for (hd%d,%d) is 0x%X.\n", (current_drive & 0x7F), (current_partition >> 16), new_type);
 		return new_type;
 	  }
 
@@ -8038,8 +8023,10 @@
 	  /* Write back the MBR to the disk.  */
 	  buf_track = -1;
 	  if (! rawwrite (current_drive, offset, mbr))
-	    return 0;
+	    break;	/* failure */
 
+	  if (debug > 0)
+		printf ("Partition type for (hd%d,%d) set to 0x%X successfully.\n", (current_drive & 0x7F), (current_partition >> 16), new_type);
 	  /* Succeed.  */
 	  errnum = 0;
 	  return 1;
@@ -8165,7 +8152,7 @@
   printf("%s\n", arg);
 
   /* Get current time.  */
-  while ((time1 = getrtsecs ()) == 0xFF);
+  while ((time2 = getrtsecs ()) == 0xFF);
 
   for (;;)
 	{
@@ -8212,7 +8199,7 @@
 {
   "pxe",
   pxe_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "pxe [cmd] [parameters]",
   "Call PXE command."
 };
@@ -8234,7 +8221,7 @@
 {
   "quit",
   quit_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "quit",
   "Exit from the GRUB shell."
 };
@@ -8327,7 +8314,7 @@
 {
   "quit",
   quit_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "quit [--disable-a20]",
   "Go back to DOS if GRUB was previously launched from DOS."
 };
@@ -8435,7 +8422,7 @@
 {
   "reboot",
   reboot_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "reboot",
   "Reboot your system."
 };
@@ -8640,16 +8627,34 @@
   
   if (next)
   {
-	if (chainloader_edx_set)
+	if (kernel_type == KERNEL_TYPE_CHAINLOADER)
 	{
+	  if (is_io)
+	  {
+		/* DL=drive, DH=media descriptor: 0xF0=floppy, 0xF8=harddrive */
+		chainloader_edx = (tmp_drive & 0xFF) | 0xF000 | ((tmp_drive & 0x80) << 4);
+		chainloader_edx_set = 1;
+
+		/* the user might wrongly set these argument, so force them to be correct */
+
+		chainloader_ebx = 0;    // clear BX for WinME
+		chainloader_ebx_set = 1;
+		chainloader_load_segment = 0x0070;
+		chainloader_load_offset = 0;
+		chainloader_skip_length = 0x0800;
+	  } else {
+	    if (chainloader_edx_set)
+	    {
 		chainloader_edx &= 0xFFFF0000;
-		chainloader_edx |= saved_drive | ((saved_partition >> 8) & 0xFF00);
-	}
+		chainloader_edx |= tmp_drive | ((tmp_partition >> 8) & 0xFF00);
+	    }
 
-	if (chainloader_ebx_set && chainloader_ebx)
-	{
+	    if (chainloader_ebx_set && chainloader_ebx)
+	    {
 		chainloader_ebx &= 0xFFFF0000;
-		chainloader_ebx |= saved_drive | ((saved_partition >> 8) & 0xFF00);
+		chainloader_ebx |= tmp_drive | ((tmp_partition >> 8) & 0xFF00);
+	    }
+	  }
 	}
 
 	saved_partition = tmp_partition;
@@ -9795,7 +9800,7 @@
 {
   "setup",
   setup_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST | BUILTIN_BOOTING,
   "setup [--prefix=DIR] [--stage2=STAGE2_FILE] [--force-lba]\n INSTALL_DEVICE [IMAGE_DEVICE]",
   "Set up the installation of GRUB automatically. This command uses"
   " the more flexible command \"install\" in the backend and installs"
@@ -10405,7 +10410,13 @@
   struct vbe_mode *mode2;
 
   if (!*arg)
-    return 0;
+  {
+    *kernel_option_video = 0; /* initialize the string to be empty. */
+    if (debug > 0)
+      grub_printf ("\nVideo option cleared. Nothing will be added to subsequent kernel command-line.\n");
+    errnum = 0;
+    return 1;
+  }
 
   errnum = ERR_BAD_ARGUMENT;
   if (! safe_parse_maxint (&arg, &width))
@@ -10475,8 +10486,10 @@
   "setvbe",
   setvbe_func,
   BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-  "setvbe MODE_3D",
+  "setvbe [MODE_3D]",
   "Set the VBE mode MODE_3D(which is of the form 1024x768x32) for each subsequent kernel command-line."
+  " If no argument is specified, clear(nullify, invalidate) the video option"
+  " string setup by the previous setvbe command."
 };
 
 
@@ -10550,6 +10563,37 @@
 };
 
 
+#if ! defined(GRUB_UTIL) && ! defined (STAGE1_5)
+extern int tpm_init(void);
+/* tpm */
+static int
+tpm_func (char *arg, int flags)
+{
+  for (;;)
+  {
+    if (grub_memcmp (arg, "--init", 6) == 0)
+      {
+	return tpm_init();
+      }
+    else
+      return ! (errnum = ERR_BAD_ARGUMENT);
+    arg = skip_to (0, arg);
+  }
+  
+  return 1;
+}
+
+static struct builtin builtin_tpm =
+{
+  "tpm",
+  tpm_func,
+  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
+  "tpm --init",
+  "Initialise TPM."
+};
+#endif /* ! defined(GRUB_UTIL) && ! defined (STAGE1_5) */
+
+
 /* unhide */
 static int
 unhide_func (char *arg, int flags)
@@ -10723,6 +10767,7 @@
   &builtin_cdrom,
 #endif
   &builtin_chainloader,
+  &builtin_checkrange,
 #ifndef GRUB_UTIL
   &builtin_checktime,
 #endif
@@ -10827,6 +10872,9 @@
 #endif /* SUPPORT_NETBOOT */
   &builtin_timeout,
   &builtin_title,
+#if ! defined(GRUB_UTIL) && ! defined (STAGE1_5)
+  &builtin_tpm,
+#endif /* ! defined(GRUB_UTIL) && ! defined (STAGE1_5) */
   &builtin_unhide,
 //  &builtin_uppermem,
   &builtin_vbeprobe,
Index: stage2/asm.S
===================================================================
--- stage2/asm.S	(revision 60)
+++ stage2/asm.S	(working copy)
@@ -162,6 +162,8 @@
 	movw	%ax, %ss
 	movl	$STACKOFF, %esp
 
+	sti		/* added 2008-08-04 */
+
 #ifndef STAGE1_5
 	movb	0x0410, %al
 	movb	%al, ABS(floppies_orig)
@@ -213,6 +215,13 @@
 	movw	$ABS(int13_handler + 1), %di		/* ES=0 */
 	repz movsb
 
+	/* calculate the new max_cdrom_id. */
+	movw	$2, %si
+	lodsw				/* AL=atapi_dev_count, AH=min_cdrom_id */
+	addb	%ah, %al
+	decw	%ax			/* AL=max_cdrom_id */
+	movb	%al, %cs:ABS(max_cdrom_id)		/* CS=0 */
+
 	/* initialize bios_drive_map with hooked_drive_map */
 	movw	$(DRIVE_MAP_SIZE * DRIVE_MAP_SLOT_SIZE / 2), %cx
 	movw	$ABS(hooked_drive_map), %si		/* CS=0 */
@@ -602,6 +611,7 @@
 	 *  of it's own initialization before transferring to "cmain".
 	 */
 	call EXT_C(init_bios_info)
+	call EXT_C(cmain)
 
 
 /*
@@ -665,6 +675,7 @@
 
 print_message:
 1:
+	sti		/* for hardware interrupt or watchdog */
 	cld
 	lodsb	(%si), %al	/* get token */
 	xorw	%bx, %bx	/* video page 0 */
@@ -701,6 +712,7 @@
 	call	EXT_C(prot_to_real)
 	.code16
 
+	sti		/* for hardware interrupt or watchdog */
 	movw	$0x5650, %ax
 	int	$0x1A
 	cmpw	$0x564E, %ax
@@ -773,6 +785,7 @@
 	call	EXT_C(prot_to_real)
 	.code16
 	
+	sti		/* for hardware interrupt or watchdog */
 	pushl	%ebx
 	pushl	%edx
 	pushw	%cx
@@ -819,6 +832,7 @@
 	call	EXT_C(prot_to_real)
 	.code16
 
+	sti		/* for hardware interrupt or watchdog */
 	pushl	%ebx
 	pushl	%edx
 	pushw	$0x22		// PXENV_TFTP_READ
@@ -1026,6 +1040,54 @@
 	ret
 
 
+/*
+ * int tpm_init (void)
+ *      return non-zero for success and zero for failure.
+ */
+ENTRY(tpm_init)
+	pushl	%ebp
+	pushl	%ebx
+	pushl	%esi
+	pushl	%edi
+	
+	call	EXT_C(prot_to_real)	/* enter real mode */
+
+	.code16
+
+	sti
+
+	movw	$0xBB00, %ax
+	int	$0x1A
+	testl	%eax, %eax
+	jnz	1f			/* failure */
+	cmpl	$0x41504354, %ebx	/* "TCPA" */
+	jnz	1f			/* failure */
+	cmpw	$0x102, %cx		/* TCG BIOS version 1.2 */
+	jb	1f			/* failure */
+	movw	%ax, %es		/* ES=0 */
+	movw	$0xBB07, %ax		/* eax hi word=0 */
+	movl	$0x00000200, %ecx	/* buffer size to hash */
+	movl	$0x00000008, %edx	/* PCR index for the hashed result */
+	xorl	%esi, %esi		/* place 0 into the event field */
+	movl	$0x00007C00, %edi	/* ES:DI point to data buffer to hash */
+	int	$0x1A
+	
+	testl	%eax, %eax
+1:
+	setz	%dl
+
+	DATA32	call	EXT_C(real_to_prot)
+	.code32
+
+	movzbl	%dl, %eax
+
+	popl	%edi
+	popl	%esi
+	popl	%ebx
+	popl	%ebp
+	ret
+
+
 /* Catch CPU exceptions 0 - 7
  *	0	Divide
  *	1	Debug
@@ -1192,192 +1254,7 @@
 
 	.code32
 
-#if 0	
 /*
- * track_int13(int drive)
- *
- * Track the int13 handler to probe I/O address space.
- */
-ENTRY(track_int13)
-	pushl	%ebp
-	movl	%esp, %ebp
-
-	pushl	%ebx
-	pushl	%edi
-
-	/* copy the original int13 handler segment:offset */
-	movl	$0x4c, %edi
-	movl	(%edi), %eax
-	movl	%eax, track_int13_addr
-		
-	/* replace the int1 handler */
-	movl	$0x4, %edi
-	pushl	(%edi)
-	movl	$ABS(int1_handler), %eax
-	movl	%eax, (%edi)
-
-	/* read the MBR to call int13 successfully */
-	movb	8(%ebp), %dl
-	
-	call	EXT_C(prot_to_real)
-
-	.code16
-
-	//sti		/* it is not bad keeping interrupt off */
-
-	movw	$SCRATCHSEG, %ax
-	movw	%ax, %es
-	xorw	%bx, %bx
-	movw	$1, %cx
-	xorb	%dh, %dh
-
-	/* save FLAGS on the stack to emulate int13 */
-	pushfw
-	
-	/* set the TF flag */
-	/* FIXME: this can be simplified not to use AX */
-	pushfw
-	popw	%ax
-	orw	$0x100, %ax
-	pushw	%ax
-	popfw
-
-	movw	$0x0201, %ax
-
-	.byte	0x9a		/* lcall */
-track_int13_addr:
-	.word	0		/* offset */
-	.word	0		/* segment */
-
-	/* TF is cleared here automatically */
-	
-	DATA32	call	EXT_C(real_to_prot)
-	.code32
-
-	/* restore the int1 handler */
-	movl	$0x4, %edi
-	popl	(%edi)
-
-	popl	%edi
-	popl	%ebx
-	popl	%ebp
-	
-	ret
-
-
-/*
- * Check if the next instruction is I/O, and if this is true, add the
- * port into the io map.
- *
- * Note: Probably this will make the execution of int13 very slow.
- *
- * Note2: In this implementation, all we can know is I/O-mapped I/O. It
- * is impossible to detect memory-mapped I/O.
- */
-int1_handler:
-	.code16
-	
-	pushw	%bp
-	movw	%sp, %bp
-	pushw	%ds
-	pushw	%ax
-	pushw	%si
-	pushw	%dx
-	
-	/* IP */
-	movw	2(%bp), %si
-	/* CS */
-	movw	4(%bp), %ax
-	movw	%ax, %ds
-
-	/* examine the next instruction */
-1:	lodsb	(%si), %al
-	/* skip this code if it is a prefix */
-	cmpb	$0x2E, %al
-	je	1b
-	cmpb	$0x36, %al
-	je	1b
-	cmpb	$0x3E, %al
-	je	1b
-	cmpb	$0x26, %al
-	je	1b
-	cmpb	$0x64, %al
-	jl	2f
-	cmpb	$0x67, %al
-	jle	1b
-2:	cmpb	$0xF0, %al
-	jl	3f
-	cmpb	$0xF3, %al
-	jle	1b
-	
-3:	/* check if this code is out* or in* */
-
-	/* ins? or outs? */
-	cmpb	$0x6C, %al
-	jl	4f
-	cmpb	$0x6F, %al
-	jle	5f
-
-4:	/* in? or out? (register operand version) */
-	cmpb	$0xEC, %al
-	jl	6f
-	cmpb	$0xEF, %al
-	jle	5f
-	
-6:	/* in? or out? (immediate operand version) */
-	cmpb	$0xE4, %al
-	jl	8f
-	cmpb	$0xE7, %al
-	jg	8f
-
-7:	/* immediate has a port */
-	lodsb	(%si), %al
-	movzbw	%al, %dx
-	
-5:	/* %dx has a port */
-
-	/* set %ds to zero */
-	xorw	%ax, %ax
-	movw	%ax, %ds
-		
-	/* set %si to the io map */
-	movw	$ABS(EXT_C(io_map)), %si
-
-		
-9:	/* check if the io map already has the port */
-	lodsw	(%si), %ax
-	/* check if this is the end */
-	testw	%ax, %ax
-	jz	1f
-	/* check if this matches the port */
-	cmpw	%ax, %dx
-	jne	9b
-	/* if so, leave from this handler */
-	jmp	8f
-	
-1:	/* check for the buffer overrun */
-	cmpw	$(ABS(EXT_C(io_map)) + (IO_MAP_SIZE + 1) * 2), %si
-	je	8f
-	/* add the port into the io map */
-	movw	%dx, -2(%si)
-
-8:	/* restore registers */	
-	popw	%dx
-	popw	%si
-	popw	%ax
-	popw	%ds
-	popw	%bp
-
-	iret
-	
-	.code32
-
-ENTRY(io_map)
-	.space	(IO_MAP_SIZE + 1) * 2
-#endif
-
-
-/*
  * set_int15_handler(void)
  *
  * Set up int15_handler.
@@ -1729,12 +1606,22 @@
 
 	.byte	((int13_handler_end - int13_handler + 0x3ff) / 0x400)
 
-	/* 3-byte space reserved. */
+	/* 1-byte space reserved. */
+
+	. = int13_handler + 0x2
+
+ENTRY(atapi_dev_count)	.byte	0
+ENTRY(min_cdrom_id)	.byte	0xE0
 	
 	. = int13_handler + 0x4
+
 	/* Signature */
-	.ascii	"G4DS"
+	.ascii	"G4DS"		# Please don't use this signature any longer.
+				# This field might be used for other purposes.
+				# Use signature at offset 0x103 instead.
 	
+	. = int13_handler + 0x08
+
 	/* Version number */
 	.word	1
 
@@ -1815,168 +1702,152 @@
 
 	. = int13_handler + 0x140
 
+#if 0
 1:
-	cmpb	$0x1a, %ah	/* PS/2 low level format ESDI drive!!!! */
-	je	error_01_disable2	/* disabled in any case */
+	/* backup far return address */
+	popl	%cs:(int13_old_cs_ip - int13_handler)
 
-					/* (BP+10): old Flags */
-					/* (BP+8): return CS */
-					/* (BP+6): return IP */
-	cld
-	pushl	%eax			/* (BP+2): old EAX */
-	pushw	%bp			/* (BP+0): old BP */
-	movw	%sp, %bp		/* BP->old BP */
+	/* build new stack: flags */
+	popw	%cs:(int13_handler_end - 2 - int13_handler)
 
-/* EDD30 code imported from edd30.asm of Smart Boot Manager. */
+	/* backup old stack */
+	movw	%sp, %cs:(int13_old_sp - int13_handler)
+	movw	%ss, %cs:(int13_old_ss - int13_handler)
 
-/*
-#; asmsyntax=nasm
-#;
-#; CD-ROM Boot Extension v 1.1 for Smart Boot Manager
-#; 
-#; Copyright (C) 2000, Christopher Li <chrisl@gnuchina.org>.
-#; Copyright (C) 2000, James Su <suzhe@gnuchina.org>
-#;
-#; This is free software, you can redistribute it and/or modify it
-#; under the terms of the GNU General Public License version 2 or above.
-#;
-#; The ATAPI driver is based on the source code of atadrv written by
-#; Hale Landis <hlandis@ibm.net>, Thanks him a lot!
-#;
-#; Without his great program, we could not implement the CD-ROM Boot feature
-#; so quickly.
-#;
-*/
+	/* build new stack pointer */
+	movw	$(int13_handler_end - 2 - int13_handler), %cs:(int13_new_sp - int13_handler)
+	movw	%cs, %cs:(int13_new_ss - int13_handler)
 
+	/* switch to new stack */
+	lssw	%cs:(int13_new_sp - int13_handler), %sp
 
-//#define	EDD_3_0
+	//pushfw			/* flags already on stack */
+	pushw	%cs
+	call	1f
 
-#define	sane_check
-#define	check_extra_fail
+	/* restore old stack */
+	lssw	%cs:(int13_old_sp - int13_handler), %sp
 
-//#define CB_DATA	0	//; data reg         in/out pio_base_addr1+0
-//#define CB_FR		1	//; feature reg         out pio_base_addr1+1
-//#define CB_SC		2	//; sector count     in/out pio_base_addr1+2
-//#define CB_SN		3	//; sector number    in/out pio_base_addr1+3
-//#define CB_CL		4	//; cylinder low     in/out pio_base_addr1+4
-//#define CB_CH		5	//; cylinder high    in/out pio_base_addr1+5
-//#define CB_DH		6	//; device head      in/out pio_base_addr1+6
-//#define CB_STAT	7	//; primary status   in     pio_base_addr1+7
-//#define CB_CMD	7	//; command             out pio_base_addr1+7
-//#define CB_DC		8	//; device control      out pio_base_addr2+6
-//#define CB_ASTAT	8	//; alternate status in     pio_base_addr2+6
-//#define CB_DC_SRST	0x04	//; soft reset
-#define	CB_STAT_BSY	0x80	//; busy
-#define	CB_STAT_RDY	0x40	//; ready
-#define	CB_STAT_SKC	0x10	//; seek complete
+	/* transfer control to caller */
+	ljmp	*%cs:(int13_old_cs_ip - int13_handler)
 
-#define	CB_STAT_DRQ	0x08	//; data request
-#define	CB_STAT_ERR	0x01	//; error
+	//iret				/* never reach here */
 
-#define	CB_SC_P_TAG	0xf8	//; ATAPI tag (mask)
-#define	CB_SC_P_REL	0x04	//; ATAPI release
-#define	CB_SC_P_IO	0x02	//; ATAPI I/O
-#define	CB_SC_P_CD	0x01	//; ATAPI C/D
+	.align	4
 
-#define	FAILBIT8	0x0100	//; SC( CD/IO bits) wrong at end of cmd
-#define	FAILBIT6	0x0040	//; byte count wrong at data packet xfer time
-#define	FAILBIT5	0x0020	//; SC (IO bit) wrong at data packet xfer time
-#define	FAILBIT4	0x0010	//; SC (CD bit) wrong at data packet xfer time
-#define	FAILBIT3	0x0008	//; byte count wrong at cmd packet xfer time
-#define	FAILBIT2	0x0004	//; SC wrong at cmd packet xfer time
-#define	FAILBIT0	0x0001	//; slow setting BSY=1 or DRQ=1 after AO cmd
+int13_old_cs_ip:	.long	0
+int13_old_sp:		.word	0
+int13_old_ss:		.word	0
+int13_new_sp:		.word	0
+int13_new_ss:		.word	0
+		
+#endif
 
-#define	CB_DC_HD15	0x08	//; bit should always be set to one
-#define	CB_DC_NIEN	0x02	//; disable interrupts
-#define	cmd_DC	CB_DC_HD15
-#define cmd_DC_ni CB_DC_HD15 | CB_DC_NIEN
+1:
 
-#undef DEBUG
+	/* backup far return address */
+	popl	%cs:(int13_old_cs_ip - int13_handler)
 
-#ifdef DEBUG
-#include "debug.h"
-#endif
+	/* backup old flags */
+	popw	%cs:(int13_old_flags - int13_handler)
 
+#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+		/* original stack layout for reference */
+		/* BP+10: old Flags */
+		/* BP+ 8: return CS */
+		/* BP+ 6: return IP */
+		/* BP+ 2: old EAX */
+		/* BP+ 0: old BP */
+		/* BP- 2: old SI */
+		/* BP- 6: FROM, TO, Hmax, Smax */
+		/* BP-10: TO_C, TO_H, TO_S */
+		/* BP-14: StartLBA_Lo */
+		/* BP-18: StartLBA_Hi */
+		/* BP-22: S_count_Lo */
+		/* BP-26: S_count_Hi */
+#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+	cld
+	movl	%eax, %cs:(int13_old_eax - int13_handler)
+	movl	%ebx, %cs:(int13_old_ebx - int13_handler)
+	movl	%ecx, %cs:(int13_old_ecx - int13_handler)
+	movl	%edx, %cs:(int13_old_edx - int13_handler)
+	movl	%esi, %cs:(int13_old_esi - int13_handler)
+	movl	%edi, %cs:(int13_old_edi - int13_handler)
+	movl	%esp, %cs:(int13_old_esp - int13_handler)
+	movl	%ebp, %cs:(int13_old_ebp - int13_handler)
+	movw	%ds, %cs:(int13_old_ds - int13_handler)
+	movw	%es, %cs:(int13_old_es - int13_handler)
+
+	cmpb	$0x1a, %ah	/* PS/2 low level format ESDI drive!!!! */
+	je	error_01_disable	/* disabled in any case */
+
 	cmpb	$0, %cs:(atapi_dev_count - int13_handler)
-	jz	no_cdrom		/* no cdrom */
+	jz	1f		/* no cdrom */
 	cmpb	%cs:(min_cdrom_id - int13_handler), %dl
-	jb	not_cdrom_drv		/* not cdrom drive */
+	jb	1f		/* not cdrom drive */
 	cmpb	%cs:(max_cdrom_id - int13_handler), %dl
 	jbe	edd30_for_cdrom
+1:
 
-not_cdrom_drv:
-//	cmpb	$0, %cs:(emu_disk_type - int13_handler)
-//	je	not_emu_drv
-
-//	cmpb	%cs:(edd30_cdemu_spec - int13_handler + 2), %dl	#; struc_cdemu_spec.emu_drvid
-//	je	cdemu_int13h
-
-not_emu_drv:
-
-no_cdrom:
-
 /****************************************************************************/
-	pushw	%si			/* BP-2: old SI */
-
-	/* set %si to the drive map */
-	movw	$(hooked_drive_map - int13_handler), %si
-
 	/* find the drive number from the drive map */
-	subw	$DRIVE_MAP_SLOT_SIZE, %sp
+	movw	$(hooked_drive_map - int13_handler - DRIVE_MAP_SLOT_SIZE), %bp
 1:	
-	addw	$DRIVE_MAP_SLOT_SIZE, %sp
-	lodsl	%cs:(%si), %eax
-	pushl	%eax			/* BP-6: FROM, TO, Hmax, Smax */
-	lodsl	%cs:(%si), %eax
-	pushl	%eax			/* BP-10: TO_C, TO_H, TO_S */
-	lodsl	%cs:(%si), %eax
-	pushl	%eax			/* BP-14: StartLBA_Lo */
-	lodsl	%cs:(%si), %eax
-	pushl	%eax			/* BP-18: StartLBA_Hi */
-	lodsl	%cs:(%si), %eax
-	pushl	%eax			/* BP-22: S_count_Lo */
-	lodsl	%cs:(%si), %eax
-	pushl	%eax			/* BP-26: S_count_Hi */
+	addw	$DRIVE_MAP_SLOT_SIZE, %bp
+	movw	%bp, %cs:(int13_new_bp - int13_handler)
+	movl	%cs:(%bp), %eax		/* FROM, TO, Hmax, Smax */
 
-	movl	-6(%bp), %eax	/* FROM, TO, Hmax, Smax */
-
 	/* check if this is the end */
 	testl	%eax, %eax
-	jnz	3f		/* not end, continue */
+	jnz	3f			/* not end, continue */
 
-	movl	-14(%bp), %eax	/* StartLBA_Lo */
+	movl	%cs:8(%bp), %eax	/* StartLBA_Lo */
 	testl	%eax, %eax
-	jnz	3f		/* not end, continue */
+	jnz	3f			/* not end, continue */
 
-	movl	-22(%bp), %eax	/* S_count_Lo */
+	movl	%cs:16(%bp), %eax	/* S_count_Lo */
 	testl	%eax, %eax
-	jnz	3f		/* not end, continue */
-	movb	%dl, %al	/* FROM */
-	movb	%dl, %ah	/* TO */
-	movw	%ax, -6(%bp)
-	jmp	2f		/* map whole drive to itself signals the end */
+	jz	2f		/* map whole drive to itself signals the end */
 3:
 	/* Now this is a valid drive map slot */
-	movw	-6(%bp), %ax	/* AL=FROM, AH=TO */
-	cmpb	%al, %dl	/* check if this matches the drive number */
+	cmpb	%cs:(%bp), %dl	/* check if this matches the drive number */
 	jne	1b		/* no, continue to check the next map */
 
 	/* yes, found the map corresponding to drive DL */
 
-#;	movw	-4(%bp), %ax	/* AL=Hmax, AH=Smax */
-#;	andb	$0xC1, %ah	/* clear bit 5 - bit 1 */
-	testb	$0x80, -7(%bp) /* TO_S */
-	jnz	1f
+	movw	%cs:2(%bp), %ax		/* AL=Hmax, AH=Smax */
 
+	/* bit 1-5 already cleared for in-situ */
+	//andb	$0xC1, %ah		/* clear bit 5 - bit 1 */
+
+	testb	$0x80, %cs:7(%bp)	/* TO_S */
+	jnz	1f			/* in-situ */
+
 	/* non-zero StartLBA signals emulation */
 
-	movl	-14(%bp), %eax	/* StartLBA_Lo */
-	testl	%eax, %eax
+	cmpl	$0, %cs:8(%bp)		/* StartLBA_Lo */
 	jnz	drive_emulation
 
+	/* StartLBA_Lo == 0 */
+
+	/* if FROM and TO are both cdrom, this is a whole drive map. */
+	testw	$0x4000, %cs:4(%bp)	/* TO_C bit 14=TO has 2048-byte cdrom sector */
+	jz	3f			/* not cdrom */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	jz	3f			/* not cdrom */
+	movb	%cs:1(%bp), %dl		/* DL changed(!!) to TO_drive */
+	cmpb	$0, %cs:(atapi_dev_count - int13_handler)
+	jz	2f		/* no cdrom by our driver, so it is a bios drive map. */
+	cmpb	%cs:(min_cdrom_id - int13_handler), %dl	/* TO_drive */
+	jb	2f		/* not cdrom drive by our driver, so it is a bios drive map. */
+	cmpb	%cs:(max_cdrom_id - int13_handler), %dl	/* TO_drive */
+	ja	2f		/* not cdrom drive by our driver, so it is a bios drive map. */
+	jmp	edd30_for_cdrom
+3:
+
 	/* S_count being not 1 signals emulation */
 
-	movl	-22(%bp), %eax	/* S_count_Lo */
+	movl	%cs:16(%bp), %eax	/* S_count_Lo */
 	shrl	$1, %eax
 	jnz	drive_emulation
 
@@ -1984,7 +1855,7 @@
 
 	/* if sectors per track > 1, this is force geometry screw. */
 
-	movw	-4(%bp), %ax	/* AL=Hmax, AH=Smax */
+	movw	%cs:2(%bp), %ax		/* AL=Hmax, AH=Smax */
 	testb	$62, %ah	/* Sectors > 1 means force geom, this -- */
 	jnz	drive_emulation	/* -- also leads to drive emulation */
 
@@ -2013,12 +1884,12 @@
 	/* map a whole drive, normal access */
 
 	/* but if --in-situ was used, we should avoid writing the MBR! */
-	testb	$0x80, -7(%bp)	/* TO_S */
-	jz	1f		/* not in-situ, allow write */
-	testb	$0x40, -7(%bp)	/* TO_S. bit 6 here means safe-boot */
-	jz	1f		/* unsafe-boot, allow write */
-	movw	2(%bp), %ax	/* restore AX */
-	cmpb	$0x03, %ah	/* is it CHS write? */
+	testb	$0x80, %cs:7(%bp)	/* TO_S */
+	jz	1f			/* not in-situ, allow write */
+	testb	$0x40, %cs:7(%bp)	/* TO_S. bit 6 here means safe-boot */
+	jz	1f			/* unsafe-boot, allow write */
+	movw	%cs:(int13_old_eax - int13_handler), %ax
+	cmpb	$0x03, %ah		/* is it CHS write? */
 	jne	3f
 
 	/* check if it is a write to MBR, i.e., C/H/S=0/0/1 */
@@ -2030,122 +1901,99 @@
 	/* deny the write and end the int 13 call */
 	call	readonly_fakewrite	/* NO RETURN!! */
 3:
-	cmpb	$0x43, %ah	/* is it LBA write? */
-	jne	1f		/* no, continue the normal access */
+	cmpb	$0x43, %ah		/* is it LBA write? */
+	jne	1f			/* no, continue the normal access */
 
 	/* check if it is a write to MBR, i.e., LBA=0 */
 
 	xorl	%eax, %eax
-	cmpl	%eax, 12(%si)	/* write to LBA_hi32bits=0? */
-	jne	1f
-	cmpl	%eax, 8(%si)	/* write to LBA_lo32bits=0? */
-	jne	1f
+	orl	12(%si), %eax		/* LBA_hi */
+	orl	8(%si), %eax		/* LBA_lo */
+	je	readonly_fakewrite	/* deny the write and end */
 
-	/* deny the write and end the int 13 call */
-	call	readonly_fakewrite	/* NO RETURN!! */
-
 1:
-	movw	-6(%bp), %ax	/* AL=FROM, AH=TO */
-	movb	%ah, %dl	/* Let DL access TO instead of FROM */
+	movb	%cs:1(%bp), %dl	/* Let DL access TO instead of FROM */
 2:
 	/* might map to itself, i.e., actually not mapped */
 	
-	movw	-2(%bp), %si	/* restore SI */
-#if 0
-	pushw	10(%bp)		/* pushfw, simulate the interrupt call */
-	
-	movl	2(%bp), %eax	/* restore EAX */
-	movw	(%bp), %bp	/* restore BP */
+	movl	%cs:(int13_old_eax - int13_handler), %eax
+	movl	%cs:(int13_old_ebp - int13_handler), %ebp  /* BP changed!! */
 
-	/* pushfw, lcall, simulate the interrupt call */
-	lcall	%cs:*(ROM_int13 - int13_handler)
-
-	pushw	%ax		/* save AX */
-	pushfw			/* save flags returned by int13 */
-	popw	%ax
-#else
-	pushw	10(%bp)		/* pushfw, simulate the interrupt call */
-	
-	movl	2(%bp), %eax	/* restore EAX */
-	movw	(%bp), %bp	/* restore BP */
-
 	call	backup_int13
 
+	pushw	%cs:(int13_old_flags - int13_handler)
 	popfw
 
 	int	$0x13
 
-	pushw	%ax		/* save AX */
+	/* save the returned CF flag to int13_old_flags */
 
-	pushfw			/* save flags returned by int13 */
+	jnc	1f
+	orb	$1, %cs:(int13_old_flags - int13_handler)
+	jmp	2f
+1:
+	andb	$0xFE, %cs:(int13_old_flags - int13_handler)
+2:
 	call	restore_int13
-	popfw
 
-	pushfw
-	popw	%ax		/* AX=flags returned by int13 */
-#endif
+	/* restore BP!! */
+	movw	%cs:(int13_new_bp - int13_handler), %bp
+	xchgw	%ax, %cs:(int13_old_eax - int13_handler)
+				/* old AX changed!! */
 
-	movw	%sp, %bp	/* set new BP */
+	/* check int13/AH=4Bh for cdrom */
+	testw	$0x4000, %cs:4(%bp)	/* TO_C bit 14=TO has 2048-byte cdrom sector */
+	jz	1f			/* not cdrom */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	jz	1f			/* not cdrom */
+	cmpb	$0x4B, %ah
+	jne	1f
+	cmpb	$0x01, %al
+	ja	1f
+	/* this is int13 function 0x4B00 or 0x4B01 */
+	/* restore DS:SI, just in case they were changed by buggy int13 */
+	movw	%cs:(int13_old_esi - int13_handler), %si
+	movw	%cs:(int13_old_ds - int13_handler), %ds
+	cmpb	$0x13, (%si)		/* packet size */
+	jne	1f
+	testb	$0x0F, 1(%si)		/* boot type(0=no emu) */
+	jne	1f
+	movb	%cs:1(%bp), %dl		/* just in case DL was changed by a buggy int13 */
+	cmpb	%dl, 2(%si)
+	jne	1f
+	movb	%cs:(%bp), %dl		/* restore DL back to the FROM drive */
+	movb	%dl, 2(%si)
+	jmp	3f			/* return */
+1:
 
-				/* BP+38: old Flags */
-				/* BP+36: return CS */
-				/* BP+34: return IP */
-				/* BP+30: old EAX */
-				/* BP+28: old BP */
-				/* BP+26: old SI */
-				/* BP+22: FROM, TO, Hmax, Smax */			
-				/* BP+18: TO_C, TO_H, TO_S */
-				/* BP+14: StartLBA_Lo */
-				/* BP+10: StartLBA_Hi */
-				/* BP+ 6: S_count_Lo */
-				/* BP+ 2: S_count_Hi */
-				/* BP+ 0: new AX returned from int 13 */
 
 #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-	leaw	28(%bp), %bp	// it is addw	$28, %bp but won't touch flags
 
-				/* BP+10: old Flags */
-				/* BP+ 8: return CS */
-				/* BP+ 6: return IP */
-				/* BP+ 2: old EAX */
-				/* BP+ 0: old BP */
-				/* BP- 2: old SI */
-				/* BP- 6: FROM, TO, Hmax, Smax */
-				/* BP-10: TO_C, TO_H, TO_S */
-				/* BP-14: StartLBA_Lo */
-				/* BP-18: StartLBA_Hi */
-				/* BP-22: S_count_Lo */
-				/* BP-26: S_count_Hi */
-				/* BP-28: new AX returned from int 13 */
-#;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+	pushw	%cs:(int13_old_flags - int13_handler)
+	popfw
 
-	movw	%ax, 10(%bp)	/* update the flags in the stack */
-
 	/* check if should restore(reversely map) the drive number */
 	jc	1f		/* restore DL on error */
-	movw	2(%bp), %ax	/* lower word of the saved EAX */
-	
+
 	/* alter MBR after read */
 
-	testb	$0x80, -7(%bp)
-	jz	3f
+	testb	$0x80, %cs:7(%bp)	/* TO_S */
+	jz	2f
 
 	cmpb	$0x02, %ah
-	je	alter_mbr
+	je	4f		/* alter MBR */
 	cmpb	$0x42, %ah
-	je	alter_mbr
-3:
+	je	4f		/* alter MBR */
+2:
 	cmpb	$0x08, %ah	/* int13 AH=08h, read drive parameters */
 	jne	2f
 
 	/* DL==number of drives, should not restore */
-	pushw	%ds
 	xorw	%ax, %ax
 	movw	%ax, %ds
-	movw	-6(%bp), %ax	/* AL=FROM, AH=TO */
-	testb	%al, %al	/* hard drive? */
 	movb	0x475, %dl	/* DL=number of hard drives */
-	js	3f		/* yes, jump */
+	testb	$0x80, %cs:(int13_old_edx - int13_handler) /* harddrive? */
+	jnz	3f		/* yes, jump */
 	//movw	$0x10, %bx	/* for floppy, refer to function 0x48 */
 	movb	0x410, %al
 	rorb	$1, %al
@@ -2156,55 +2004,64 @@
 	andb	%ah, %al
 	movb	%al, %dl	/* DL=number of floppy drives */
 	//lesw	0x0078, %di	/* point to int 1E floppy parameters */
-3:
-	popw	%ds
 	jmp	3f
 2:
-	//cmpb	$0x15, %ah	/* int13 AH=15h, read drive type */
-	//je	3f		/* CX:DX==total sectors, should not restore */
-	//jne	1f
-	xorb	$0x15, %ah	/* int13 AH=15h, read drive type */
-	/* CF=0 for now. if ZF=1, then AH was 0x15, and it is "equal"
-	 * for the jxx class of instructions. if ZF=0, then AH was not 0x15,
-	 * and it is "above" for the jxx class of instructions.
-	 */
-1:
-	movw	-6(%bp), %ax	/* get the drive mapping */
-	/* should not simply use "jne 2f" here because ZF is unknown when
-	 * error occurred for the above int13 call
-	 */
-	jc	2f		/* "below" means error occurred for int13 */
-	ja	2f		/* "above" means it is not int13 AH=15h */
-	/* "equal" means int13 AH=15h */
-	testb	%al, %al	/* the FROM drive is harddrive? */
-	js	3f		/* yes, do not restore DL */
+	cmpb	$0x15, %ah	/* read drive type */
+	jne	2f
+	testb	$0x80, %cs:(int13_old_edx - int13_handler) /* harddrive? */
+	jnz	3f		/* yes, do not restore DL */
 	/* restore DL for floppy int13 AH=15h call */
+	jmp	1f
+4:
+	call	modify_in_situ
+	movl	%cs:(int13_old_ebx - int13_handler), %ebx
+	movl	%cs:(int13_old_ecx - int13_handler), %ecx
+	movl	%cs:(int13_old_edx - int13_handler), %edx
+	movl	%cs:(int13_old_edi - int13_handler), %edi
+	movw	%cs:(int13_old_es - int13_handler), %es
 2:
+	movw	%cs:(%bp), %ax	/* get the drive mapping */
 	/* try to restore DL if possible */
 	cmpb	%al, %ah	/* check if the mapping was performed */
 	je	3f		/* not performed, so need not restore DL */
 	cmpb	%dl, %ah
 	jne	3f		/* DL changed by int13, so do not restore */
-	movb	%al, %dl	/* restore DL back to the FROM drive */
+1:
+	movb	%cs:(int13_old_edx - int13_handler), %dl	/* restore DL back to the FROM drive */
 3:
 	/* return */
 
-	movl	2(%bp), %eax	/* restore the original EAX */
-	popw	%ax		/* update the int13 status in AX */
-	movw	(%bp), %bp	/* restore the original BP */
-	addw	$32, %sp
-	iret
+	/* BX, CX, DX, ES, DI are output registers and should not touch. */
 
-alter_mbr:
+	pushw	%cs:(int13_old_flags - int13_handler)
+	popfw
 
-	call	modify_in_situ
+	movl	%cs:(int13_old_esi - int13_handler), %esi
+	movw	%cs:(int13_old_ds - int13_handler), %ds
+	movl	%cs:(int13_old_eax - int13_handler), %eax
+	movl	%cs:(int13_old_ebp - int13_handler), %ebp
+	movw	%cs:(int13_old_esp - int13_handler), %sp
+	ljmp	*%cs:(int13_old_cs_ip - int13_handler)
 
-	movw	-6(%bp), %ax	/* get the drive mapping */
-	jmp	2b
+	.align	4
 
+int13_old_cs_ip:	.long	0
+int13_old_eax:		.long	0
+int13_old_ebx:		.long	0
+int13_old_ecx:		.long	0
+int13_old_edx:		.long	0
+int13_old_esi:		.long	0
+int13_old_edi:		.long	0
+int13_old_esp:		.long	0
+int13_old_ebp:		.long	0
+int13_old_ds:		.word	0
+int13_old_es:		.word	0
+int13_old_flags:	.word	0
+int13_new_bp:		.word	0
+
 /****************************************************************************/
 restricted_map:
-	movw	2(%bp), %ax	/* lower word of the saved EAX */
+	movw	%cs:(int13_old_eax - int13_handler), %ax
 
 	/* CHS read functions */
 	cmpb	$0x02, %ah	/* read sectors */
@@ -2218,7 +2075,7 @@
 	cmpb	$0x21, %ah	/* PS/1 and newer PS/2 - read multiple disk sectors */
 	jne	1f
 2:
-	movb	-3(%bp), %ah	/* AH=Smax */
+	movb	%cs:3(%bp), %ah	/* AH=Smax */
 	testb	$63, %ah	/* check if Sectors=0, i.e., disable CHS */
 	jz	error_01_disable
 	ret
@@ -2239,7 +2096,7 @@
 	cmpb	$0x22, %ah	/* PS/1 and newer PS/2 - write multiple disk sectors */
 	jne	1f
 2:
-	movb	-3(%bp), %ah	/* AH=Smax */
+	movb	%cs:3(%bp), %ah	/* AH=Smax */
 	testb	$63, %ah	/* check if Sectors=0, i.e., disable CHS */
 	jz	error_01_disable
 	testb	$0x80, %ah	/* readonly access? */
@@ -2274,7 +2131,7 @@
 	cmpb	$0x4e, %ah	/* Extensions v2.1 - SET HARDWARE CONFIGURATION */
 	jne	1f
 2:
-	movb	-3(%bp), %ah	/* AH=Smax */
+	movb	%cs:3(%bp), %ah	/* AH=Smax */
 	testb	$64, %ah	/* disable LBA? */
 	jnz	error_01_disable
 	ret
@@ -2283,7 +2140,7 @@
 	cmpb	$0x43, %ah	/* Extensions - EXTENDED WRITE */
 	jne	1f
 2:
-	movb	-3(%bp), %ah	/* AH=Smax */
+	movb	%cs:3(%bp), %ah	/* AH=Smax */
 	testb	$64, %ah	/* disable LBA? */
 	jnz	error_01_disable
 	testb	$0x80, %ah	/* readonly access? */
@@ -2294,37 +2151,34 @@
 
 error_01_disable:
 	/* function not supported, or the input CHS is invalid */
-	addw	$26, %sp	/* adjust SP */
-	popw	%si
-	popw	%bp
-	popl	%eax
-error_01_disable2:
-	movb	$0x01, %ah	/* signal invalid function call */
-	stc			/* signal error */
-	lret	$2		/* far return discard the original flags */
+	movl	%cs:(int13_old_eax - int13_handler), %eax
+	movb	$0x01, %ah	/* invalid function call */
+1:
+	pushw	%cs:(int13_old_flags - int13_handler)
+	popfw
+	stc			/* error */
+	jmp	1f
 
 readonly_fakewrite:
-	addw	$26, %sp	/* adjust SP */
-	popw	%si
-	#;testb	$1, -22(%bp)	/* lowest bit of S_count_Lo */
-	testb	$0x40, -7(%bp)	/* bit 6 of TO_S */
-	popw	%bp
-	popl	%eax
-	jnz	1f
-	/* read only */
-	movb	$0x03, %ah	/* signal write protection */
-	stc			/* signal error */
-	lret	$2		/* far return discard the original flags */
+	testb	$0x40, %cs:7(%bp)	/* bit 6 of TO_S */
+	movl	%cs:(int13_old_eax - int13_handler), %eax
+	movb	$0x03, %ah	/* write protection */
+	jz	1b		/* read only */
+	xorb	%ah, %ah	/* fake write */
+	pushw	%cs:(int13_old_flags - int13_handler)
+	popfw
+	clc			/* write succeeded */
 1:
-	/* fake write */
-	xorb	%ah, %ah	/* signal write succeeded */
-	/*clc*/			/* signal success, CF already cleared by XOR */
-	lret	$2		/* far return discard the original flags */
+	movl	%cs:(int13_old_esi - int13_handler), %esi
+	movw	%cs:(int13_old_ds - int13_handler), %ds
+	movl	%cs:(int13_old_ebp - int13_handler), %ebp
+	movw	%cs:(int13_old_esp - int13_handler), %sp
+	ljmp	*%cs:(int13_old_cs_ip - int13_handler)
 
 
 /****************************************************************************/
 drive_emulation:
-	movw	-4(%bp), %ax	/* AL=Hmax, AH=Smax */
+	movw	%cs:2(%bp), %ax	/* AL=Hmax, AH=Smax */
 	testb	$63, %ah	/* disable CHS? */
 	jz	2f		/* yes, call restricted map */
 	testb	$0xc0, %ah	/* readonly or disable LBA? */
@@ -2332,85 +2186,77 @@
 2:
 	call	restricted_map
 1:
-	movw	2(%bp),	%ax	/* get original AX */
+	movw	%cs:(int13_old_eax - int13_handler), %ax
 
 	testb	%ah, %ah	/* reset disk system, always succeed */
 	jnz	1f
-	clc
+	/*clc*/			/* CF already cleared by TEST */
 	jmp	int13_return
 /****************************************************************************/
 1:
-	cmpb	$0x01, %ah /* get status of last operation, always succeed */
+	cmpb	$0x01, %ah	/* get status, always succeed */
 	jnz	1f
 	xorb	%ah, %ah
-	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x04, %ah	/* verify sectors, always succeed */
 	jnz	1f
 	xorb	%ah, %ah
-	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x09, %ah /* INITIALIZE CONTROLLER WITH DRIVE PARAMETERS */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	xorb	%ah, %ah
-	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x0c, %ah	/* SEEK TO CYLINDER */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	xorb	%ah, %ah
-	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x0d, %ah	/* reset hard disks */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	xorb	%ah, %ah
-	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x10, %ah	/* check if drive ready */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	xorb	%ah, %ah
-	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x11, %ah	/* recalibrate drive */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	xorb	%ah, %ah
-	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x14, %ah	/* CONTROLLER INTERNAL DIAGNOSTIC */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	xorb	%ah, %ah
-	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x05, %ah	/* format track */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 
 	/* CH=cylinder number (bits 8,9 in high bits of CL)
@@ -2420,13 +2266,12 @@
 	 */
 
 	xorb	%ah, %ah	/* do nothing but return success */
-	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x08, %ah	/* get drive parameters */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	pushw	%ds
 	xorw	%ax, %ax
@@ -2446,14 +2291,11 @@
 	lesw	0x0078, %di	/* point to int1E floppy parameters */
 2:
 	popw	%ds
-	movw	-4(%bp), %ax	/* AL=Hmax, AH=Smax */
+	movw	%cs:2(%bp), %ax	/* AL=Hmax, AH=Smax */
 	movb	%al, %dh	/* max head number */
 	andb	$63, %ah
 	movb	%ah, %cl	/* max sector number */
 
-	///* simply use 1024 cylinders, hope this would work well */
-	//orw	$0xffc0, %cx	/* max cylinder number=1023 */
-
 	/* max cylinder number */
 
 	pushl	%edx
@@ -2464,8 +2306,7 @@
 	mull	%ecx		/* EDX=0, EAX=sectors per cylinder */
 	xchgl	%eax, %ecx
 
-	movl	-22(%bp), %eax	/* S_count_Lo */
-	#;andb	$0xfe, %al
+	movl	%cs:16(%bp), %eax	/* S_count_Lo */
 	decl	%eax
 	//xorl	%edx, %edx
 	divl	%ecx		/* EAX=max cylinder number */
@@ -2476,15 +2317,13 @@
 	shlb	$6, %ah		/* high 2 bits of cylinder */
 	orb	%ah, %cl
 
-	//movb	$0x08, %dl	/* drives=8(HDs=8 as well as FDs=8) */
 	xorw	%ax, %ax
-	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x15, %ah	/* get disk type */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	testb	%dl, %dl	/* hard drive? */
 	js	2f		/* yes, jump */
@@ -2495,35 +2334,32 @@
 	movb	$0x03, %ah	/* hard disk */
 
 	/* CX:DX=total number of sectors */
-	movw	-22(%bp), %dx	/* lo word of S_count_Lo */
-	movw	-20(%bp), %cx	/* hi word of S_count_Lo */
-	#;andb	$0xfe, %dl	/* clear bit 0 */
+	movw	%cs:16(%bp), %dx	/* lo word of S_count_Lo */
+	movw	%cs:18(%bp), %cx	/* hi word of S_count_Lo */
 	clc
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x16, %ah
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	xorb	%ah, %ah	/* AH=0 means disk not changed */
-	/* clc */		/* signal success, CF already cleared by XOR */
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x17, %ah	/* set floppy type for format */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	movb	$0x03, %al	/* 1.44M drive, 1.44M floppy */
 	xorb	%ah, %ah
-	/* clc */		/* signal success, CF already cleared by XOR */
 	jmp	int13_return
 /****************************************************************************/
 1:
 	cmpb	$0x18, %ah	/* set media type for format */
 	jnz	1f
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
 	testb	%dl, %dl	/* hard drive? */
 	js	error_01_invalid
@@ -2537,7 +2373,6 @@
 	movw	%ax, %es
 	popw	%ax
 	xorb	%ah, %ah
-	/* clc */		/* signal success, CF already cleared by XOR */
 	jmp	int13_return
 /****************************************************************************/
 1:
@@ -2548,9 +2383,9 @@
 
 	/* so AH is either 2(for read) or 3(for write) */
 
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jnz	error_01_invalid	/* CDROM */
-#if 1
+
 	cmpw	$0x0301, %ax	/* is it write 1 sector? */
 	jne	2f
 	cmpw	$0x0001, %cx	/* write to cylinder 0, sector 1? */
@@ -2564,43 +2399,8 @@
 	testb	%dh, %dh	/* write to floppy head 0? */
 	jne	2f		/* no, write permitted */
 3:
-	#;movb	-22(%bp), %ah	/* lowest byte of S_count_Lo */
-	movb	-7(%bp), %ah	/* TO_S, bit 6 for fake write */
-	testb	$0x40, %ah	/* fake write here means safeboot */
-	jz	2f		/* unsafe boot allows the write */
-
-	/* disable the write */
-	addw	$24, %sp	/* adjust SP */
-	popw	%si
-	popw	%bp
-	popl	%eax
-	xorb	%ah, %ah	/* signal write succeeded, this is a fake */
-	/* clc */		/* signal success, CF already cleared by XOR */
-	lret	$2		/* far return discard the original flags */
-	
-#else
-	/* debug only. locate windows 98 unidentified write to floppy */
-	pushaw
-	movw	8(%bp), %ax
-	movw	%ax, %ds
-	movw	6(%bp), %si
-	subw	$0x0400, %si
-	movw	%bx, %di
-	movw	$0x0400, %cx
-	cld
-	repz movsw
-	movw	%si, %ax
-	movw	%di, %bx
-	subw	$4, %di
-	stosw
-	movw	%bx, %ax
-	stosw
-	popaw
-	movb	$4, %al
-/*3:*/
-	/*hlt*/			/* invalid write to floppy, halt the machine */
-	/*jmp	3b*/
-#endif
+	testb	$0x40, %cs:7(%bp)	/* TO_S, bit 6=fake write(safeboot) */
+	jnz	readonly_fakewrite	/* fake the write */
 2:
 	cmpb	$0x7F, %al	/* check if sectors exceed 127 */
 	ja	error_01_invalid
@@ -2608,19 +2408,17 @@
 	jz	error_01_invalid
 	testb	$63, %cl	/* beginning sector number 0 is invalid */
 	jz	error_01_invalid
-	movb	-3(%bp), %ah	/* AH=Smax */
+	movb	%cs:3(%bp), %ah	/* AH=Smax */
 	andb	$63, %ah
 	pushw	%cx
 	andb	$63, %cl
 	cmpb	%ah, %cl	/* CL should not > max sector number */
 	popw	%cx
 	ja	error_01_invalid
-	movb	-4(%bp), %ah	/* AH=Hmax */
+	movb	%cs:2(%bp), %ah	/* AH=Hmax */
 	cmpb	%ah, %dh	/* DH should not > max head number */
 	ja	error_01_invalid
 
-	pushw	%ds
-
 	pushw	%cs
 	popw	%ds		/* DS=CS */
 
@@ -2639,7 +2437,7 @@
 	pushl	%ebx		/* save EBX */
 
 	xorl	%ebx, %ebx	/* EBX=0 */
-	movb	-4(%bp), %bl	/* BL=Hmax */
+	movb	%cs:2(%bp), %bl	/* BL=Hmax */
 	incw	%bx		/* EBX=total heads, <=256 */
 
 	pushl	%edx
@@ -2649,7 +2447,7 @@
 	xorw	%bx, %bx	/* EBX=0 */
 	movb	%dh, %bl	/* EBX=head number */
 	addl	%ebx, %eax	/* EAX=tracks before this head */
-	movb	-3(%bp), %bl	/* Max sector number */
+	movb	%cs:3(%bp), %bl	/* Max sector number */
 	andb	$63, %bl	/* EBX=sectors per track */
 
 	pushl	%edx
@@ -2666,67 +2464,94 @@
 
 disk_address_packet_ready:
 
+	/* DS=CS */
+
 	/* start-sector-number(LBA) in DAP is still for FROM_DRIVE */
 
-	call	bound_check
+/****************************************************************************/
+	/* 
+	 * check if the request exceeds the boundary of the emulated disk.
+	 *
+	 * input:	DS:SI
+	 * output:	CF=0, success, all sectors transferred
+	 *		CF=1, failure, no sectors transferred
+	 *		EAX changed
+	 *
+	 */
+	cmpl	$1, %cs:16(%bp)		/* S_count_Lo */
+	ja	2f
+	cmpl	$0, %cs:8(%bp)		/* StartLBA_Lo */
+	je	4f			/* map whole drive, no restrictions */
+2:
+	cmpl	$0, 12(%si)	/* hi 32-bit of the requested StartLBA */
+	jnz	3f		/* non-zero is considered `too big' */
+	movl	%cs:16(%bp), %eax	/* S_count_Lo */
+	cmpl	%eax, 8(%si)	/* lo 32-bit of the requested StartLBA */
+	jnb	3f
+	subl	8(%si), %eax
+	pushl	%ebx
+	movzwl	2(%si), %ebx	/* requested sectors */
+	cmpl	%ebx, %eax
+	popl	%ebx
+//	jnb	4f
+//3:
+//	stc
+4:
+/****************************************************************************/
 
-	testb	$0xfe, %ah	/* allow all or part of sectors to tranfer */
-	stc
-	jnz	3f		/* no sectors to transfer, skip */
+	jc	3f		/* no sectors to transfer, fail */
 
 	/* adjust start-sector-number(LBA) to access TO_DRIVE */
-	movl	-14(%bp), %eax	/* StartLBA_Lo */
+	movl	%cs:8(%bp), %eax	/* StartLBA_Lo */
 	addl	%eax, 8(%si)
 	adcl	$0, 12(%si)
 
 	/* set drive number(TO_DRIVE) and function number(EBIOS) */
-	movb	-5(%bp), %dl	/* DL=TO_DRIVE */
-	movb	3(%bp), %ah	/* 0x02=read, 0x03=write */
+	movb	%cs:1(%bp), %dl		/* DL=TO_DRIVE */
+	movb	%cs:(int13_old_eax - int13_handler + 1), %ah
+				/* 0x02=read, 0x03=write */
 	orb	$0x40, %ah	/* 0x42=EXT_read, 0x43=EXT_write */
 
 	call	real_int13_service
 
-	/* restore original start-sector-number(in the DAP) */
-	pushfw
-	pushl	%eax
-	movl	-14(%bp), %eax	/* StartLBA_Lo */
-	subl	%eax, 8(%si)
-	sbbl	$0, 12(%si)
-	popl	%eax
-	popfw
+	///* restore original start-sector-number(in the DAP) */
+	//pushfw
+	//movl	%cs:8(%bp), %eax	/* StartLBA_Lo */
+	//subl	%eax, 8(%si)
+	//sbbl	$0, 12(%si)
+	//popfw
 
-	jc	2f	/* on error we needn't use the bound check result */
+	jc	3f			/* failure */
 
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	jnz	4f			/* CDROM */
+	movw	$(EBIOS_disk_address_packet - int13_handler), %si
+	pushw	%cs
+	popw	%ds
 	call	modify_boot_sectors
-	popfw			/* use bound check info */
-	pushfw			/* dummy push, for the following dummy pop */
-	jnc	4f
-	movb	$0x04, %ah	/* sector not found */
-2:
-	popfw			/* dummy pop */
-	stc
-	pushfw
 4:
-	movb	2(%si), %al	/* number of sectors transferred */
+	movb	%cs:(int13_old_eax - int13_handler), %al
+	xorb	%ah, %ah
+	jmp	4f			/* success */
 
+3:
+	movw	$0x400, %ax	/* no sectors transferred */
 	/* write back sectors transferred to original DAP for LBA access */
-	testb	$0x40, 3(%bp)	/* original AH */
-	jz	4f		/* not an LBA call */
+	cmpb	$0x40, %cs:(int13_old_eax - int13_handler + 1)
+	jb	4f		/* CF=1, function 02 or 03, not an LBA call */
 
-	movw	-2(%bp), %si	/* original SI */
-	popfw
-	popw	%ds
-	pushw	%ds
-	pushfw
+	movw	%cs:(int13_old_esi - int13_handler), %si
+	movw	%cs:(int13_old_ds - int13_handler), %ds
 
 	/* DS:SI -> original DAP */
 	movb	%al, 2(%si)
+	stc				/* failure */
 4:
-	/* It is not safe to use POPW %DS for running in protected mode */
-	popfw			/* dummy pop, skip the pushed flags */
-	movb	-6(%bp), %dl	/* restore DL(=FROM_DRIVE) */
-3:
-	popw	%ds
+	movl	%cs:(int13_old_edx - int13_handler), %edx
+	movl	%cs:(int13_old_ebx - int13_handler), %ebx
+	movl	%cs:(int13_old_ecx - int13_handler), %ecx
+	movl	%cs:(int13_old_edi - int13_handler), %edi
+	movw	%cs:(int13_old_es - int13_handler), %es
 	jmp	int13_return
 /****************************************************************************/
 1:
@@ -2748,7 +2573,7 @@
 	cmpb	$0x43, %ah	/* EBIOS write sectors */
 	jnz	1f
 
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jz	2f
 
 	/* CDROM */
@@ -2756,7 +2581,8 @@
 	stc			/* error */
 	jmp	int13_return
 2:
-	movw	-2(%bp), %si	/* get old SI, disk address packet */
+	/* get old SI, disk address packet */
+	movw	%cs:(int13_old_esi - int13_handler), %si
 	movl	(%si), %eax	/* packet length, sectors, etc. */
 	testb	%ah, %ah
 	jnz	error_01_invalid
@@ -2768,7 +2594,6 @@
 	testb	%al, %al
 	jz	error_01_invalid
 
-#if 1
 	/* copy disk address packet to EBIOS_disk_address_packet */ 
 
 	pushw	%es
@@ -2789,13 +2614,11 @@
 
 	/* set DS:SI */
 
-	pushw	%ds
-
 	movw	%cs, %ax
 	movw	%ax, %ds	/* DS=CS */
 	movw	$(EBIOS_disk_address_packet - int13_handler), %si
 
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jz	2f
 	shlb	$2, 2(%si)
 	movl	8(%si), %eax
@@ -2803,49 +2626,7 @@
 	shll	$2, 8(%si)
 2:
 	jmp	disk_address_packet_ready
-#else
 
-	call	bound_check
-
-	testb	$0xfe, %ah	/* allow all or part of sectors to tranfer */
-	stc
-	jnz	int13_return	/* no sectors to transfer, skip */
-
-	movl	-14(%bp), %eax	/* StartLBA_Lo */
-	addl	%eax, 8(%si)
-	adcl	$0, 12(%si)
-
-	movb	-5(%bp), %dl	/* DL=TO_DRIVE */
-	movb	3(%bp), %ah	/* 0x42=read, 0x43=write */
-	orb	$0x40, %ah	/* 0x42=EXT_read, 0x43=EXT_write */
-
-	call	real_int13_service
-
-	jc	2f		/* on error need not use the bound check */
-//	call	modify_boot_sectors
-	popfw			/* use bound check info */
-	pushfw			/* dummy push, for the following dummy pop */
-	jnc	3f
-	movb	$0x04, %ah	/* sector not found */
-2:
-	popfw			/* dummy pop */
-	stc
-	pushfw
-3:
-	pushl	%eax
-	movl	-14(%bp), %eax	/* StartLBA_Lo */
-	subl	%eax, 8(%si)
-	sbbl	$0, 12(%si)
-	popl	%eax
-
-	call	modify_boot_sectors
-
-	movb	-6(%bp), %dl	/* restore DL(=FROM_DRIVE) */
-
-	popfw			/* pop the pushed Flags by bound_check */
-	jmp	int13_return
-#endif
-
 /****************************************************************************/
 1:
 	cmpb	$0x44, %ah	/* EBIOS verify sectors */
@@ -2865,11 +2646,12 @@
 	cmpb	$0x48, %ah	/* EBIOS GET DRIVE PARAMETERS */
 	jnz	1f
 
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jz	2f			/* normal disks */
 
 	/* CDROM */
-	movw	-2(%bp), %si	/* get old SI, extended drive parameter table */
+	/* get old SI, extended drive parameter table */
+	movw	%cs:(int13_old_esi - int13_handler), %si
 	cmpw	$26, (%si)
 	jb	error_01_invalid
 
@@ -2892,7 +2674,8 @@
 	xorw	%ax, %ax	/* success, CF cleared */
 	jmp	int13_return
 2:
-	movw	-2(%bp), %si	/* get old SI, extended drive parameter table */
+	/* get old SI, extended drive parameter table */
+	movw	%cs:(int13_old_esi - int13_handler), %si
 	movw	$26, (%si)	/* buffer length */
 	movw	$2, 2(%si)	/* info */
 	xorl	%eax, %eax
@@ -2902,7 +2685,7 @@
 	movl	%eax, 20(%si)	/* hi 32 bits of total sectors */
 	pushl	%ebx
 	xorl	%ebx, %ebx
-	movw	-4(%bp), %ax	/* AL=Hmax, AH=Smax */
+	movw	%cs:2(%bp), %ax	/* AL=Hmax, AH=Smax */
 	andb	$63, %ah
 	movb	%ah, 12(%si)	/* sectors per track */
 	movb	%ah, %bl
@@ -2912,7 +2695,7 @@
 	pushl	%edx
 	mulw	%bx		/* DX:AX=product, DX=0 */
 	movw	%ax, %bx	/* BX=sectors per cylinder */
-	movl	-22(%bp), %eax	/* S_count_Lo */
+	movl	%cs:16(%bp), %eax	/* S_count_Lo */
 	#;andb	$0xfe, %al
 	movl	%eax, 16(%si)	/* total sectors */
 	xorl	%edx, %edx	/* EDX:EAX=64bit total sectors */
@@ -2937,13 +2720,13 @@
 	cmpw	$0x4B01, %ax	/* CDROM GET DISK EMULATION STATUS */
 	jnz	1f
 
-	testw	$0x2000, -10(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
 	jz	error_01_invalid	/* normal disks have no 0x4B01 function */
 
 	/* CDROM */
 	pushw	%es
 	pushw	%di
-	movw	-2(%bp), %di	/* old SI, specification packet */
+	movw	%cs:(int13_old_esi - int13_handler), %di	/* old SI */
 	pushw	%ds
 	popw	%es
 	movw	$0x0013, %ax	/* packet size=13h, boot type=0 (no-emu) */
@@ -2978,111 +2761,48 @@
 	stc			/* signal error */
 
 int13_return:
-	pushw	%ax		/* save status */
-	//pushfw
-	//popw	%ax
-	lahf			/* Load Flags into AH */
-	movb	10(%bp), %al
-	shrw	$1, %ax
-	rolb	$1, %al
-
-	movb	%al, 10(%bp)	/* update flags in the stack */
-	movw	-2(%bp), %si	/* restore the original SI */
-	movl	2(%bp), %eax	/* restore the original EAX */
-	movw	(%bp), %bp	/* restore the original BP */
-	popw	%ax		/* restore status */
-	addw	$32, %sp	/* adjust SP */
-	iret
-
-/****************************************************************************/
-bound_check:
-
-	/* 
-	 * check if the request exceeds the boundary of the emulated disk.
-	 *
-	 * input:	DS:SI
-	 * output:	AH=0 no restrictions, all sectors transferred
-	 *		AH=1 sectors transferred, but not all
-	 *		AH=4 error exit immediately, no sectors transferred
-	 *
-	 * if S_count=StartLBA=0, then no restrictions
-	 * else if 8(%si)>=S_count then error
-	 * else if 8(%si)+2(%si)<=S_count then no restrictions
-	 * else let 2(%si)=S_count-8(%si),call original int13,signal error
-	 *
-	 */
-	movl	-14(%bp), %eax	/* StartLBA_Lo */
-	testl	%eax, %eax
-	jnz	2f
-	movl	-22(%bp), %eax	/* S_count_Lo */
-	shrl	$1, %eax
-	jnz	2f
-	clc		/* map whole drive, signal no restrictions */
-	popw	%ax	/* pop return IP */
-	pushfw		#; push additional Flags!!
-	pushw	%ax	/* push return IP */
-	xorb	%ah, %ah	/* no restrictions, all sectors transferred */
-	ret
+	movw	%ax, %cs:(int13_old_eax - int13_handler)	/* status */
+	jnc	1f
+	orb	$1, %cs:(int13_old_flags - int13_handler)
+	jmp	2f
+1:
+	andb	$0xFE, %cs:(int13_old_flags - int13_handler)
 2:
-	movl	12(%si), %eax	/* hi 32-bit of the requested StartLBA */
-	testl	%eax, %eax
-	jnz	3f		/* non-zero is considered `too big' */
-	movl	-22(%bp), %eax	/* S_count_Lo */
-	#;andb	$0xfe, %al
-	cmpl	%eax, 8(%si)	/* lo 32-bit of the requested StartLBA */
-	jb	2f
-3:
-	/* all sectors exceed the bound, exit immediately */
-	#; Return WITHOUT additional Flags pushed!!
+	pushw	%cs:(int13_old_flags - int13_handler)
+	popfw
 
-	movb	$4, %ah
-	xorb	%al, %al	/* no sectors transferred */
-	movb	%al, 2(%si)	/* SI+2 retrieve sectors transferred */
-	stc
-	ret
-2:
-	subl	8(%si), %eax
-	pushl	%ebx
-	xorl	%ebx, %ebx
-	movw	2(%si), %bx
-	cmpl	%eax, %ebx
-	popl	%ebx
-	ja	2f
-	clc		/* signal no restrictions */
-	popw	%ax	/* pop return IP */
-	pushfw		#; push additional Flags!!
-	pushw	%ax	/* push return IP */
-	xorb	%ah, %ah	/* no restrictions, all sectors transferred */
-	ret
-2:
-	movb	%al, 2(%si)	/* SI+2 retrieve sectors transferred */
-	stc
-	popw	%ax	/* pop return IP */
-	pushfw		#; push additional Flags!!
-	pushw	%ax	/* push return IP */
-	movb	$1, %ah	/* not all sectors tranferred */
-	ret
+	movl	%cs:(int13_old_eax - int13_handler), %eax
+	movl	%cs:(int13_old_esi - int13_handler), %esi
+	movw	%cs:(int13_old_ds - int13_handler), %ds
+	movl	%cs:(int13_old_ebp - int13_handler), %ebp
+	movw	%cs:(int13_old_esp - int13_handler), %sp
+	ljmp	*%cs:(int13_old_cs_ip - int13_handler)
 
 /****************************************************************************/
 real_int13_service:
 
 	/* AH = 0x42 or 0x43 */
 
+	/* save return address to memory */
+	popw	%cs:(int13_ret_IP - int13_handler)
 	/* save AX to memory */
 	movw	%ax, %cs:(int13_reg_AX - int13_handler)
 
 	cmpb	$0xff, %dl	/* mem drive */
 	jne	normal_disk_drive
 
-	testw	$0x4000, -10(%bp)	/* TO_C bit 14=TO has 2048-byte cdrom sector */
+	testw	$0x4000, %cs:4(%bp)	/* TO_C bit 14=TO has 2048-byte cdrom sector */
 	jnz	normal_disk_drive
 
 	/* handle memdrive */
 
+	//sti		/* for hardware interrupt or watchdog */
 	cmpb	$0x42, %ah
 	je	3f
 	cmpb	$0x43, %ah
-	jne	5f
+	je	3f
+	stc
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
 	/* DS:SI points to disk address packet 	*/
 	/* 	2(%si), byte, sectors(1-127) 	*/
 	/* 	4(%si), word, offset 		*/
@@ -3090,8 +2810,6 @@
 	/* 	8(%si), qword, lba		*/
 3:
 	/* AH = 0x42 or 0x43 */
-	pushw	%es
-	pushal
 	sahf	/* Store AH into flags SF ZF xx AF xx PF xx CF */
 	pushf
 	movzwl	4(%si), %ebx	#;  BX=offset, EBX_high_word=0
@@ -3104,13 +2822,15 @@
 	jc	4f	/* write */
 	xchgl	%eax, %ecx
 4:
+	/* Data transfer: (%eax) -> (%ecx), number of sectors 2(%si) */
+	movl	%eax, %cs:(int13_data_addr_from - int13_handler)
+	movl	%ecx, %cs:(int13_data_addr_to - int13_handler)
+
 	cmpl	$0, %cs:(memdisk_raw - int13_handler)
 	je	4f		/* do not use raw mode */
 
 	/* raw mode as in memdisk, contributed by Bean */
 
-	/* Data transfer: (%eax) -> (%ecx), number of sectors 2(%si) */
-	
 //	pushw	%ax
 	smsw	%bx
 	testb	$1, %bl
@@ -3120,13 +2840,10 @@
 	/* switch to protected mode myself */
 	/* ebx destroy */
 	
-	pushfl
-	pushw	%ds
-	pushw	%es
-	pushl	%eax
-	pushl	%ecx
-	pushw	%ds
-	pushw	%si
+	//pushw	%ds
+	//pushw	%es
+	//pushl	%eax
+	//pushl	%ecx
 
 	cli
 
@@ -3149,31 +2866,7 @@
 	testl	$0x100000, %edx	# zero means data inside an even mega
 	setz	%dl		# we think of it as if A20 were on
 	jz	3f		# no need to enable A20
-#if 0
-	/* Test to see if A20 is enabled or not */
-	xorw	%ax, %ax
-	movw	%ax, %ds	/* DS=0 */
-	decw	%ax
-	movw	%ax, %es	/* ES=0xFFFF */
 
-	movw	%ds:0, %ax
-	movw	%ax, %bx
-	xorw	%es:0x10, %bx
-	notw	%ax
-	movw	%ax, %ds:0
-	movw	%ax, %dx
-	xorw	%es:0x10, %dx
-	notw	%ax
-	movw	%ax, %ds:0
-
-	orw	%bx, %dx
-	pushw	%dx		/* 0=A20 off, 1=A20 on */
-	jnz	1f
-	movb	$1, %dl		/* A20 is off, so it need turn on. */
-	call	int13_enable_a20
-1:
-	popw	%dx
-#else
 	cli	/* yes, keep interrupt off when controlling A20 */
 
 	pushw	%dx
@@ -3181,36 +2874,26 @@
 	movw	$0x0001, %dx		# enable a20
 	call	enable_disable_a20
 	popw	%dx
-	//sete	%dl			# DL=1 means success
 	jz	1f		/* success */
 
 	/* A20 control failed. */
 
 	# notify the user
-	movzbw	-6(%bp), %ax		/* FROM_DRIVE */
+	movzbw	%cs:(%bp), %ax		/* FROM_DRIVE */
 	pushw	%ax
-	pushw	$a20_failure - int13_handler		# the format string
+	pushw	$a20_failure - int13_handler	# the format string
 	call	realmode_printf
 	addw	$4, %sp			# adjust the stack pointer
 
-	popw	%si
-	popw	%ds
-	popl	%ecx
-	popl	%eax
-	popw	%es
-	popw	%ds
-	popfl
+	//popl	%ecx
+	//popl	%eax
+	//popw	%es
+	//popw	%ds
 
 	//jmp	4f		/* try once more with int15/ah=87h */
 
-	/* return failure to the caller */
-	popal
-	popw	%es
-	movb	$0, 2(%si)	/* signal no sectors successfully moved */
-	/* sector not found 	*/
-	movb	$4, %ah
 	stc
-	ret
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
 
 a20_failure:
 	.ascii	"\r\ngrub4dos: A20 failure on memdrive=0x%X.\r\n\0"
@@ -3219,21 +2902,24 @@
 	/* CF=1 means A20 was originally enabled. */
 	setc	%dl
 	movb	$0, %dh
-#endif
+
 3:
-	popw	%si
+	movw	$(EBIOS_disk_address_packet - int13_handler), %si
+	pushw	%cs
 	popw	%ds
-	popl	%ecx
-	popl	%eax
-
-	movl	%ecx, %edi
+	//popl	%ecx
+	//popl	%eax
 	movzbl	2(%si), %ecx	#; ECX=number of sectors to transfer
-	movl	%eax, %esi	#; ESI changed!!
+	movl	%cs:(int13_data_addr_to - int13_handler), %edi
+	movl	%cs:(int13_data_addr_from - int13_handler), %esi
+				#; ESI changed!!
 
+	cli
 	shll	$7, %ecx	/* 128 dwords per sector */
 
 	lgdt	%cs:MyGDT - int13_handler
 	movl	%cr0, %eax
+	andl	$0x0000FFFF, %eax
 	orb	$1, %al
 	movl	%eax, %cr0	/* Switch to protected mode */
 
@@ -3243,17 +2929,13 @@
 
 	cld
 
-	addr32	rep movsl
+	addr32	rep movsl	/* ESI, EDI changed! */
 
-//	movw	$8, %bx		/* Switch back to 64K data segment */
-//	movw	%bx, %ds
-//	movw	%bx, %es
-
 	andb	$0xFE, %al
 	movl	%eax, %cr0	/* Back to real mode */
 	
-	popw	%es
-	popw	%ds
+	//popw	%es
+	//popw	%ds
 
 	cmpl	$0, %cs:(a20_keep_on - int13_handler)
 	jne	1f	/* Keep A20 on. This should hurt nothing. */
@@ -3262,22 +2944,14 @@
 	andw	%dx, %dx	/* 0=orig A20 off, 1=orig A20 on */
 	jnz	1f
 
-#if 0
-	call	int13_enable_a20
-#else
+	cli	/* yes, keep interrupt off when controlling A20 */
 	movw	$0x0004, %cx		# try so many times on failure
 	//movw	$0x0000, %dx		# zero means `disable'
 	call	enable_disable_a20
-#endif
 
 1:
-
-	popfl
-
-	popal
-	popw	%es
-	xorb	%ah, %ah
-	ret
+	clc
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
 4:
 	movb	2(%si), %bl	/* number of sectors to be moved */
 	pushw	%cs
@@ -3309,59 +2983,17 @@
 	testb	$1, %al
 	popw	%ax
 	jnz	4f		/* protected mode */
-#if 0
-	pushw	%ax
-	pushw	%ds
-	xorw	%ax, %ax
-	movw	%ax, %ds
-	movl	0x0054, %eax	/* point to int15 vector */
-	popw	%ds
-	cmpl	%eax, %cs:(ROM_int15 - int13_handler)
-	popw	%ax
-	je	4f
-	/* real mode with int15 vector changed */
-#endif
+
 	/* real mode */
 	pushfw
 	lcall	%cs:*(ROM_int15 - int13_handler)
 	
-#if 0
-	/* ensure A20 is on when we return to caller. */
-
-	/* A20 control is a slow operation. Enabling A20 here in int13 handler
-	 * could cause problems on some machines.
-	 */
-
-	pushfw
-
-	cli	/* yes, keep interrupt off when controlling A20 */
-
-	movw	$0x00ff, %cx		# try so many times on failure
-	movw	$0x0001, %dx		# non-zero means `enable'
-	call	enable_disable_a20
-	//sete	%dl			# DL=1 means success
-
-	popfw
-#endif
-
 	jmp	6f
 4:
-	///* protected mode, or real mode with int15 vector unchanged */
 	/* protected mode */
 	int	$0x15
 6:
-	popal
-	popw	%es
-	jc	6f
-	xorb	%ah, %ah
-	ret
-6:
-	movb	$0, 2(%si)	/* signal no sectors successfully moved */
-5:
-	/* sector not found 	*/
-	movb	$4, %ah
-	stc
-	ret
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
 
 /****************************************************************************/
 normal_disk_drive:
@@ -3369,41 +3001,14 @@
 	/* handle normal disk drive */
 
 	/* AH = 0x42 or 0x43 */
-#if 1
 	pushw	%ax
 	smsw	%ax
 	testb	$1, %al
 	popw	%ax
 	jz	3f	// real mode
-#else
-	pushw	%ds
-	pushw	%si
-	xorw	%si, %si
-	movw	%si, %ds	/* DS=SI=0 */
-				/* DS:[SI+0x4C] points to int 13 vector */
-	ldsw	0x4C(%si), %si	/* new DS:SI=int 13 vector, pointing to */
-				/* int 13 service routine */
-	cmpb	$0x63, (%si)	/* win 98 places ARPL here */
-	popw	%si
-	popw	%ds
-	jne	3f	// real mode
-#endif
+
 	/* protected mode(Windows 98, EMM386) */
 
-	#;/* now inside win 98, will call protected mode int 13 */
-
-#if 0
-	/* debug code to test the win98 behavior */
-
-	/* disable the disk access in protected mode. */
-	testw	$0x400, -10(%bp)	/* TO_C */
-	jnz	1f
-	movb	$0, 2(%si)
-	movb	$2, %ah		/* I/O error */
-	stc
-	ret
-1:
-#endif
 	pushw	%si		/* save SI */
 	pushl	%eax		/* save EAX */
 	pushl	%ebx		/* save EBX */
@@ -3437,7 +3042,7 @@
 	jz	2f		/* not mapped, do nothing */
 	movb	%bl, %dl	/* use the mapped FROM_DRIVE for win 98 */
 2:
-	movb	-6(%bp), %al	/* AL=FROM_DRIVE */
+	movb	%cs:(%bp), %al	/* AL=FROM_DRIVE */
 	testb	%al, %al	/* hard drive emulation? */
 	jns	2f		/* floppy, jump */
 	cmpb	%al, %dl
@@ -3447,18 +3052,8 @@
 	popl	%ebx
 	popl	%eax
 	popw	%si
-#if 0
-	/* This does not work, although it seems it should work. */
-	int	$0x13		/* call win 98 protected-mode int 13 */
-	ret
-#else
-	/* This works on win98, but not tested under emm386. */
-//	pushfw
-//	lcall	%cs:*(ROM_int13 - int13_handler)
-//	ret
 
-	/* so we can just fall through to real mode... */
-#endif
+	/* fall through to real mode... */
 
 3:
 
@@ -3468,28 +3063,16 @@
 	/* 	4(%si), word, offset 		*/
 	/* 	6(%si), word, segment 		*/
 	/* 	8(%si), qword, lba		*/
-#if 0
-	/* debug code to test the win98 behavior */
 
-	/* disable the disk access in real mode. */
-	testw	$0x400, -10(%bp)	/* TO_C */
-	jnz	1f
-	movb	$0, 2(%si)
-	movb	$2, %ah		/* I/O error */
-	stc
-	ret
-1:
-#endif
-
-	testw	$0x4000, -10(%bp)	/* TO_C bit 14=TO has 2048-byte cdrom sector */
+	testw	$0x4000, %cs:4(%bp)	/* TO_C bit 14=TO has 2048-byte cdrom sector */
 	jz	1f
 
-	/* LBA supported, CHS not applicable */
+	/* LBA supported, CHS not applicable for CDROM */
 
-	pushw	%es
-	pushw	%cx
-	pushl	%ebx
-	pushl	%edi
+	movw	%es, %cs:(int13_cdrom_es - int13_handler)
+	movw	%cx, %cs:(int13_cdrom_cx - int13_handler)
+	movl	%ebx, %cs:(int13_cdrom_ebx - int13_handler)
+	movl	%edi, %cs:(int13_cdrom_edi - int13_handler)
 
 	movzbw	2(%si), %cx	/* sectors to transfer */
 	movl	8(%si), %edi	/* start sector number(LBA) */
@@ -3524,10 +3107,10 @@
 	movb	$1, 2(%si)		/* read 1 big sector */
 
 	//pushw	%es
-	pushw	%bx
-	movw	%cs, %bx
-	movw	%bx, %es
-	movw	%bx, 6(%si)		/* set the buffer segment */
+	movw	%bx, %cs:(int13_cdrom_bx - int13_handler)
+	movw	%cs, %ax
+	movw	%ax, %es
+	movw	%ax, 6(%si)		/* set the buffer segment */
 	movw	$edd30_disk_buffer - int13_handler, %bx
 	movw	%bx, 4(%si)		/* set the buffer offset */
 	movw	%cs:(int13_reg_AX - int13_handler), %ax
@@ -3539,13 +3122,14 @@
 	jb	2f			/* not cdX */
 	cmpb	%cs:(max_cdrom_id - int13_handler), %dl
 	ja	2f			/* not cdX */
+	/* read 1 cdrom sector using our builtin cdrom driver. */
 	movb	$1, %cs:(force_int13 - int13_handler)
 2:
 	call	int13_with_retry	/* read a big 2048-byte sector */
 
 	movb	$0, %cs:(force_int13 - int13_handler)
 
-	popw	%bx
+	movw	%cs:(int13_cdrom_bx - int13_handler), %bx
 	//popw	%es
 	jc	3f			/* failed */
 
@@ -3612,93 +3196,20 @@
 	jnz	3b
 //	loop	3b
 
-	popl	%edi
-	popl	%ebx
-	popw	%cx
-	popw	%es
-	movw	%cs:(int13_reg_AX - int13_handler), %ax
-	xorb	%ah, %ah	/* success */
-	ret
+	movw	%cs:(int13_cdrom_es - int13_handler), %es
+	movw	%cs:(int13_cdrom_cx - int13_handler), %cx
+	movl	%cs:(int13_cdrom_ebx - int13_handler), %ebx
+	movl	%cs:(int13_cdrom_edi - int13_handler), %edi
+	clc
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
 3:
-	popl	%edi
-	popl	%ebx
-	popw	%cx
-	popw	%es
-	movw	%cs:(int13_reg_AX - int13_handler), %ax
-	movb	$0, 2(%si)
-	movb	$2, %ah		/* I/O error */
+	movw	%cs:(int13_cdrom_es - int13_handler), %es
+	movw	%cs:(int13_cdrom_cx - int13_handler), %cx
+	movl	%cs:(int13_cdrom_ebx - int13_handler), %ebx
+	movl	%cs:(int13_cdrom_edi - int13_handler), %edi
 	stc
-	ret
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
 
-#if 0
-
-	/* step 1. read leading scrap */
-	pushl	%eax
-	movl	(%si), %eax
-	movl	%eax, %cs:(tmp_dap - int13_handler)
-	movl	4(%si), %eax
-	movl	%eax, %cs:(tmp_dap - int13_handler + 4)
-	movl	8(%si), %eax
-	movl	%eax, %cs:(tmp_dap - int13_handler + 8)
-	movl	12(%si), %eax
-	movl	%eax, %cs:(tmp_dap - int13_handler + 12)
-	popl	%eax
-
-	testb	$3, 8(%si)
-	jz	4f			/* no leading portion */
-
-	pushw	%es
-	pushw	%ebx
-
-	movl	8(%si), %ebx		/* LBA */
-	shrl	$2, 8(%si)		/* big sector LBA */
-	movb	$1, 2(%si)		/* read 1 big sector */
-
-	movw	%cs, %bx
-	movw	%bx, 6(%si)
-	movw	%bx, %es
-	movw	$edd30_disk_buffer - int13_handler, %bx
-	movw	%bx, 4(%si)
-	call	int13_with_retry
-	popw	%ebx
-	popw	%es
-
-	jc	3f
-
-	pushw	%ax
-	movb	%cs:(tmp_dap - int13_handler + 2), %ah	/* wanted small sectors */
-	movb	%cs:(tmp_dap - int13_handler + 8), %al
-	negb	%al
-	andb	$3, %al			/* available small sectors */
-	movb	$0, %ch
-	movb	%al, %cl
-	cmpb	%al, %ah
-	jnb	5f
-	movb	%ah, %cl
-5:
-	shlw	$8, %cx			/* move words */
-	repz movsw
-	popw	%ax
-4:
-	/* step 2. read regular middle part */
-
-	/* step 3. read trailing scrap */
-
-3:
-	pushl	%eax
-	movl	%cs:(tmp_dap - int13_handler), %eax
-	movl	%eax, (%si)
-	movl	%cs:(tmp_dap - int13_handler + 4), %eax
-	movl	%eax, 4(%si)
-	movl	%cs:(tmp_dap - int13_handler + 8), %eax
-	movl	%eax, 8(%si)
-	movl	%cs:(tmp_dap - int13_handler + 12), %eax
-	movl	%eax, 12(%si)
-	popl	%eax
-	ret
-
-#endif
-
 /* cache 1 big 2048-byte sector at edd30_disk_buffer */
 
 last_read_cd_drive:
@@ -3715,47 +3226,123 @@
 	.long	0xFFFFFFFF	#; lo dword. for a valid cache, lowest 2 bits=0
 	.long	0xFFFFFFFF	#; hi dword
 
+int13_data_addr_from:
+	.long	0
+int13_data_addr_to:
+	.long	0
+int13_cdrom_edi:
+	.long	0
+int13_cdrom_ebx:
+	.long	0
+int13_cdrom_cx:
+	.word	0
+int13_cdrom_bx:
+	.word	0
+int13_cdrom_es:
+	.word	0
+
 1:
 	#;jmp	1f	/* just check if CHS translation code works */
-	testw	$0x8000, -10(%bp)	/* TO_C bit 15=LBA support */
+	testw	$0x8000, %cs:4(%bp)	/* TO_C bit 15=LBA support */
 #if 0
 	jnz	int13_with_retry	/* LBA mode */
 #else
 	jz	1f			/* CHS only, so skip the LBA access */
-	pushw	%es
-	pushw	%bx
+	movw	%es, %cs:(int13_tmp_es_bx - int13_handler + 2)
+	movw	%bx, %cs:(int13_tmp_es_bx - int13_handler)
 	movw	4(%si), %bx
+	shrw	$4, %bx
+	addw	%bx, 6(%si)
+	andw	$0x000F, 4(%si)
+	cmpb	$0x80, 2(%si)
+	jb	2f			/* 0x7F sectors or less is ok */
+	ja	3f			/* 0x81 sectors or more is bad */
+
+	/* now 0x80 sectors requested. */
+
+	testw	$0x2000, %cs:4(%bp)	/* TO_C bit 13=FROM has 2048-byte cdrom sector */
+	jz	3f			/* not CDROM, fail out. */
+	/* virtual cdrom function call could request 64K data each time */
+	/* transfer 0x80 sectors = twice 0x40 sectors */
+	movb	$0x40, 2(%si)		/* transfer the first 32K */
+	movw	4(%si), %bx
 	movw	6(%si), %es
 	call	int13_with_retry
-	popw	%bx
-	popw	%es
-	jc	1f	/* LBA access failed, use CHS access once more. */
-	ret
+	jc	4f
+	movb	$0x40, 2(%si)
+	addw	$0x800, 6(%si)		/* step to next 32K of the buffer */
+	movw	4(%si), %bx
+	movw	6(%si), %es
+	pushl	%eax
+	xorl	%eax, %eax
+	movb	$0x40, %al
+	addl	%eax, 8(%si)		/* adjust start_LBA */
+	movb	$0, %al
+	adcl	%eax, 12(%si)
+	popl	%eax
+	call	int13_with_retry
+	/* we ignore this step and keep start_LBA in a modified state. This is
+	 * because only modify_boot_sectors need start_LBA and we are accessing
+	 * the virtual cdrom, so we will not call modify_boot_sectors.
+	 */
+	//pushfw
+	//pushl	%eax
+	//xorl	%eax, %eax
+	//movb	$0x40, %al
+	//subl	%eax, 8(%si)		/* adjust start_LBA */
+	//movb	$0, %al
+	//sbbl	%eax, 12(%si)
+	//popl	%eax
+	//popfw
+4:
+	movb	$0x80, 2(%si)		/* restore its original value */
+	lesw	%cs:(int13_tmp_es_bx - int13_handler), %bx
+	movw	%bx, 4(%si)		/* restore its original value */
+	movw	%es, 6(%si)		/* restore its original value */
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
+	
+2:
+	movw	4(%si), %bx
+	movw	6(%si), %es
+	call	int13_with_retry
+	lesw	%cs:(int13_tmp_es_bx - int13_handler), %bx
+	movw	%bx, 4(%si)		/* restore its original value */
+	movw	%es, 6(%si)		/* restore its original value */
+	jnc	4f
+	testw	$0x1000, %cs:4(%bp)	/* TO_C bit 12=BIFURCATE */
+	jz	1f	/* not bifurcate, use CHS access once more. */
+	stc		/* bifurcate, error out. */
+4:
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
+
+3:
+	movb	$1, %ah
+	stc
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
+
+	.align	4
+int13_tmp_es_bx:	.long	0
+
 1:
 #endif
 	/* CHS mode */
 
-	/* get AX */
-	movw	%cs:(int13_reg_AX - int13_handler), %ax
-	pushw	%ax	/* 0x42 or 0x43 */
-
 	/* byte at SI+2: number of sectors to access */
 	/* 8 bytes at SI+8: StartLBA */
 
 	/* CHS mode cannot access large addresses */
-	movl	12(%si), %eax
-	testl	%eax, %eax
+	cmpl	$0, 12(%si)
 	jnz	1f
 
 	pushl	%edx
 	pushl	%ebx
-	movw	-10(%bp), %ax	/* TO_C */
+	movw	%cs:4(%bp), %ax	/* TO_C */
 	andw	$0x3FF, %ax	/* get lo 10 bits */
 	incw	%ax		/* cylinders */
 	pushw	%ax
-	movzbw	-8(%bp), %ax	/* TO_H */
+	movzbw	%cs:6(%bp), %ax	/* TO_H */
 	incw	%ax		/* heads */
-	movzbw	-7(%bp), %bx	/* TO_S */
+	movzbw	%cs:7(%bp), %bx	/* TO_S */
 	andb	$0x3F, %bl
 	mulw	%bx		/* DX=0, AX=heads*sectors */
 	popw	%bx		/* cylinders */
@@ -3774,26 +3361,23 @@
 
 	/* we will access one sector at a time */
 
-	pushw	%es
-	pushw	%bx
-	pushw	%cx
-	pushl	%edi
-
 	movzbw	2(%si), %cx	/* sectors to transfer */
 	movl	8(%si), %edi	/* start sector number(LBA) */
 3:
 	/* translate LBA to CHS */
 
-	pushw	%cx
+	//pushw	%cx
+	movw	%cx, %cs:(int13_chs_cx - int13_handler)
 
 	/* get sectors per cylinder */
 
-	pushw	%dx
+	//pushw	%dx
+	movw	%dx, %cs:(int13_chs_dx - int13_handler)
 
 	pushl	%edi		/* lba */
-	movzbw	-8(%bp), %ax	/* TO_H */
+	movzbw	%cs:6(%bp), %ax	/* TO_H */
 	incw	%ax		/* heads */
-	movzbw	-7(%bp), %bx	/* TO_S */
+	movzbw	%cs:7(%bp), %bx	/* TO_S */
 	andb	$0x3F, %bl
 	mulw	%bx		/* DX=0, AX=sectors per cylinder */
 	popw	%cx		/* lba_lo */
@@ -3811,12 +3395,14 @@
 	shlb	$6, %dh		/* hi 2 bits of cylinder */
 	orb	%dh, %cl
 
-	popw	%dx		/* DL=drive number */
-	pushw	%dx
+	movw	%cs:(int13_chs_dx - int13_handler), %dx	/* DL=drive number */
+	//popw	%dx		/* DL=drive number */
+	//pushw	%dx
 
 	movb	%al, %dh	/* DH=head number */
 
-	pushl	%edi
+	//pushl	%edi
+	movl	%edi, %cs:(int13_chs_edi - int13_handler)
 
 	//movw	%di, %ax
 	subw	8(%si), %di	/* sectors already read */
@@ -3829,157 +3415,95 @@
 	addw	%di, %ax	/* segment */
 	movw	%ax, %es
 
-	movb	3(%bp), %ah	/* 0x42/0x02=read, 0x43/0x03=write */
+	movb	%cs:(int13_old_eax - int13_handler + 1), %ah
+				/* 0x42/0x02=read, 0x43/0x03=write */
 	andb	$0x03, %ah	/* AH=0x02 0r 0x03 */
 	movb	$0x01, %al	/* number of sectors to read/write */
 
 	call	int13_with_retry
 
-	popl	%edi
-	popw	%dx
+	movl	%cs:(int13_chs_edi - int13_handler), %edi
+	movw	%cs:(int13_chs_dx - int13_handler), %dx
+	//popl	%edi
+	//popw	%dx
 
 	incl	%edi		/* next sector */
 
-	popw	%cx
-	jc	3f
-	testb	%ah, %ah
-	jnz	3f
+	movw	%cs:(int13_chs_cx - int13_handler), %cx
+	//popw	%cx
+	jc	1f
 	loop	3b
 
-	popl	%edi
-	popw	%cx
-	popw	%bx
-	popw	%es
-	popw	%ax
-	xorb	%ah, %ah	/* success */
-	ret
-3:
-	popl	%edi
-	popw	%cx
-	popw	%bx
-	popw	%es
-	popw	%ax
-	movb	$0, 2(%si)
-	movb	$2, %ah		/* I/O error */
-	stc
-	ret
-
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
 1:
-	popw	%ax
-	movb	$0, 2(%si)
-	movb	$4, %ah		/* sector not found */
 	stc
-	ret
+	jmp	*%cs:(int13_ret_IP - int13_handler)	//ret
 
 	.align	2
+int13_ret_IP:
+	.word	0
 int13_reg_AX:
 	.word	0
+int13_chs_cx:
+	.word	0
+int13_chs_dx:
+	.word	0
 
+	.align	4
+int13_chs_edi:
+	.long	0
+
 /****************************************************************************/
 int13_with_retry:
 
-	/* backup the last DWORD in the buffer */
-	pushl	%es:0x1FC(%bx)
-	popl	%cs:(sector_last_dword - int13_handler)
+	/* save return address to memory */
+	popw	%cs:(int13_retry_IP - int13_handler)
+//	/* backup the last DWORD in the buffer */
+//	pushl	%es:0x1FC(%bx)
+//	popl	%cs:(sector_last_dword - int13_handler)
 
 	/* retry count should be an odd number initially */
 	movb	$5, %cs:(retry_count - int13_handler)
-	pushfw
 
 	cmpb	$0, %cs:(force_int13 - int13_handler)
 	jnz	3f	/* we should use current int 13 instead of ROM_int13 */
 	call	backup_int13
 3:
-	pushal
+	movb	%ah, %cs:(int13_retry_ah - int13_handler)
+	call	int13_simple
 
-	pushw	%ds
-//	pushw	%si
-	pushw	%es
-//	pushw	%bp
-//	pushw	%dx
-
-#if 0
-	cmpb	$0, %cs:(force_int13 - int13_handler)
-	jnz	2f
-
-	pushw	%ax
-	smsw	%ax
-	testb	$1, %al
-	popw	%ax
-
-	sti			/* The buggy BIOS requires STI? */
-
-	jz	4f
-
-	/* pmode */
-
-	testb	$1, %cs:(int13_scheme - int13_handler)
-	jz	4f
-2:
-	int	$0x13
-
-	jmp	2f
-4:
-	/* real mode */
-
-	pushfw
-	lcall	%cs:*(ROM_int13 - int13_handler)
-2:
-#else
-	sti
-	int	$0x13
-#endif
-//	popw	%dx
-//	popw	%bp
-	popw	%es
-//	popw	%si
-	popw	%ds
-
-	popal
-
 	jnc	3f		/* success */
 
-	/* if the last dword changed, consider it is success */
+//	/* if the last dword changed, consider it is success */
+//
+//	pushl	%eax
+//	movl	%es:0x1FC(%bx), %eax
+//	cmpl	%eax, %cs:(sector_last_dword - int13_handler)
+//	popl	%eax
+//
+//	jne	3f		/* success */
 
-	pushl	%eax
-	movl	%es:0x1FC(%bx), %eax
-	cmpl	%eax, %cs:(sector_last_dword - int13_handler)
-	popl	%eax
-
-	jne	3f		/* success */
-
 	decb	%cs:(retry_count - int13_handler)
 	jz	2f		/* finally failed */
 
 	/* reset disk and try again */
-	pushw	%ds
-	pushw	%es
-	pushal
-	xorw	%ax, %ax	/* AH=0, Reset Disk */
-	int	$0x13
-	popal
-	popw	%es
-	popw	%ds
+	movb	$0, %cs:(int13_retry_ah - int13_handler)
+	call	int13_simple
 
-	testb	$1, 3(%bp)	/* 0x42/0x02=read, 0x43/0x03=write */
-	jnz	3b		/* it is write */
+//	testb	$1, %cs:(int13_old_eax - int13_handler + 1)
+//				/* 0x42/0x02=read, 0x43/0x03=write */
+//	jnz	3b		/* it is write */
+//
+//	/* touch the last dword of the buffer */
+//	notl	%es:0x1FC(%bx)
+//	notl	%cs:(sector_last_dword - int13_handler)
 
-	/* touch the last dword of the buffer */
-	notl	%es:0x1FC(%bx)
-	notl	%cs:(sector_last_dword - int13_handler)
-
 	jmp	3b		/* try again, ignoring the reset failure */
 2:
-	/* failure */
-	popfw			/* restore IF, DF */
-	movb	$2, %ah		/* I/O error */
 	stc			/* failure */
 	jmp	2f
 3:
-	/* success */
-	popfw			/* restore IF, DF */
-	xorb	%ah, %ah	/* CF=0 */
-	//clc			/* success */
+	clc			/* success */
 2:
 	pushfw
 
@@ -3987,8 +3511,8 @@
 	jnz	2f	/* we have not touched the int 13 vector */
 	call	restore_int13
 2:
-	popfw			/* restore original flags: IF, DF, CF, ... */
-	ret
+	popfw
+	jmp	*%cs:(int13_retry_IP - int13_handler)	//ret
 
 backup_int13:
 
@@ -4023,29 +3547,189 @@
 retry_count:
 	.byte	5
 
+int13_retry_ah:
+	.byte	0
 force_int13:
 	.byte	0
 
+	.align	2
+int13_retry_IP:
+	.word	0
+int13_retry_ds:
+	.word	0
+int13_retry_es:
+	.word	0
+
 	.align	4
-tmp_int13:
+int13_retry_eax:
 	.long	0
-sector_last_dword:
+int13_retry_ebx:
 	.long	0
+int13_retry_ecx:
+	.long	0
+int13_retry_edx:
+	.long	0
+int13_retry_esi:
+	.long	0
+int13_retry_edi:
+	.long	0
+int13_retry_ebp:
+	.long	0
+tmp_int13:
+	.long	0
+//sector_last_dword:
+//	.long	0
 
 /****************************************************************************/
-modify_boot_sectors:
+int13_simple:
 
-	pushw	%es
-	pushal
-	movw	2(%bp),	%ax	/* get original AX */
-	/* check CHS read */
-	cmpb	$0x02, %ah	/* is it read? */
-	jne	3f
-	cmpw	$0x0001, %cx	/* read from cylinder 0, sector 1? */
-	je	5f
+	/* input:	CF=0	reset disk	*/
+
+	/* save return address to memory */
+	popw	%cs:(int13_simple_IP - int13_handler)
+
+	movl	%eax, %cs:(int13_retry_eax - int13_handler)
+	movl	%ebx, %cs:(int13_retry_ebx - int13_handler)
+	movl	%ecx, %cs:(int13_retry_ecx - int13_handler)
+	movl	%edx, %cs:(int13_retry_edx - int13_handler)
+	movl	%esi, %cs:(int13_retry_esi - int13_handler)
+	movl	%edi, %cs:(int13_retry_edi - int13_handler)
+	movl	%ebp, %cs:(int13_retry_ebp - int13_handler)
+	movw	%ds, %cs:(int13_retry_ds - int13_handler)
+	movw	%es, %cs:(int13_retry_es - int13_handler)
+
+	//sti
+
+	cmpb	$0, %cs:(force_int13 - int13_handler)
+	jz	3f
+	/* read 1 cdrom sector using our builtin cdrom driver. */
+
+	/* backup old variables to bak variables */
+	movl	%cs:(int13_old_eax - int13_handler), %eax
+	movl	%eax, %cs:(int13_bak_eax - int13_handler)
+	movl	%cs:(int13_old_ebx - int13_handler), %eax
+	movl	%eax, %cs:(int13_bak_ebx - int13_handler)
+	movl	%cs:(int13_old_ecx - int13_handler), %eax
+	movl	%eax, %cs:(int13_bak_ecx - int13_handler)
+	movl	%cs:(int13_old_edx - int13_handler), %eax
+	movl	%eax, %cs:(int13_bak_edx - int13_handler)
+	movl	%cs:(int13_old_esi - int13_handler), %eax
+	movl	%eax, %cs:(int13_bak_esi - int13_handler)
+	movl	%cs:(int13_old_edi - int13_handler), %eax
+	movl	%eax, %cs:(int13_bak_edi - int13_handler)
+	movl	%cs:(int13_old_ebp - int13_handler), %eax
+	movl	%eax, %cs:(int13_bak_ebp - int13_handler)
+	movw	%cs:(int13_old_ds - int13_handler), %ax
+	movw	%ax, %cs:(int13_bak_ds - int13_handler)
+	movw	%cs:(int13_old_es - int13_handler), %ax
+	movw	%ax, %cs:(int13_bak_es - int13_handler)
+	movw	%cs:(int13_old_flags - int13_handler), %ax
+	movw	%ax, %cs:(int13_bak_flags - int13_handler)
+	movl	%cs:(int13_old_cs_ip - int13_handler), %eax
+	movl	%eax, %cs:(int13_bak_cs_ip - int13_handler)
+
+	/* setup old variables for use by edd30_for_cdrom */
+
+	/* edd30_for_cdrom far return address */
+	movw	%cs, %cs:(int13_old_cs_ip + 2 - int13_handler)
+	movw	$(2f - int13_handler), %cs:(int13_old_cs_ip - int13_handler)
+	/* edd30_for_cdrom flags */
+	pushfw
+	popw	%cs:(int13_old_flags - int13_handler)
+	movw	%cs:(int13_retry_es - int13_handler), %ax
+	movw	%ax, %cs:(int13_old_es - int13_handler)
+	movw	%cs:(int13_retry_ds - int13_handler), %ax
+	movw	%ax, %cs:(int13_old_ds - int13_handler)
+	movl	%cs:(int13_retry_ebp - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_ebp - int13_handler)
+	movl	%cs:(int13_retry_edi - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_edi - int13_handler)
+	movl	%cs:(int13_retry_esi - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_esi - int13_handler)
+	movl	%cs:(int13_retry_edx - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_edx - int13_handler)
+	movl	%cs:(int13_retry_ecx - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_ecx - int13_handler)
+	movl	%cs:(int13_retry_ebx - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_ebx - int13_handler)
+	movl	%cs:(int13_retry_eax - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_eax - int13_handler)
+
+	movb	%cs:(int13_retry_ah - int13_handler), %ah
+	jmp	edd30_for_cdrom		/* will return at 2f */
+2:
+	/* restore old variables from bak variables */
+	movl	%cs:(int13_bak_eax - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_eax - int13_handler)
+	movl	%cs:(int13_bak_ebx - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_ebx - int13_handler)
+	movl	%cs:(int13_bak_ecx - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_ecx - int13_handler)
+	movl	%cs:(int13_bak_edx - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_edx - int13_handler)
+	movl	%cs:(int13_bak_esi - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_esi - int13_handler)
+	movl	%cs:(int13_bak_edi - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_edi - int13_handler)
+	movl	%cs:(int13_bak_ebp - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_ebp - int13_handler)
+	movw	%cs:(int13_bak_ds - int13_handler), %ax
+	movw	%ax, %cs:(int13_old_ds - int13_handler)
+	movw	%cs:(int13_bak_es - int13_handler), %ax
+	movw	%ax, %cs:(int13_old_es - int13_handler)
+	movw	%cs:(int13_bak_flags - int13_handler), %ax
+	movw	%ax, %cs:(int13_old_flags - int13_handler)
+	movl	%cs:(int13_bak_cs_ip - int13_handler), %eax
+	movl	%eax, %cs:(int13_old_cs_ip - int13_handler)
+	/* eax changed but no problem */
+
+	jmp	2f
 3:
+	movb	%cs:(int13_retry_ah - int13_handler), %ah
+	int	$0x13
+2:
+	movw	%cs:(int13_retry_ds - int13_handler), %ds
+	movw	%cs:(int13_retry_es - int13_handler), %es
+	movl	%cs:(int13_retry_eax - int13_handler), %eax
+	movl	%cs:(int13_retry_ebx - int13_handler), %ebx
+	movl	%cs:(int13_retry_ecx - int13_handler), %ecx
+	movl	%cs:(int13_retry_edx - int13_handler), %edx
+	movl	%cs:(int13_retry_esi - int13_handler), %esi
+	movl	%cs:(int13_retry_edi - int13_handler), %edi
+	movl	%cs:(int13_retry_ebp - int13_handler), %ebp
+
+	jmp	*%cs:(int13_simple_IP - int13_handler)	//ret
+
+	.align	2
+int13_simple_IP:
+	.word	0
+
+	.align	4
+int13_bak_cs_ip:	.long	0
+int13_bak_eax:		.long	0
+int13_bak_ebx:		.long	0
+int13_bak_ecx:		.long	0
+int13_bak_edx:		.long	0
+int13_bak_esi:		.long	0
+int13_bak_edi:		.long	0
+int13_bak_ebp:		.long	0
+int13_bak_ds:		.word	0
+int13_bak_es:		.word	0
+int13_bak_flags:	.word	0
+
+/****************************************************************************/
+modify_boot_sectors:
+
+	movw	%cs:(int13_old_eax - int13_handler), %ax
+//	/* check CHS read */
+//	cmpb	$0x02, %ah	/* is it read? */
+//	jne	3f
+//	cmpw	$0x0001, %cx	/* read from cylinder 0, sector 1? */
+//	je	5f
+//3:
 	/* check LBA read */
-	cmpb	$0x42, %ah	/* is it extended read? */
+	//cmpb	$0x42, %ah	/* is it extended read? */
+	testb	$0x01, %ah	/* is it extended read? */
 	jne	4f		/* no, do nothing. */
 	cmpl	$0, 12(%si)	/* read from LBA_high=0? */
 	jne	4f		/* no, do nothing. */
@@ -4054,7 +3738,7 @@
 	cmpl	$0, 8(%si)	/* read from LBA_low=0? */
 	je	3f		/* yes, continue. */
 
-	movzbl	-3(%bp), %eax	/* AL=Smax */
+	movzbl	%cs:3(%bp), %eax	/* AL=Smax */
 	andb	$63, %al	/* EAX=sectors per track */
 	movb	$1, %dh		/* simulate CHS read of head 1 */
 	cmpl	%eax, 8(%si)	/* read from LBA_low=sectors per track? */
@@ -4070,13 +3754,13 @@
 #;	jns	4f		/* no, do nothing */
 	cmpw	$0xaa55, %es:0x1fe(%bx)	/* is it a valid boot sector? */
 	jne	4f			/* no, skip */
-	movl	-22(%bp), %eax	/* S_count_Lo */
+	movl	%cs:16(%bp), %eax	/* S_count_Lo */
 	shrl	$1, %eax	/* map a whole drive? */
 	jz	4f		/* yes, nothing need to change */
-	movl	-14(%bp), %eax	/* StartLBA_Lo */
+	movl	%cs:8(%bp), %eax	/* StartLBA_Lo */
 	testl	%eax, %eax	/* geometry translation only? */
 	jz	4f		/* yes, needn't change */
-	movl	-6(%bp), %eax	/* FROM_DRIVE, TO_DRIVE, H, S */
+	movl	%cs:(%bp), %eax	/* FROM_DRIVE, TO_DRIVE, H, S */
 
 	testb	%al, %al	/* The FROM_DRIVE is hard drive? */
 	jns	modify_floppy	/* no, goto floppy boot record modification */
@@ -4222,7 +3906,7 @@
 	//decl	%eax
 
 	pushl	%eax		/* EAX-1=end sector number */
-	movzwl	-4(%bp), %eax	/* Hmax, Smax */
+	movzwl	%cs:2(%bp), %eax	/* Hmax, Smax */
 	andb	$63, %ah
 	movzbl	%ah, %ecx
 	mulb	%cl
@@ -4251,7 +3935,7 @@
 				/* EAX hi=0, EDX hi=0 */
 	xchgw	%ax, %cx	/* CX=cylinder number */
 	xchgw	%ax, %dx	/* AX=sector number in the last cylinder */
-	movb	-3(%bp), %dl	/* DL=Smax */
+	movb	%cs:3(%bp), %dl	/* DL=Smax */
 	andb	$63, %dl
 	divb	%dl		/* AL=head number, AH=sector number - 1 */
 	stosb			/* DI=BX+0x1c4 */
@@ -4265,8 +3949,7 @@
 
 4:
 	/* end partition table modification */
-	popal
-	popw	%es
+	/* needn't restore registers */
 	ret
 
 /****************************************************************************/
@@ -4276,26 +3959,6 @@
 
 	cmpb	$0x00, %dh	/* read from head 0? */
 	jne	4b
-#;	xorl	%eax, %eax
-#;	cmpl	%eax, %es:0x1c(%bx)	/* Number of hidden sectors */
-#;	je	4b
-#;	cmpl	$0x33544146, %es:0x52(%bx)	/* FAT32? */
-#;	je	5f
-#;	/* NTFS drive number is also at offset 0x24 */
-#;	//cmpl	$0x31544146, %es:0x36(%bx)	/* FAT16? */
-#;	//jne	4b
-#;	cmpw	$0x80, %es:0x24(%bx)	/* Physical drive number */
-#;	jne	4b
-#;	movb	%al, %es:0x24(%bx)	/* AL=floppy drive number */
-#;	jmp	6f
-#;5:
-#;	cmpb	$0x80, %es:0x40(%bx)	/* Physical drive number */
-#;	jne	4b
-#;	movb	%al, %es:0x40(%bx)	/* AL=0 means floppy */
-#;6:
-#;	movl	%eax, %es:0x1c(%bx)	/* let number of hidden sectors=0 */
-#;	/*movb	$0xf0, %es:0x15(%bx)*/	/* set floppy media descriptor */
-#;	jmp	4b
 
 	pushl	%ecx
 	pushw	%si
@@ -4339,17 +4002,15 @@
 /****************************************************************************/
 modify_HD_DOS:
 
-//	cmpb	$0x42, 3(%bp)		/* is extended read? */
-//	je	4b
 	cmpb	$0x01, %dh		/* read from head 1? */
 	jne	4b
-	movl	-14(%bp), %eax		/* StartLBA_Lo */
+	movl	%cs:8(%bp), %eax		/* StartLBA_Lo */
 	testl	%eax, %eax
 	jz	4b
 	cmpl	%eax, %es:0x1c(%bx)	/* Number of hidden sectors */
 	jbe	4b
 	subl	%eax, %es:0x1c(%bx)
-	movzbl	-3(%bp), %eax		/* AL=Smax */
+	movzbl	%cs:3(%bp), %eax		/* AL=Smax */
 	andb	$63, %al
 	cmpl	%eax, %es:0x1c(%bx)	/* Number of hidden sectors */
 	jnb	4b
@@ -4359,12 +4020,12 @@
 /****************************************************************************/
 modify_in_situ:
 
-	pushw	%es
-	pushal
-	//movw	2(%bp),	%ax	/* get original AX */
+	movb	%al, %cs:(int13_in_situ_sectors - int13_handler)
 
+	cld
+
 	/* if FROM is not harddrive, do nothing. */
-	testb	$0x80, -6(%bp)	/* FROM drive */
+	testb	$0x80, %cs:(%bp)	/* FROM drive */
 	jz	4f
 
 	cmpb	$0x02, %ah	/* is it CHS read? */
@@ -4377,10 +4038,10 @@
 	movw	%dx, %di	/* save DX to DI */
 	movw	%cx, %si	/* save CX to SI */
 
-	movb	-7(%bp), %al	/* TO_S */
+	movb	%cs:7(%bp), %al	/* TO_S */
 	andb	$63, %al
 	movzbw	%al, %dx
-	mulb	-8(%bp)
+	mulb	%cs:6(%bp)	/* TO_H */
 	addw	%dx, %ax	/* AX=sectors_per_cylinder */
 
 	/* get current cylinder number */
@@ -4399,10 +4060,12 @@
 
 	/* get current head number */
  
-	movb	-7(%bp), %al	/* TO_S */
+	movb	%cs:7(%bp), %al	/* TO_S */
 	andb	$63, %al
 	mulb	%dh		/* AX=sectors */
+
 	popl	%edx
+
 	movzwl	%ax, %eax
 	addl	%edx, %eax
 
@@ -4411,7 +4074,7 @@
 	decw	%cx
 	movzbl	%cl, %ecx
 	addl	%ecx, %eax	/* EAX=start sector number */
-	movzbl	2(%bp),	%ecx	/* sectors read */
+	movzbl	%cs:(int13_in_situ_sectors - int13_handler), %ecx
 	jmp	6f
 	
 3:
@@ -4432,23 +4095,23 @@
 
 	/* if EAX <= startLBA_Lo < EAX + ECX, then the boot sector is read. */
 
-	cmpl	-14(%bp), %eax	/* startLBA_Lo */
+	cmpl	%cs:8(%bp), %eax	/* startLBA_Lo */
 	ja	4f		/* boot sector was not read */
 	addl	%eax, %ecx
-	cmpl	-14(%bp), %ecx
+	cmpl	%cs:8(%bp), %ecx
 	jbe	4f		/* boot sector was not read */
 
-	movl	-14(%bp), %ecx
+	movl	%cs:8(%bp), %ecx
 	subl	%eax, %ecx	/* sectors between ES:BX and boot record */
 
 	/* modify hidden sectors of the partition boot record */
-	cmpb	$0x07, -10(%bp)	/* NTFS */
+	cmpb	$0x07, %cs:4(%bp)	/* NTFS */
 	je	3f
-	cmpb	$0x0C, -10(%bp)	/* FAT32(LBA) */
+	cmpb	$0x0C, %cs:4(%bp)	/* FAT32(LBA) */
 	je	3f
-	cmpb	$0x0E, -10(%bp)	/* FAT12/16 */
+	cmpb	$0x0E, %cs:4(%bp)	/* FAT12/16 */
 	je	3f
-	cmpb	$0x83, -10(%bp)	/* EXT2 */
+	cmpb	$0x83, %cs:4(%bp)	/* EXT2 */
 	jne	4f
 3:
 	movw	%es, %ax
@@ -4457,7 +4120,7 @@
 	movw	%ax, %es
 	cmpw	$0xaa55, %es:0x1fe(%bx)
 	jne	4f
-	movl	-14(%bp), %eax	/* startLBA_Lo */
+	movl	%cs:8(%bp), %eax	/* startLBA_Lo */
 	movl	%eax, %es:0x1c(%bx)
 
 	jmp	4f
@@ -4471,7 +4134,7 @@
 	/* first, the MS magic number should be non-zero */
 	cmpl	$0, %es:0x1b8(%bx)
 	jne	5f
-	movb	-6(%bp), %al	/* FROM drive */
+	movb	%cs:(%bp), %al	/* FROM drive */
 	movb	%al, %es:0x1b8(%bx)	/* let it be the FROM_DRIVE */
 5:
 	leaw	0x1be(%bx), %di	/* DI=BX+0x1be */
@@ -4534,7 +4197,7 @@
 
 	/* DI=BX+0x1be */
 
-	movl	-14(%bp), %eax	/* startLBA_Lo */
+	movl	%cs:8(%bp), %eax	/* startLBA_Lo */
 
 	call	lba_to_chs
 
@@ -4542,8 +4205,8 @@
 	//movb	$0x00, %al	/* clear boot indicator */
 	stosl			/* DI=BX+0x1c2 */
 
-	movl	-22(%bp), %eax
-	addl	-14(%bp), %eax
+	movl	%cs:16(%bp), %eax
+	addl	%cs:8(%bp), %eax
 	decl	%eax		/* endLBA */
 	
 	call	lba_to_chs
@@ -4551,14 +4214,14 @@
 	/* if in situ, TO_C holds the partition type:
 	 * 	0x07(NTFS), 0x0C(FAT32), 0x0E(FAT12/16), 0x83(EXT2/3)
 	 */
-	movb	-10(%bp), %al	/* TO_C */
+	movb	%cs:4(%bp), %al	/* TO_C */
 	stosl			/* DI=BX+0x1c6 */
 
 	/* modify start sector and sector count */
 
-	movl	-14(%bp), %eax
+	movl	%cs:8(%bp), %eax
 	stosl			/* DI=BX+0x1ca */
-	movl	-22(%bp), %eax
+	movl	%cs:16(%bp), %eax
 	stosl			/* DI=BX+0x1ce */
 
 #if 1
@@ -4661,10 +4324,11 @@
 
 4:
 	/* end partition table and BPB modification */
-	popal
-	popw	%es
 	ret
 
+int13_in_situ_sectors:
+	.byte	0
+
 /****************************************************************************/
 
 lba_to_chs:
@@ -4682,7 +4346,7 @@
 	 */
 
 	pushl	%eax		/* EAX=end sector number */
-	movzwl	-8(%bp), %eax	/* TO_H, TO_S */
+	movzwl	%cs:6(%bp), %eax	/* TO_H, TO_S */
 	andb	$63, %ah
 	movzbl	%ah, %ecx
 	mulb	%cl
@@ -4711,7 +4375,7 @@
 				/* EAX hi=0, EDX hi=0 */
 	xchgw	%ax, %cx	/* CX=cylinder number */
 	xchgw	%ax, %dx	/* AX=sector number in the last cylinder */
-	movb	-7(%bp), %dl	/* TO_S */
+	movb	%cs:7(%bp), %dl	/* TO_S */
 	andb	$63, %dl
 	divb	%dl		/* AL=head number, AH=sector number - 1 */
 	//stosb			/* DI=BX+0x1c4 */
@@ -4734,9 +4398,9 @@
 	ret
 
 /****************************************************************************/
-ENTRY(atapi_dev_count)	.long	0
-ENTRY(min_cdrom_id)	.long	0xE0
-max_cdrom_id:		.long	0xE0
+max_cdrom_id:		.byte	0xE0
+
+	.align	4
 ENTRY(memdisk_raw)	.long	1	/* set to 0 if accessing memdrives using int15/AH=87h */
 ENTRY(a20_keep_on)	.long	1	/* set to 0 if a20 should be auto-off */
 ENTRY(lba_cd_boot)	.long	0	/* LBA of no-emulation boot image, in 2048-byte sectors */
@@ -5268,62 +4932,72 @@
 
 #include "a20.inc"
 
-// Input:
-//	dl=0 - Disable A20
-//	dl=1 - Eanble A20
+/****************************************************************************/
 
+/* EDD30 code imported from edd30.asm of Smart Boot Manager. */
 
-int13_enable_a20:
-	movw	$0x2400,%ax
-	addb	%dl, %al
-	stc
-	pushfw
-	lcall	%cs:*(ROM_int15 - int13_handler)
-	jnc	int13_a20_gloop2ret
-	
-	call    int13_a20_gloop1
+/*
+#; asmsyntax=nasm
+#;
+#; CD-ROM Boot Extension v 1.1 for Smart Boot Manager
+#; 
+#; Copyright (C) 2000, Christopher Li <chrisl@gnuchina.org>.
+#; Copyright (C) 2000, James Su <suzhe@gnuchina.org>
+#;
+#; This is free software, you can redistribute it and/or modify it
+#; under the terms of the GNU General Public License version 2 or above.
+#;
+#; The ATAPI driver is based on the source code of atadrv written by
+#; Hale Landis <hlandis@ibm.net>, Thanks him a lot!
+#;
+#; Without his great program, we could not implement the CD-ROM Boot feature
+#; so quickly.
+#;
+*/
 
-	movb	$KC_CMD_WOUT, %al
-	outb	$K_CMD
 
-int13_a20_gloopint1:
-	inb	$K_STATUS
-	andb	$K_IBUF_FUL, %al
-	jnz	int13_a20_gloopint1
+//#define	EDD_3_0
 
-	movb	$KB_OUTPUT_MASK, %al
-	
-	orb	%dl, %dl
-	jz	int13_a20_gdoit
-	orb	$KB_A20_ENABLE, %al
+#define	sane_check
+#define	check_extra_fail
 
-int13_a20_gdoit:
-	outb	$K_RDWR
+//#define CB_DATA	0	//; data reg         in/out pio_base_addr1+0
+//#define CB_FR		1	//; feature reg         out pio_base_addr1+1
+//#define CB_SC		2	//; sector count     in/out pio_base_addr1+2
+//#define CB_SN		3	//; sector number    in/out pio_base_addr1+3
+//#define CB_CL		4	//; cylinder low     in/out pio_base_addr1+4
+//#define CB_CH		5	//; cylinder high    in/out pio_base_addr1+5
+//#define CB_DH		6	//; device head      in/out pio_base_addr1+6
+//#define CB_STAT	7	//; primary status   in     pio_base_addr1+7
+//#define CB_CMD	7	//; command             out pio_base_addr1+7
+//#define CB_DC		8	//; device control      out pio_base_addr2+6
+//#define CB_ASTAT	8	//; alternate status in     pio_base_addr2+6
+//#define CB_DC_SRST	0x04	//; soft reset
+#define	CB_STAT_BSY	0x80	//; busy
+#define	CB_STAT_RDY	0x40	//; ready
+#define	CB_STAT_SKC	0x10	//; seek complete
 
-	call	int13_a20_gloop1
+#define	CB_STAT_DRQ	0x08	//; data request
+#define	CB_STAT_ERR	0x01	//; error
 
-	/* output a dummy command (USB keyboard hack) */
-	movb	$0xff, %al
-	outb	$K_CMD
-	call	int13_a20_gloop1
-	
-	jmp	int13_a20_gloop2ret
+#define	CB_SC_P_TAG	0xf8	//; ATAPI tag (mask)
+#define	CB_SC_P_REL	0x04	//; ATAPI release
+#define	CB_SC_P_IO	0x02	//; ATAPI I/O
+#define	CB_SC_P_CD	0x01	//; ATAPI C/D
 
-int13_a20_gloop1:
-	inb	$K_STATUS
-	andb	$K_IBUF_FUL, %al
-	jnz	int13_a20_gloop1
+#define	FAILBIT8	0x0100	//; SC( CD/IO bits) wrong at end of cmd
+#define	FAILBIT6	0x0040	//; byte count wrong at data packet xfer time
+#define	FAILBIT5	0x0020	//; SC (IO bit) wrong at data packet xfer time
+#define	FAILBIT4	0x0010	//; SC (CD bit) wrong at data packet xfer time
+#define	FAILBIT3	0x0008	//; byte count wrong at cmd packet xfer time
+#define	FAILBIT2	0x0004	//; SC wrong at cmd packet xfer time
+#define	FAILBIT0	0x0001	//; slow setting BSY=1 or DRQ=1 after AO cmd
 
-int13_a20_gloop2:
-	inb	$K_STATUS
-	andb	$K_OBUF_FUL, %al
-	jz	int13_a20_gloop2ret
-	inb	$K_RDWR
-	jmp	int13_a20_gloop2
+#define	CB_DC_HD15	0x08	//; bit should always be set to one
+#define	CB_DC_NIEN	0x02	//; disable interrupts
+#define	cmd_DC	CB_DC_HD15
+#define cmd_DC_ni CB_DC_HD15 | CB_DC_NIEN
 
-int13_a20_gloop2ret:
-	ret
-
 /****************************************************************************/
 
 __reg_select_dev:
@@ -5400,7 +5074,7 @@
 
 
 select_atapi:
-	cmpw	atapi_cur_dev - int13_handler, %ax	# device serial number
+	cmpw	%cs:(atapi_cur_dev - int13_handler), %ax	# device serial number
 	jne	select_atapi_force
 	//clc	#; CF already cleared
 	ret
@@ -5415,31 +5089,31 @@
 	pushw	%cs
 	popw	%es
 
-	cmpw	atapi_dev_count - int13_handler, %ax
+	cmpb	%cs:(atapi_dev_count - int13_handler), %al
 	cmc
 	jb	2f
 
-	movw	%ax, atapi_cur_dev - int13_handler	# device serial number
+	movw	%ax, %cs:(atapi_cur_dev - int13_handler)	# device serial number
 
 	movw	$atapi_dev_base - int13_handler, %si	# array of ATAPI reg pointer and dev
 	shlw	$2, %ax					# each element of array has 4 bytes
 	addw	%ax, %si
-	movw	(%si), %bx				# BX is the reg pointer of the current device
+	movw	%cs:(%si), %bx				# BX is the reg pointer of the current device
 
 	call	reg_setup_base_addr			# fill the 10-word reg_addr area
 							# change no registers
 
-	movw	2(%si), %bx				# BX is the dev number of the current device
+	movw	%cs:2(%si), %bx				# BX is the dev number of the current device
 	movw	%bx, %ax
 
 	call	set_timeout				# set timeout for reg_select_dev
 							# change no registers
 
-	call	reg_select_dev	#; reg_select_dev
+	call	reg_select_dev
 
-	addb	$0x0A, %bl	#; BL= 0x0A or 0x0B
-	shlb	$4, %bl		#; BL= 0xA0 or 0xB0
-	movb	%bl, reg_cur_dev - int13_handler
+	addb	$0x0A, %bl		#; BL= 0x0A or 0x0B
+	shlb	$4, %bl			#; BL= 0xA0 or 0xB0
+	movb	%bl, %cs:(reg_cur_dev - int13_handler)
 
 	clc
 2:
@@ -5518,7 +5192,8 @@
 
 	movw	%ds, %ax	# save DS
 
-	movw	-18(%bp), %ds	# get DS for the disk address packet
+	# get DS for the disk address packet
+	movw	%cs:(int13_old_ds - int13_handler), %ds
 	movw	2(%si), %cx	# struc_int13ext.blk_count
 	movw	4(%si), %di	# struc_int13ext.buf_addr_off
 	movw	6(%si), %bx	# struc_int13ext.buf_addr_seg
@@ -5863,7 +5538,7 @@
 	pushw	%di
 	cld			# store upward
 	movw	$reg_addr - int13_handler, %di	# points to 10-word space
-	movw	(%bx), %ax	# get base address
+	movw	%cs:(%bx), %ax	# get base address
 	# store 8 ports(command block registers)
 
 #if 0
@@ -5900,8 +5575,8 @@
 	incw	%ax
 	stosw
 
-	movw	2(%bx), %ax	# get base address
-	stosw			# store 2 ports(control block registers)
+	movw	%cs:2(%bx), %ax		# get base address
+	stosw				# store 2 ports(control block registers)
 	incw	%ax
 	stosw
 	popw	%di
@@ -5920,7 +5595,7 @@
 				# not 20 seconds, but 5 seconds
 	 			#; FIXME: Midnight overflow
 	 			# Midnight overflow is handled in check_timeout
-	movl	%eax, time_out - int13_handler
+	movl	%eax, %cs:(time_out - int13_handler)
 	popl	%eax
 	ret
 
@@ -6084,10 +5759,6 @@
 	jz	3f
 	movb	$52, %bh		#; error
 
-#ifdef DEBUG
-	print_stat [.status],"%b %s check BSY=0 DRQ=1 now\n",bx,STAT_BUF
-#endif
-
 	jmp	2f
 3:
 
@@ -6099,27 +5770,16 @@
 	jnz	4f
 3:
 	orb	$FAILBIT2, %bl		#; error
-#ifdef DEBUG
-	print_stat [.status],"%b %s %b check reason\n",bx,STAT_BUF,[.reason]
-#endif
 4:
 	movw	_bcnt_ - int13_handler, %ax
 	cmpw	24(%bp), %ax
 	jz	3f
 	orb	$FAILBIT3, %bl		#; error
 
-#ifdef DEBUG
-	print_stat [.status],"%b %s 0x%x check packet_len\n",bx,STAT_BUF,[.bcnt]
-#endif
-
 3:
 
 #endif	//; sane_check
 
-#ifdef DEBUG
-	debug_print "sending cmd buffer"
-#endif
-
 	movw	$atapi_cmd_buffer - int13_handler, %si
 #if 0
 	movw	$12, %cx		#; cmd_buff_len is 12
@@ -6137,9 +5797,6 @@
 3:
 	# while
 
-#ifdef DEBUG
-	debug_print "  data transfer ----------------------------\n"
-#endif
 	call	sub_atapi_delay
 4:	    
 	# while {inbyte CB_ASTAT},{test al,CB_STAT_BSY},nz
@@ -6156,10 +5813,6 @@
 	# endwhile
 4:
 
-#ifdef DEBUG
-	print_stat al,"%b %s wait ASTAT BSY=0\n",bx,STAT_BUF
-#endif
-
 	#; Data transfer loop
 	#; read the primary state register
 
@@ -6183,22 +5836,11 @@
 	inb	%dx, %al
 	movb	%al, _bcnt_ - int13_handler + 1
 
-#ifdef DEBUG
-	print_stat [.status],"%b %s pre-data reason=%b len=%d\n",bx,STAT_BUF,[.reason],[.bcnt]
-
-	print_stat [.status],"  stat "
-	debug_print "  check the device said end of command"
-#endif
-
 	testb	$(CB_STAT_BSY | CB_STAT_DRQ), _status_ - int13_handler
 	jnz	4f
 	orb	$0x80, 18(%bp)		#; NON_DATA
 	jmp	2f
 4:
-#ifdef DEBUG
-	debug_print "  device want transfer data BSY = 0 DRQ =1"
-#endif
-
 	movb	_status_ - int13_handler, %al
 	andb	$(CB_STAT_BSY | CB_STAT_DRQ), %al
 	cmpb	$CB_STAT_DRQ, %al
@@ -6208,46 +5850,22 @@
 4:
 
 #ifdef sane_check
-
-#ifdef DEBUG
-	print_stat al,"  stat "
-	debug_print "  check: C/nD=0, IO=1 (read) or IO=0 (write)"
-#endif
 	testb	$(CB_SC_P_TAG | CB_SC_P_REL | CB_SC_P_CD), _reason_ - int13_handler
 	jz	4f
-
 	orb	$FAILBIT4, %bl		#; error
-
-#ifdef DEBUG
-	print_stat al, "  FAIL:%b %s reason=%b C/nD=0, IO=1 (read) or IO=0 (write)\n",bx,STAT_BUF,[.reason],
-#endif
 4:
 	testb	$CB_SC_P_IO, _reason_ - int13_handler
 	jz	4f
 	cmpb	$0, 18(%bp)
 	jz	4f
 	orb	$FAILBIT5, %bl		#; error
-
-#ifdef DEBUG
-	print_stat al, "  FAIL:%b %s reason=%b dir=%d\n",bx,STAT_BUF,[.reason],[.dir]
-#endif
-
 4:
-
 #endif	//; sane_check
 
 	#; do the slow data transfer
 
-#ifdef DEBUG
-	debug_print "  do slow delay"
-#endif
-
 	call	sub_atapi_delay
 
-#ifdef DEBUG
-	debug_print "  check data len zero"
-#endif
-
 	movw	_bcnt_ - int13_handler, %ax
 	orw	%ax, %ax
 	jnz	4f
@@ -6256,10 +5874,6 @@
 	jmp	2f
 4:
 
-#ifdef DEBUG
-	debug_print "  check the buffer len" 
-#endif
-
 #ifdef sane_check 
 	cmpw	$0x8000, %ax		#; REG_ATAPI_MAX_BYTES
 	jna	4f
@@ -6316,11 +5930,6 @@
 	jna	3f
 
 	movb	$57, %bh		#; error: time is out
-
-#ifdef DEBUG
-	debug_print "  end of command, wait for BSY=0\n"
-#endif
-
 	jmp	2f
 3:
 
@@ -6332,11 +5941,6 @@
 	jz	1f
 
 	movb	$58, %bh		#; error
-
-#ifdef DEBUG
-	debug_print "Error: final check for stat al\n"
-#endif
-
 	jmp	2f
 1:
 	# inbyte CB_SC, [.reason]
@@ -6355,20 +5959,11 @@
 	jnz	2f
 1:
 	orw	$FAILBIT8, %bx		#; error
-
-#ifdef DEBUG
-	debug_print "FAIL:final check for protocol failures C/nD=1 IO=1\n"
-#endif
-
 2:
 #endif	//; check_extra_fail
 
 #;	outbyte CB_DC,cmd_DC
 
-#ifdef DEBUG
-	debug_print " end of command, ec:failbit=%x, %d bytes data\n",bx,cx
-#endif
-
 	movw	%bx, 14(%bp)	# __AX	#; error
 	movw	%cx, 12(%bp)	# __CX
 
@@ -6527,50 +6122,71 @@
 //	;   -20 es
 //	;   -24 edx
 
+	/* will read these variables:
+	 *	int13_old_eax
+	 *	int13_old_ebx
+	 *	int13_old_ecx
+	 *	int13_old_edx
+	 *	int13_old_esi
+	 *	int13_old_edi
+	 *	int13_old_ebp
+	 *	int13_old_ds
+	 *	int13_old_es
+	 *	int13_old_flags
+	 *	int13_old_cs_ip
+	 * will write these variables:
+	 *	int13_old_eax
+	 *	int13_old_ebx
+	 *	int13_old_ecx
+	 *	int13_old_flags
+	 */
+
 	sti
 
 	cld
 
-	pushaw
-	pushw	%ds
-	pushw	%es
-	pushl	%edx
 	pushw	%cs
 	popw	%ds
 
-	pushw	%ax
 	movzbw	%dl, %ax
 	subb	%cs:(min_cdrom_id - int13_handler), %al
 	call	select_atapi	#; select_atapi_force
-	popw	%ax
+	movw	%cs:(int13_old_eax - int13_handler), %ax
 
 	jnc	1f
 	movb	$0xAA, %ah
-	jmp	edd30_for_cdrom_fail_out
+	jmp	2f	//fail_out
 1:
-	movw	$(edd30_act_table_end - edd30_act_table), %cx
-	xorw	%bx, %bx
-1:
-	cmpb	%ah, (edd30_act_table - int13_handler)(%bx)
-	je	1f
-	incw	%bx
-	loop	1b
-	jmp	edd30_for_cdrom_invalid_cmd
-1:
-	shlw	$1, %bx
-	jmp	*(edd30_jmp_table - int13_handler)(%bx)
+	cmpb	$0, %ah
+	je	6f	//reset
+	cmpb	$1, %ah
+	je	7f	//get_last_stat
+	cmpb	$0x41, %ah
+	je	8f	//install_check
+	cmpb	$0x42, %ah
+	je	9f	//ext_read
+	cmpb	$0x43, %ah
+	je	10f	//ext_write
+	cmpb	$0x44, %ah		/* verify sectors */
+	je	5f	//success_out
+	cmpb	$0x47, %ah		/* extended seek */
+	je	5f	//success_out
+	cmpb	$0x48, %ah
+	je	11f	//get_drv_param
+	cmpb	$0x4B, %ah
+	jne	3f	//invalid_cmd
 
-edd30_for_cdrom_stop_disk_emu:
-	cmpb	$1, %al		/* only 0x4B01 supported */
-	jne	edd30_for_cdrom_invalid_cmd
+	//stop_disk_emu:
+	cmpb	$1, %al			/* only 0x4B01 supported */
+	jne	3f	//invalid_cmd
 
 	movw	%si, %di
-	pushw	-18(%bp)	/* old DS */
-	popw	%es
+	movw	%cs:(int13_old_ds - int13_handler), %es
 	movw	$0x0013, %ax	/* packet size=13h, boot type=0 (no-emu) */
 	cld
 	stosw
-	movb	%dl, %al	/* drive=DL, controller=0 */
+	//movb	%dl, %al	/* drive=DL, controller=0 */
+	movb	%cs:(int13_old_edx - int13_handler), %al	/* drive=DL, controller=0 */
 	stosw
 	xorw	%ax, %ax
 	stosw
@@ -6581,152 +6197,96 @@
 	movb	$4, %al
 	stosw			/* sector count=4 */
 				/* CHS makes no sense for no-emu */
-	jmp	edd30_for_cdrom_success_out
+	jmp	5f	//success_out
 
-edd30_for_cdrom_get_drv_param:
-	call	edd30_get_cdrom_param
-	jnc	edd30_for_cdrom_success_out
-	jmp	edd30_for_cdrom_invalid_cmd
+11:	//get_drv_param:
+	movw	%cs:(int13_old_ds - int13_handler), %ds
+	cmpw	$26, (%si)
+	jb	3f		//invalid_cmd
 
-edd30_for_cdrom_ext_write:
+	movw	$26, (%si)
+//	movw	$0x74, 2(%si)		#; struc_extparam.flags: removable, lock, chg line
+	movw	$0x00, 2(%si)		# none, tinybit 2007-11-15
+	movw	$0x800, 24(%si)		# bytes per sect=2048
+	xorl	%eax, %eax
+	decw	%ax
+	movl	%eax, 4(%si)		# cylinders=0xFFFF
+	movb	$0, %ah
+	movl	%eax, 8(%si)		# heads=0xFF
+	movb	$15, %al
+	movl	%eax, 12(%si)		# sectors per track=15
+	movl	%eax, 20(%si)		# total sectors hi dword=0
+	xorw	%ax, %ax		# CF cleared
+	decl	%eax			# EAX=0xFFFFFFFF
+	movl	%eax, 16(%si)		# total sectors lo dword
+					# CF is cleared
+	jmp	5f	//success_out
+
+10:	//ext_write:
 	movb	$0x03, %ah	# error code of write-protection
-	jmp	edd30_for_cdrom_fail_out
+	jmp	2f	//fail_out
 
-edd30_for_cdrom_ext_read:
+9:	//ext_read:
 	call	edd30_read_cdrom
-	jnc	edd30_for_cdrom_success_out
-	jmp	edd30_for_cdrom_fail_out
+	jnc	5f	//success_out
+	jmp	2f	//fail_out
 
-edd30_for_cdrom_install_check:
+8:	//install_check:
 	cmpw	$0x55AA, %bx	# added by tinybit 2007-11-15
-	jne	edd30_for_cdrom_invalid_cmd
+	jne	3f	//invalid_cmd
 
-	movw	$0xAA55, -8(%bp)	#; bx=0xaa55
+	movw	$0xAA55, %cs:(int13_old_ebx - int13_handler)	#; bx=0xaa55
 	movb	$0x21, %ah	# ah=0x21  edd-1.1
-//	movb	$0x07, -4(%bp)	#; cx= 0x01 | 0x04, ext disk access and edd ok
-	movb	$0x01, -4(%bp)	# cx=0x01, ext disk access ok -- tinybit 2007-11-15
-	jmp	edd30_for_cdrom_success_out_no_ah
+	movb	$0x01, %cs:(int13_old_ecx - int13_handler)	# cx=0x01, ext disk access ok -- tinybit 2007-11-15
+	jmp	4f	//success_out_no_ah
 
-edd30_for_cdrom_get_last_stat:
-	movb	int13_last_stat - int13_handler, %ah
-	jmp	edd30_for_cdrom_success_out_no_ah
+7:	//get_last_stat:
+	movb	%cs:(int13_last_stat - int13_handler), %ah
+	jmp	4f	//success_out_no_ah
 
-edd30_for_cdrom_reset:
+6:	//reset:
 	call	reg_reset
-	movw	atapi_cur_dev - int13_handler, %ax	# device serial number
+	movw	%cs:(atapi_cur_dev - int13_handler), %ax	# device serial number
 	call	select_atapi_force
 
-edd30_for_cdrom_success_out:
+5:	//success_out:
 	xorb	%ah, %ah
 
-edd30_for_cdrom_success_out_no_ah:
-	andb	$0xFE, 10(%bp)
+4:	//success_out_no_ah:
+	andb	$0xFE, %cs:(int13_old_flags - int13_handler)
 	jmp	1f
 
-edd30_for_cdrom_invalid_cmd:
+3:	//invalid_cmd:
 	movb	$0x01, %ah
 
-edd30_for_cdrom_fail_out:
-	orb	$1, 10(%bp)	// set CF=1 for ERROR
+2:	//fail_out:
+	orb	$1, %cs:(int13_old_flags - int13_handler)	// set CF=1 for ERROR
 
 1:
 	/* set error code AH */
-	movb	%ah, int13_last_stat - int13_handler
-	movb	%ah, 3(%bp)
+	movb	%ah, %cs:(int13_last_stat - int13_handler)
+	movb	%ah, %cs:(int13_old_eax + 1 - int13_handler)
 
-	popl	%edx
-	popw	%es
-	popw	%ds
-	popaw
-	popw	%bp
-	popl	%eax
-	iret
+	movl	%cs:(int13_old_eax - int13_handler), %eax
+	movl	%cs:(int13_old_ebx - int13_handler), %ebx
+	movl	%cs:(int13_old_ecx - int13_handler), %ecx
+	movl	%cs:(int13_old_edx - int13_handler), %edx
+	movl	%cs:(int13_old_esi - int13_handler), %esi
+	movl	%cs:(int13_old_edi - int13_handler), %edi
+	movl	%cs:(int13_old_ebp - int13_handler), %ebp
+	movw	%cs:(int13_old_ds - int13_handler), %ds
+	movw	%cs:(int13_old_es - int13_handler), %es
 
-#;============================================================================
-edd30_get_cdrom_param:
-	pushw	%ds
-	movw	-18(%bp), %ax		#; restore ds
-	movw	%ax, %ds
-	movw	(%si), %ax
-	cmpw	$26, %ax
-	jb	1f			# CF set, failure
+	/* restore old flags */
+	pushw	%cs:(int13_old_flags - int13_handler)
+	popfw
+	/* transfer control to caller */
+	ljmp	*%cs:(int13_old_cs_ip - int13_handler)
 
-	movw	$26, %ax
-	movw	%ax, (%si)
-//	movw	$0x74, 2(%si)		#; struc_extparam.flags: removable, lock, chg line
-	movw	$0x00, 2(%si)		# none, tinybit 2007-11-15
-	movw	$0x800, 24(%si)		# bytes per sect=2048
-	xorl	%eax, %eax
-	decw	%ax
-	movl	%eax, 4(%si)		# cylinders=0xFFFF
-	movb	$0, %ah
-	movl	%eax, 8(%si)		# heads=0xFF
-	movb	$15, %al
-	movl	%eax, 12(%si)		# sectors per track=15
-	movl	%eax, 20(%si)		# total sectors hi dword=0
-	xorw	%ax, %ax		# CF cleared
-	decl	%eax			# EAX=0xFFFFFFFF
-	movl	%eax, 16(%si)		# total sectors lo dword
-					# CF is cleared
-1:
-	popw	%ds
-	ret
-
 #;============================================================================
 
-
-//cdemu_act_table:
-//	.byte	0x0, 0x1, 0x2, 0x4, 0x8, 0x15, 0x16, 0x4B
-//cdemu_act_table_end:
-
-//cdemu_jmp_table:
-//	.word	edd30_for_cdrom_success_out - int13_handler		#; 0 reset 
-//	.word	edd30_for_cdrom_get_last_stat - int13_handler		#; 1 get last state
-//	.word	cdemu_int13h_emu_read - int13_handler			#; 2 read
-//	.word	cdemu_int13h_emu_read - int13_handler			#; 4 verify
-//	.word	cdemu_int13h_emu_get_param - int13_handler		#; 8 get param
-//	.word	cdemu_int13h_emu_get_type - int13_handler		#; 0x15 get type
-//	.word	edd30_for_cdrom_success_out - int13_handler		#; 0x16 detect disk change
-//	.word	edd30_for_cdrom_stop_disk_emu - int13_handler		#; 0x4b stop disk emu
-
-
-edd30_act_table:
-	.byte	0x0, 0x1, /*0x15,*/ 0x41, 0x42, 0x43, 0x44, /*0x45, 0x46,*/ 0x47, 0x48, /*0x49, 0x4D, 0x4A, 0x4C, 0x4E,*/ 0x4B
-edd30_act_table_end:
-
-edd30_jmp_table:
-	.word	edd30_for_cdrom_reset - int13_handler
-	.word	edd30_for_cdrom_get_last_stat - int13_handler
-//#;	.word	edd30_for_cdrom_get_disk_type - int13_handler
-	.word	edd30_for_cdrom_install_check - int13_handler
-	.word	edd30_for_cdrom_ext_read - int13_handler
-	.word	edd30_for_cdrom_ext_write - int13_handler
-	.word	edd30_for_cdrom_success_out - int13_handler		# 0x44 verify sectors -- tinybit 2007-11-15
-//#;	.word	edd30_for_cdrom_success_out - int13_handler		# 0x45 lock / unlock
-//#;	.word	edd30_for_cdrom_success_out - int13_handler		# 0x46 eject
-	.word	edd30_for_cdrom_success_out - int13_handler		# 0x47 extended seek
-	.word	edd30_for_cdrom_get_drv_param - int13_handler		# 0x48 
-//#;	.word	edd30_for_cdrom_success_out - int13_handler		# 0x49 check media change
-//#;	.word	edd30_for_cdrom_return_boot_catalog - int13_handler	# 0x4D
-//#;	.word	edd30_for_cdrom_init_disk_emu - int13_handler		# 0x4A
-//#;	.word	edd30_for_cdrom_init_disk_emu_and_boot - int13_handler	# 0x4C
-//#;	.word	edd30_for_cdrom_success_out - int13_handler		# 0x4E set hardware configuration
-	.word	edd30_for_cdrom_stop_disk_emu - int13_handler		# 0x4B stop disk emu
-
 int13_last_stat:	.byte	0			#; the error code in AH
 
-//drive_map:		.word	0, 0, 0
-
-//emu_buf_off:		.word	0
-//emu_buf_seg:		.word	0
-//emu_cdrom_id:		.byte	0
-//emu_disk_type:		.byte	0	#;1=360 2=1.2 3=720 4=1.44 6=2.88 10h=atapi
-//emu_cyl:		.word	0
-//emu_sec:		.word	0
-//emu_head:		.word	0
-//emu_last_read:		.long	0
-
-//	.bss
 start_of_atapi_data:
 
 atapi_cur_dev:		.word	0	#; device serial number
@@ -6777,20 +6337,15 @@
 
 end_of_atapi_data:
 
-
-
-//edd30_cdemu_spec:	.space	19	# SIZE_OF_CDEMU_SPEC
-//atapi_dpte_buffer:	.space	16	# SIZE_OF_DPTE
-
 			.align	16
 
 edd30_disk_buffer:	.space	0x800
 
-//cmd_select_dev:	.byte	0xA0, 0xB0	#; CB_DH_DEV0, CB_DH_DEV1
-
 ENTRY(slow_atapi_device)
 			.long	0
 
+#;============================================================================
+
 /* void realmode_printf(const char *format, ...)
  *
  * input:	format is offset in CS segment
@@ -6889,14 +6444,8 @@
 	popaw
 	ret
 
-//int13_handler_code_end:
+#;============================================================================
 
-//#if 0
-//	.align	4
-//#else
-//	.space	(8 - ((int13_handler_code_end - int13_handler) % 8)) % 8
-//#endif
-
 	.align	16
 
 GDT_data:		/* used by int15/ah=87h */
@@ -6993,12 +6542,14 @@
 
 /* Don't insert code or data here! Buggy BIOSes could overwrite this area! */
 
+//	.align	16
+
+//	.space	0x1000	/* 4KB stack */
+
 int13_handler_end:
 	
-//	/* confirm the handler routine does not exceed the 0x1000(4KB) size */
-//	. = . - (int13_handler_end - int13_handler) / 0x1001
+#;============================================================================
 
-
 #define CDROM_INIT
 #ifdef CDROM_INIT
 
@@ -7187,11 +6738,11 @@
 	movw	$64, %cx		#; overwrite ATAPIs with CDROMs
 	repz movsb
 
-	movw	%bx, atapi_dev_count - int13_handler
-	movw	min_cdrom_id - int13_handler, %cx
-	addw	%bx, %cx
+	movb	%bl, atapi_dev_count - int13_handler
+	movb	min_cdrom_id - int13_handler, %cl
+	addb	%bl, %cl
 	decw	%cx
-	movw	%cx, max_cdrom_id - int13_handler
+	movb	%cl, max_cdrom_id - int13_handler
 	movw	%bx, %cx
 #endif
 
@@ -7219,7 +6770,7 @@
 	pushw	%si
 	pushw	%di
 	cld
-	movw	$0, atapi_dev_count - int13_handler		# reset counter
+	movb	$0, atapi_dev_count - int13_handler		# reset counter
 	movw	$reg_base_addr - int13_handler, %bx		# BX points to base address array
 	movw	$atapi_dev_base - int13_handler, %di		# will store base pointers and device numbers
 1:
@@ -7310,7 +6861,7 @@
 	jne	3f			# no, ignore it.
 
 	#; It is ATAPI, so add it to the list at atapi_dev_base
-	incw	atapi_dev_count - int13_handler	# count it
+	incb	atapi_dev_count - int13_handler	# count it
 	movw	%bx, %ax		# store the pointer to the base reg pair
 	stosw
 	movw	%si, %ax		# store the device number(master/slave)
@@ -7334,12 +6885,12 @@
 	cmpw	$0, (%bx)		# end?
 	jnz	1b			# no, probe next reg group
 
-	movw	atapi_dev_count - int13_handler, %cx
+	movzbw	atapi_dev_count - int13_handler, %cx
 	movw	%cx, %bx
 	decw	%bx
-	movw	min_cdrom_id - int13_handler, %ax
-	addw	%bx, %ax
-	movw	%ax, max_cdrom_id - int13_handler
+	movb	min_cdrom_id - int13_handler, %al
+	addb	%bl, %al
+	movb	%al, max_cdrom_id - int13_handler
 	popw	%di
 	popw	%si
 	popw	%bx
@@ -7515,6 +7066,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 #ifdef ABSOLUTE_WITHOUT_ASTERISK
 	DATA32	ADDR32	ljmp	(offset)
@@ -7565,6 +7117,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movl	%ecx, %ebp
 
@@ -7613,6 +7166,7 @@
 
 	/* turn on protected mode */
 	movl	%cr0, %eax
+	andl	$0x0000FFFF, %eax
 	orl	$CR0_PE_ON, %eax
 	movl	%eax, %cr0
 
@@ -7687,7 +7241,8 @@
 
 	/* clear the PE bit of CR0 */
 	movl	%cr0, %eax
-	andl 	$CR0_PE_OFF, %eax
+	//andl 	$CR0_PE_OFF, %eax
+	andl 	$0x0000FFFE, %eax
 	movl	%eax, %cr0
 
 	/* flush prefetch queue, reload %cs */
@@ -8175,7 +7730,7 @@
 
 	movw	$63, %cx	/* cylinder=0, sector=Max possible */
 1:
-	movw	$SCRATCHSEG, %ax
+	movw	$0x57E0, %ax	/* Don't use SCRATCHSEG */
 	movw	%ax, %es
 	movw	%ax, %ds
 	xorw	%bx, %bx
@@ -8271,7 +7826,7 @@
 
 	movb	$0xFF, %dh	/* head=Max possible */
 1:
-	movw	$SCRATCHSEG, %ax
+	movw	$0x57E0, %ax	/* Don't use SCRATCHSEG */
 	movw	%ax, %es
 	movw	%ax, %ds
 	xorw	%bx, %bx
@@ -8581,114 +8136,8 @@
 
 	.code32
 
-#if 0		
-/*
- *   int get_diskinfo_floppy (int drive, unsigned long *cylinders, 
- *                            unsigned long *heads, unsigned long *sectors)
- *
- *   Return the geometry of DRIVE in CYLINDERS, HEADS and SECTORS. If an
- *   error occurs, then return non-zero, otherwise zero.
- */
 
-ENTRY(get_diskinfo_floppy)
-	pushl	%ebp
-	movl	%esp, %ebp
-
-	pushl	%ebx
-	pushl	%esi
-
-	/* drive */
-	movb	0x8(%ebp), %dl
-	/* enter real mode */
-	call	EXT_C(prot_to_real)
-
-	.code16
-
-	//sti		/* it is not bad keeping interrupt off */
-	sti	#; added 2006-11-30
-
-	/* init probe value */
-	movl	$probe_values-1, %esi
-1:
-	xorw	%ax, %ax
-#if defined(STAGE1_5) || 1
-	int	$0x13
-#else
-	call	safe_int13
-#endif
-
-	incw	%si
-	movb	(%si), %cl
-	cmpb	$0, %cl		/* probe failed if zero */
-	je	2f
-
-	/* perform read */
-	movw	$SCRATCHSEG, %ax
-	movw	%ax, %es
-	xorw	%bx, %bx
-	movw	$0x0201, %ax
-	movb	$0, %ch
-	movb	$0, %dh
-#if defined(STAGE1_5) || 1
-	int	$0x13
-#else
-	call	safe_int13
-#endif
-
-	/* FIXME: Read from floppy may fail even if the geometry is correct.
-	   So should retry at least three times.  */
-	jc	1b		/* next value */
-	
-	/* succeed */
-	jmp	2f
-	
-probe_values:
-	.byte	36, 18, 15, 9, 0
-	
-2:
-	/* back to protected mode */
-	DATA32	call	EXT_C(real_to_prot)
-	.code32
-
-	/* restore %ebp */
-	leal	0x8(%esp), %ebp
-	
-	/* cylinders */
-	movl	0xc(%ebp), %eax
-	movl	$80, %ebx
-	movl	%ebx, (%eax)
-	/* heads */
-	movl	0x10(%ebp), %eax
-	movl	$2, %ebx
-	movl	%ebx, (%eax)
-	/* sectors */
-	movl	0x14(%ebp), %eax
-	movzbl	%cl, %ebx
-	movl	%ebx, (%eax)
-
-	/* return value in %eax */
-	xorl	%eax, %eax
-	cmpb	$0, %cl
-	jne	3f
-	incl	%eax		/* %eax = 1 (non-zero) */
-3:
-	popl	%esi
-	popl	%ebx
-	popl	%ebp
-
-	ret
-#endif
-	
-
-/* Source files are splitted, as they have different copyrights.  */
 #ifndef STAGE1_5
-//# include "setjmp.S"
-//# include "apm.S"
-#endif /* ! STAGE1_5 */
-		
-	
-
-#ifndef STAGE1_5
 /* get_code_end() :  return the address of the end of the code
  * This is here so that it can be replaced by asmstub.c.
  */
@@ -8726,6 +8175,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	cmpb	$0x1, %bl
 	//DATA32	je	xext
@@ -8782,6 +8232,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movw	$0xe801, %ax
 	//int	$0x15
@@ -8862,6 +8313,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movw	%si, %es
 
@@ -8943,6 +8395,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movb	$0xc0, %ah
 	int	$0x15
@@ -9005,6 +8458,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movw	%bx, %es
 
@@ -9061,6 +8515,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movw	%bx, %es
 	movw	$0x4F01, %ax
@@ -9100,6 +8555,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movw	$0x4F02, %ax
 	int	$0x10
@@ -9145,6 +8601,7 @@
 	call	prot_to_real
 
 	.code16
+	sti		/* for hardware interrupt or watchdog */
 	movw	$0x2400, %ax
 	testb	%dl, %dl
 	jz	1f
@@ -9338,11 +8795,13 @@
 	
 	.code16
 
-	cli	/* yes, keep interrupt off when controlling A20 */
+	sti		/* for hardware interrupt or watchdog */
 
 	movw	$0x00ff, %cx		# try so many times on failure
 	movb	$0x01, %dh		# with a20 debug on
+	cli	/* yes, keep interrupt off when controlling A20 */
 	call	enable_disable_a20
+	sti		/* for hardware interrupt or watchdog */
 	sete	%dl			# DL=1 means success
 
 #if 0	/* comment out to avoid hanging ONDA C51G board. */
@@ -9508,6 +8967,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movb	%dl, %al
 	xorb	%bh, %bh
@@ -9762,6 +9222,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
         xorb	%bh, %bh                /* set page to 0 */
 	movb	$0x3, %ah
@@ -9800,6 +9261,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
         xorb	%bh, %bh                /* set page to 0 */
 	movb	$0x2, %ah
@@ -9833,6 +9295,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	/* move the cursor to the beginning */
 	movb	$0x02, %ah
@@ -9885,6 +9348,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movb	$0x03, %ah
 	xorb	%bh, %bh
@@ -9907,6 +9371,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movb    $0x1, %ah
 	int     $0x10 
@@ -9924,13 +9389,13 @@
 /* graphics mode functions */
 #ifdef SUPPORT_GRAPHICS
 VARIABLE(cursorX)
-.word	0
+	.word	0
 VARIABLE(cursorY)
-.word	0
+	.word	0
 VARIABLE(cursorCount)
-.word 0
+	.word	0
 VARIABLE(cursorBuf)
-.byte	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+	.byte	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 
 	
 /*
@@ -9952,6 +9417,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	xorw	%bx, %bx
 	movb	$0xf, %ah
@@ -9989,6 +9455,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movw	$0x1130, %ax
 	movb	$6, %bh		/* font 8x16 */
@@ -10063,6 +9530,7 @@
 	.code16
 
 	//sti		/* it is not bad keeping interrupt off */
+	sti		/* for hardware interrupt or watchdog */
 
 	movb	%bl, %bh
 	movw	$0x1000, %ax
@@ -10161,6 +9629,7 @@
 
 	.code16
 
+	sti		/* for hardware interrupt or watchdog */
 	movb	$2, %ah
 	clc
 	int	$0x1a
@@ -10431,7 +9900,8 @@
 
 	/* clear the PE bit of CR0 */
 	movl	%cr0, %eax
-	andl	$CR0_PE_OFF, %eax
+	//andl	$CR0_PE_OFF, %eax
+	andl 	$0x0000FFFE, %eax
 	movl	%eax, %cr0
 
 	/* setup DS, ES, SS, FS and GS before loading CS */
Index: stage2/boot.c
===================================================================
--- stage2/boot.c	(revision 60)
+++ stage2/boot.c	(working copy)
@@ -20,6 +20,7 @@
 
 
 #include "shared.h"
+#include <term.h>
 
 #include "freebsd.h"
 #include "imgact_aout.h"
@@ -95,6 +96,15 @@
 	}
     }
 
+  /* leave graphics mode now before the extended memory is overwritten. */
+#ifdef SUPPORT_GRAPHICS
+  if (graphics_inited)
+  {
+    graphics_end ();
+    current_term = term_table; /* assumption: console is first */
+  }
+#endif
+
   /* Use BUFFER as a linux kernel header, if the image is Linux zImage
      or bzImage.  */
   lh = (struct linux_kernel_header *) buffer;
Index: stage2/grldrstart.S
===================================================================
--- stage2/grldrstart.S	(revision 60)
+++ stage2/grldrstart.S	(working copy)
@@ -331,15 +331,39 @@
 	cld
 	repz movsw		/* SI=DI=0x1be, CX=0 */
 
-	movw	$(grldr_signature - _start1), %bx
+	/********************************************************************/
+	/*  At this moment we are still not sure whether the helper is ok.  */
+	/********************************************************************/
 
+disk_serial_number_structure:
+
+#if (defined(GRLDR_MBR)) || (defined(GRLDR_INSTALL))
+
+	/********************************************************************/
+	/* This piece of code is structured! It contains address 0x1FFC and */
+	/* a disk serial number that can be created by grub4dos installer.  */
+	/********************************************************************/
+
+	movw	$0x1FFC, %bx		/* .byte 0xBB, 0xFC, 0x1F */
+
 	/* if the boot loader has loaded more than one sector, we use them */
+	movl	$0x93cb4d05, %eax	/* date-time for disk serial number */
+
+		/* "MOV EAX"(0x66, 0xB8) followed by the changeable S.N. */
+#else
+	movw	$(grldr_signature - _start1), %bx	/* BX=0x1FFC */
+
+	/* if the boot loader has loaded more than one sector, we use them */
 	movl	$0xAA555247, %eax	/* "GR" 0x55 0xAA */
+#endif
+
+disk_serial_number_structure_end:
+
 //#if (! defined(GRLDR_MBR)) && (! defined(GRLDR_INSTALL))
-	cmpl	%eax, (%bx)		/* DS=old segment! */
+	cmpl	%eax, (%bx)		/* DS=old segment of 07C0:0000 */
 	jne	1f
 
-	/* The MOVE_HELPER code is in the old segment! */
+	/* The MOVE_HELPER code is in the old segment of 07C0:0000 */
 
 	call	move_helper	/* SI=0x1be, CX=0 */
 1:
@@ -402,20 +426,9 @@
 	movw	$0x200, %bx	/* ES:BX immediately follow this sector */
 	movw	$2, %cx		/* skip the first sector already loaded */
 
-	pushaw
-//	int	$0x13
-	call	int13
-	popaw
-
+	call	read_disk_with_reset_and_dec_di
 	jnc	3f
 
-	pushaw
-	xorw	%ax, %ax
-//	int	$0x13
-	call	int13
-	popaw
-
-	decw	%di
 	jnz	2b
 3:
 	popal
@@ -423,11 +436,19 @@
 
 	jne	Error_or_prev_MBR	/* Missing helper */
 
+	/* Helper is loaded from floppy, so we set floppy as preferred. */
+	//movw	$0xff00, 0x06
+	//movw	%cx, 0x06	/* CX=0 */
+	call	set_floppy_preferred
 1:
 #endif
 
 	popfw			/* CF=1 on error */
 	jc	try_floppy	/* harddisk (hd0) failed, try floppy (fd0) */
+
+	/*********************************/
+	/* Helper is successfully loaded */
+	/*********************************/
 1:
 	pushw	%cs
 	popw	%ds
@@ -449,8 +470,9 @@
 	movb	$2, %ah
 	pushw	$FS_BOOT
 	popw	%es		/* ES=FS_BOOT */
-	xorw	%bx, %bx
+	xorw	%bx, %bx	/* read partition boot track to FS_BOOT:0000 */
 
+#if (! defined(GRLDR_MBR)) && (! defined(GRLDR_INSTALL))
 	pushaw
 //	int	$0x13		/* read partition boot track to FS_BOOT:0000 */
 	call	int13
@@ -463,8 +485,12 @@
 //	int	$0x13
 	call	int13
 	popaw
+	decw	%di
+#else
+	call	read_disk_with_reset_and_dec_di
+	jnc	helper_call
+#endif
 
-	decw	%di
 	jnz	2b
 
 helper_call_c:
@@ -647,6 +673,26 @@
 	popw	%ds
 	jmp	add_sub_si
 
+#if (defined(GRLDR_MBR)) || (defined(GRLDR_INSTALL))
+read_disk_with_reset_and_dec_di:
+	pushaw
+//	int	$0x13
+	call	int13
+	popaw
+
+	jnc	3f
+
+	pushaw
+	xorw	%ax, %ax
+//	int	$0x13
+	call	int13
+	popaw
+	decw	%di
+	stc
+3:
+	ret
+#endif
+
 	/* prints string CS:SI (modifies AX BX SI) */
 3:
 	//xorw	%bx, %bx	/* video page 0 */
@@ -1212,29 +1258,25 @@
 	movw	$0x0003, %ax	/* set display mode: 80*25 color text */
 	int	$0x10
 
-	xorw	%bx, %bx
-	movw	$(launch_pre_stage2 - _start1), %si
-	call	print_message	/* CS:SI points to message string */
+	//xorw	%bx, %bx
+	//movw	$(launch_pre_stage2 - _start1), %si
+	//call	print_message	/* CS:SI points to message string */
 
-	xorw	%ax, %ax
-	movw	%ax, %ss
-	movw	$0x2000, %sp
+	//xorw	%ax, %ax
+	//movw	%ax, %ss
+	//movw	$0x2000, %sp
 
-	sti
+	//sti
 
 	ljmp	$0, $0x8200
 
-launch_pre_stage2:
-	.ascii	"\r\n\r\nBooting GRLDR...\r\n"
+//launch_pre_stage2:
+//	.ascii	"\r\nBooting GRLDR...\r\n"
 
-	.byte	0		/* mark the end of ascii zero string */
+//	.byte	0		/* mark the end of ascii zero string */
 
 default_config_file:
-//#ifndef PRESET_MENU_STRING
 	.ascii	"/menu.lst"
-//#else
-//	.ascii	"[default menu is disabled]"
-//#endif
 
 	.byte	0		/* mark the end of ascii zero string */
 #endif	/* ! defined(GRLDR_MBR) && (! defined(GRLDR_INSTALL)) */
@@ -2236,7 +2278,9 @@
 
 	movb	$0x41, %ah
 	movw	$0x55AA, %bx
+	pushw	%dx
 	int	$0x13
+	popw	%dx
 	pushw	%ss		/* SS=0 */
 	popw	%ds		/* DS=0 */
 
@@ -2245,6 +2289,8 @@
 	jne	1f		/* No EBIOS */
 	testb	$1, %cl
 	jz	1f		/* No EBIOS */
+	testb	%dl, %dl	/* floppy? */
+	jns	1f		/* yes, only use CHS for FAT12/16 on floppy. */
 	/* EBIOS supported */
 	movb	$0x42, (ebios_12_16 - 1 - Entry_12_16 + 0x7c00)
 1:
@@ -5350,36 +5396,44 @@
 	/* before we call the routine, we will check if the user want to
 	 * skip this step and continue to find the GRLDR
 	 */
-#if 0
-	movw	$(press_space_bar_string - _start1), %si
-	cmpw	$0x3920, %cs:0x04
-	je	1f
-	movw	$(press_hot_key_string - _start1), %si
-1:
-
-	cmpb	$0, %cs:0x03
-	je	1f
-	call	print_message	/* CS:SI points to message string */
-	movw	$(press_any_key_string - _start1), %si
-	call	print_message	/* CS:SI points to message string */
-#else
 	/* if timeout==0, don't display the message */
   	cmpb    $0, %cs:0x03
   	je      1f
+	/* Press ... to start GRUB, any other key to boot previous MBR ... */
 	movw	$(press_hot_key_pre - _start1), %si
 	call	print_message
 	movw	$(press_hot_key_name - _start1), %si
 	call	print_message
 	movw	$(press_hot_key_sub - _start1), %si
 	call	print_message
-#endif
 1:
 	call	sleep_5_seconds
-	jc	1f		/* desired hot-key pressed */
+	jc	3f		/* desired hot-key pressed */
 	call	boot_prev_mbr	//Error_modify
+	jmp	3f
+2:
+	/* before we find GRLDR, give the user a chance to boot_prev_mbr. */
+	/* if timeout==0, don't display the message */
+  	cmpb    $0, %cs:0x03
+  	je      1f
+	/* Press ... to boot previous MBR, any other key to start GRUB ... */
+	movw	$(press_hot_key_pre - _start1), %si
+	call	print_message
+	movw	$(press_hot_key_name - _start1), %si
+	call	print_message
+	movw	$(press_hot_key_sub1 - _start1), %si
+	call	print_message
 1:
+	call	sleep_5_seconds
+	jnc	3f
+	/* desired hot-key pressed */
+	andb	$0x7F, %cs:0x02
+	call	boot_prev_mbr	//Error_modify
+3:
+	/* modify code at 2b to be "jmp 4f" */
+	movw	$(0xEB | ((4f - 2b - 2) << 8)), (2b - _start1)
 	orb	$0x80, %cs:0x02
-2:
+4:
 #endif
 	popfw
 	popal
@@ -5922,7 +5976,7 @@
 	jz	1f
 	movw	$0x0400, %bx		/* FAT32 */
 	movw	$0x0058, %cx		/* FAT32 */
-	movw	$(FAT32_message - _start1), %si
+	movw	$(FAT32_message - _start1), %si	/* SI changed!! */
 	jmp	7f
 8:
 	/* NTFS */
@@ -6047,6 +6101,7 @@
 
 2:
 	/* FAT12/FAT16 */
+	xorw	%si, %si
 	movb	0x10(%si), %al		/* number of FATs(NTFS:0, FAT:1,2) */
 	testb	%al, %al
 	jz	1f
@@ -6058,8 +6113,15 @@
 	ja	7f
 	movw	$(FAT12_message - _start1), %si
 7:
+	pushw	%bx
+	pushw	%cx
+	call	print_message	/* CS:SI points to message string */
+	popw	%cx
+	popw	%bx
+
 	/* fix for fat 12/16/32: sectors per track, offset 0x18 */
 	/* fix for fat 12/16/32: number of heads, offset 0x1a */
+	xorw	%si, %si
 	movw	%cs:0x08(%si), %ax	/* SI=0 */
 	cmpw	$0xFFFF, %ax
 	jz	3f
@@ -6079,7 +6141,6 @@
 3:
 	movl	%eax, 0x1c		/* adjust hidden_sectors for FAT */
 
-	call	print_message	/* CS:SI points to message string */
 	pushw	%cs
 	popw	%ds
 	/* DS=SS=0x9400 */
@@ -6382,43 +6443,32 @@
 	aam			/* AH=high decimal, AL=low decimal */
 	addw	$0x3030, %ax
 	xchgb	%al, %ah
-	movw	%ax, 9(%si)
+	movw	%ax, 32(%si)
 	call	print_message	/* CS:SI points to message string */
 3:
-	incw	%dx
+	incw	%dx		/* !!!! Next drive !!!! */
 	cmpb	%dh, %dl
 	jnb	2f		/* all drives checked, try floppy finally */
 
 	pushw	%bx
-//	pushw	%dx
-//	pushw	%es
 	movb	$8, %ah		/* read drive parameters changes DX,ES,DI,BX */
-//	int	$0x13
 	call	int13
-//	popw	%es
 	jc	3f		/* try next hard drive */
 	andb	$63, %cl	/* CL=sectors per track, CF cleared */
 	stc
 	jz	3f		/* try next hard drive */
-//	popw	%dx		/* get DL */
 	popw	%bx
 	movb	%dl, %ch	/* DL saved at BP high byte in the stack */
 	pushw	%cx		/* push new BX onto stack */
-//	pushw	%dx
 	movw	$0x201, %ax	/* read 1 sector */
 	movw	$0x7e00, %bx	/* read MBR to 9400:7e00 */
 	movw	$1, %cx
 	xorb	%dh, %dh
-//	stc
-//	int	$0x13
 	call	int13
 	sti
 3:
-//	popw	%dx
 	popw	%bx		/* BL=sectors per track, BH=DL */
 
-	//movw	%si, %bx	/* BL=sectors per track */
-
 	movw	$(Error_while_reading_string - _start1), %si
 	jc	2b		/* read failure, try next hard drive */
 
@@ -6774,8 +6824,11 @@
 	testb	$0x80, %cs:0x02		/* test bit 7 of the third byte */
 	jz	2f			/* zero means boot prev-MBR first */
 
+	/* Cannot find GRLDR. Press space bar to hold the screen, any other key to boot previous MBR ... */
 	movw	$(Cannot_find_GRLDR_string - _start1), %si
 	call	print_message	/* CS:SI points to message string */
+	movw	$(nt_boot_image - _start1), %si
+	call	print_message	/* CS:SI points to message string */
 	movw	$(press_space_bar_string - _start1), %si
 	movw	$0x3920, %cs:0x04	/* reset hot-key to space bar */
 	movb	$15, %cs:0x03		/* reset time out to 15 seconds */
@@ -6804,6 +6857,7 @@
 	testb	$0x80, %cs:0x02	/* are we called prior to the GRLDR search? */
 	jnz	1f		/* no, it is a failure at last */
 	/* yes, so return to the caller */
+	/* Invalid previous MBR. Press any key to start GRUB ... */
 	movw	$(continue_string - _start1), %si
 	call	print_message	/* CS:SI points to message string */
 	call	sleep_5_seconds
@@ -6811,6 +6865,10 @@
 1:
 	movw	$(message_string_helper - _start1), %si
 	call	print_message	/* CS:SI points to message string */
+	movw	$(nt_boot_image - _start1), %si
+	call	print_message	/* CS:SI points to message string */
+	movw	$(ctrl_alt_del_string - _start1), %si
+	call	print_message	/* CS:SI points to message string */
 1:	jmp	1b	/* hang */
 
 sleep_5_seconds:
@@ -7321,6 +7379,11 @@
 //#endif
 
 #if (defined(GRLDR_MBR)) || (defined(GRLDR_INSTALL))
+set_floppy_preferred:
+	movw	$0xff00, 0x06	/* preferred drive=0, partition=0xff */
+	andb	$0xFE, 0x02	/* bit0=0, enable GRLDR search on floppy */
+	ret
+
 filesystem_boot:
 	/* The partition boot record successfully modified, just boot it */
 
@@ -7416,23 +7479,146 @@
 	jns	1f			/* yes, continue to tune. */
 
 	cmpw	$0x1c2, %si		/* first run on this hard drive? */
-	je	1f			/* yes, continue to tune. */
-	ret
+	jne	2f			/* no, avoid tuning again. */
 1:
 	movw	$0xffff, 0x08
 
 #if (defined(GRLDR_MBR)) || (defined(GRLDR_INSTALL))
 	cmpb	$0x42, 0x00	/* EBIOS present? */
-	jne	1f		/* no, continue the geometry tune */
-#endif
-	ret
-1:
+	je	2f		/* yes, skip the tune */
+
 	#; real geometry tune follows. if you wish to disable the tune,
 	#; just do a 'ret' here.
 	//ret		#; disable the tune
 
+	/* check if the code is loaded completely */
+
+	cmpl	$0xAA555247, (grldr_signature - _start1) /* "GR" 0x55 0xAA */
+	je	real_geometry_tune
+
+#endif
+2:
+	ret
+
+press_space_bar_string:
+	.ascii	"\r\nPress space bar\0"
+
+press_hot_key_pre:
+	.ascii "\r\nPress \0"
+
+press_hot_key_sub:
+	.ascii	" to start GRUB, any other key to boot previous MBR ...\0"
+press_hot_key_sub1:
+	.ascii	" to boot previous MBR, any other key to start GRUB ...\0"
+
+hot_key_timeout_pre:
+	.ascii "\r\nTimeout : \0"
+
+hot_key_timeout_num:
+	.ascii "   \b\b\b\0"
+
+continue_string:
+	.ascii	"\r\nInvalid previous MBR. Press any key to start GRUB ...\0"
+
+Cannot_find_GRLDR_string:
+	.ascii	"\r\nCannot find \0"
+
+prev_MBR_string:
+	.ascii	" to hold the screen, any other key to boot previous MBR ...\0"
+
+Error_while_reading_string:
+	.ascii	"\r\nError while reading MBR of \0"
+
+drive_number_string:
+	.ascii	" in partition table of drive (hd0 ) \0"
+
+partition_boot_indicator_string:
+	.ascii	"\r\nInvalid boot indicator\0"
+
+partition_sectors_per_track_string:
+	.ascii	"\r\nInvalid sectors_per_track\0"
+
+partition_start_sector_string:
+	.ascii	"\r\nInvalid start_sector\0"
+
+partition_end_sector_string:
+	.ascii	"\r\nInvalid end_sector\0"
+
+no_boot_signature_string:
+	.ascii	"\r\nNo boot signature\0"
+
+message_string_helper:
+	.ascii	"\r\nError: Cannot find \0"
+ctrl_alt_del_string:
+	.ascii	" in all drives. Press Ctrl+Alt+Del to restart.\0"
+
+partition_message:
+	.ascii	"\r\nTry (hd0,0 ) : \0"
+
+EXT2_message:
+	.ascii	"EXT2: \0"
+
+#if 0
+NTFS4_message:
+	.ascii	"NTFS4: \0"
+NTFS5p_message:
+	.ascii	"NTFS5p: \0"
+#endif
+
+NTFS5_message:
+	.ascii	"NTFS5: \0"
+FAT32_message:
+	.ascii	"FAT32: \0"
+FAT16_message:
+	.ascii	"FAT16: \0"
+FAT12_message:
+	.ascii	"FAT12: \0"
+non_MS_message:
+	.ascii	"non-MS: skip \0"
+extended_message:
+	.ascii	"Extended: \0"
+invalid_message:
+	.ascii	"invalid or null \0"
+
 #if (defined(GRLDR_MBR)) || (defined(GRLDR_INSTALL))
 
+	/* grldr.mbr is larger than 8K. */
+
+	######################################################################
+	# The installer should setup the long integer at offset 0x1FFC as
+	# the unique disk signature. The same signature value must be also
+	# placed into the disk_serial_number_structure in the first sector(the
+	# MBR sector). You can easily locate the structure through the pointer
+	# at offset 0x1FF8.
+	#
+	# For GRLDR.MBR the default disk serial number is the grldr.mbr
+	# signature(0x93cb4d05). You should change it according to the
+	# date-time value just at the time when you run the installer.
+	######################################################################
+
+	. = _start1 + 0x1FF8
+
+	/* point to disk serial number in the first sector, i.e., the MBR
+	 * sector. The program never access this pointer. It can be used by
+	 * an external program to easily locate the disk serial number at MBR.
+	 */
+
+	.word	disk_serial_number_structure - _start1 + 5
+
+	. = _start1 + 0x1FFA
+
+	/* version of grldr.mbr. It has a copy at (grldr_signature - 2) */
+
+	.word   3
+
+	. = _start1 + 0x1FFC
+
+	.long	0x93cb4d05		/* date-time for disk serial number */
+
+	. = _start1 + 0x2000
+
+real_geometry_tune:
+
 //////////////////////////////////////////////////////////////////////////////
 
 	/* initialize passed-in values */
@@ -7458,6 +7644,18 @@
 1:
 	popaw
 
+	/* print BIOS geometry */
+
+	movzbw	%cs:(Sectors_passed_in - _start1), %cx
+	pushw	%cx
+	movzbw	%cs:(Heads_passed_in - _start1), %cx
+	pushw	%cx
+	movzbw	%dl, %cx
+	pushw	%cx
+	pushw	$(BIOS_geom_string - _start1)
+	call	realmode_printf
+	addw	$8, %sp
+
 //////////////////////////////////////////////////////////////////////////////
 
 	/* get maximum sector number */
@@ -7645,6 +7843,21 @@
 
 //////////////////////////////////////////////////////////////////////////////
 
+	/* print tuned geometry */
+
+	movzbw	%cs:(Smax_tuned - _start1), %cx
+	pushw	%cx
+	movzbw	%cs:(Hmax_tuned - _start1), %cx
+	incw	%cx
+	pushw	%cx
+	movzbw	%dl, %cx
+	pushw	%cx
+	pushw	$(TUNE_geom_string - _start1)
+	call	realmode_printf
+	addw	$8, %sp
+
+	/* return with success */
+
 	movw	%cs:(Smax_tuned - _start1), %cx
 	movb	%cs:(Hmax_tuned - _start1), %dh
 	movb	%cl, %cs:0x08	/* Smax */
@@ -7823,8 +8036,114 @@
 	stc			/* Flag: below */
 	ret
 
+#;============================================================================
+
+/* void realmode_printf(const char *format, ...)
+ *
+ * input:	format is offset in CS segment
+ * 
+ * Usage example:
+ * 
+ * 		pushw	IntegerN
+ *		 ... ... ... ...
+ * 		pushw	Integer2
+ * 		pushw	Integer1
+ * 		pushw	$format_string - _start1
+ *		call	realmode_printf
+ * 		addw	$(2*(N+1)), %sp
+ * 
+ * where int13_handle should be the base of the CS segment,
+ * and format_string like this:
+ *
+ * format_string:
+ *		 .string "Int1=%x, Int2=%x, ..., IntN=%x\r\n"
+ *
+ * Currently only %d, %x and %X are implemented.
+ */
+
+realmode_printf:
+	pushaw
+	movw	%sp, %bp
+	# bp+18:	format
+	# bp+20:	variables
+	addw	$18, %bp
+	movw	(%bp), %si		# points to format string
+	addw	$2, %bp			# (%bp) is the first variable
+1:
+	cs lodsb
+	testb	%al, %al
+	jz	1f
+	cmpb	$'%', %al
+	jne	2f
+
+	#; %d, %x, %X
+
+	cs lodsb
+	testb	%al, %al
+	jz	1f
+	cmpb	$'d', %al
+	movw	$10, %bx		# base 10
+	jz	4f
+	cmpb	$'x', %al
+	jz	3f
+	cmpb	$'X', %al
+	jne	1b			# unkown directive, continue
+3:
+	/* print hexa number */
+	movw	$16, %bx		# base 16
+4:
+	/* print decimal or hexa number */
+	pushl	%edi
+
+	xorl	%edi, %edi
+	xorw	%cx, %cx		# count the digits
+	movw	(%bp), %ax
+5:
+	xorw	%dx, %dx
+	divw	%bx			# AX=quo, DX=rem
+	movw	%dx, %di
+	rorl	$4, %edi
+	incw	%cx
+	testw	%ax, %ax		# end?
+	jnz	5b
+
+	/* print the digits in EDI */
+	xorw	%bx, %bx	/* video page 0 */
+5:
+	roll	$4, %edi
+	movw	%di, %ax		# get digit in AL
+	andb	$0x0f, %al
+	cmpb	$9, %al
+	jbe	6f
+	addb	$7, %al			# A, B, C, D, E, F
+6:
+	addb	$0x30, %al
+	movb	$0x0e, %ah	/* print it */
+	int	$0x10		/* via TTY mode */
+	loop	5b
+
+	popl	%edi
+
+	addw	$2, %bp			# (%bp) is the next variable
+	jmp	1b			# continue
+2:
+	/* print char in AL */
+	xorw	%bx, %bx	/* video page 0 */
+	movb	$0x0e, %ah	/* print it */
+	int	$0x10		/* via TTY mode */
+	jmp	1b			# continue
+1:
+	popaw
+	ret
+
+#;============================================================================
 //////////////////////////////////////////////////////////////////////////////
 
+BIOS_geom_string:
+	.string	"\r\nBIOS: Drive=0x%X, H=%d, S=%d\r\n"
+TUNE_geom_string:
+	.string	"TUNE: Drive=0x%X, H=%d, S=%d\r\n"
+
 	.align	4
 
 Sectors_passed_in:
@@ -7842,82 +8161,31 @@
 
 //////////////////////////////////////////////////////////////////////////////
 
-#endif
+#endif	/* end of real_geometry_tune */
 
-press_space_bar_string:
-	.ascii	"\r\nPress space bar\0"
+#if (! defined(GRLDR_MBR)) && (! defined(GRLDR_INSTALL))
+	######################################################################
+	# External modifiers may setup a long integer at offset 0x1FFC as the
+	# unique disk signature. The same signature value must be also placed
+	# into the disk_serial_number_structure in the first sector(the MBR
+	# sector). You can easily locate the structure through the pointer at
+	# offset 0x1FF8.
+	#
+	# For GRLDR the default disk serial number is the grldr signature
+	# ("GR" 0x55 0xAA). Generally you needn't change it, though you are
+	# allowed to change it through an external modifier.
+	######################################################################
 
-press_hot_key_pre:
-	.ascii "\r\nPress \0"
+	. = _start1 + 0x1FF8
 
-press_hot_key_sub:
-	.ascii	" to start GRUB, any other key to boot previous MBR ...\0"
+	/* point to disk serial number in the first sector, i.e., the MBR
+	 * sector. The program never access this pointer. It can be used by
+	 * an external program to easily locate the disk serial number at MBR.
+	 */
 
-hot_key_timeout_pre:
-	.ascii "\r\nTimeout : \0"
+	.word	disk_serial_number_structure - _start1 + 5
 
-hot_key_timeout_num:
-	.ascii "   \b\b\b\0"
-
-continue_string:
-	.ascii	"\r\nInvalid previous MBR. Press any key to start GRUB ...\0"
-
-Cannot_find_GRLDR_string:
-	.ascii	"\r\nCannot find GRLDR.\0"
-
-prev_MBR_string:
-	.ascii	" to hold the screen, any other key to boot previous MBR ...\0"
-
-Error_while_reading_string:
-	.ascii	"\r\nError while reading MBR of \0"
-
-drive_number_string:
-	.ascii	"drive (hd0 ) \0"
-
-partition_boot_indicator_string:
-	.ascii	"\r\nInvalid boot indicator in partition table of \0"
-
-partition_sectors_per_track_string:
-	.ascii	"\r\nInvalid sectors_per_track in partition table of \0"
-
-partition_start_sector_string:
-	.ascii	"\r\nInvalid start_sector in partition table of \0"
-
-partition_end_sector_string:
-	.ascii	"\r\nInvalid end_sector in partition table of \0"
-
-no_boot_signature_string:
-	.ascii	"\r\nNo boot signature in partition table of \0"
-
-message_string_helper:
-	.ascii	"\r\nError: Cannot find GRLDR in all devices. Press Ctrl+Alt+Del to restart.\0"
-
-partition_message:
-	.ascii	"\r\nTry (hd0,0 ) : \0"
-
-EXT2_message:
-	.ascii	"EXT2: \0"
-NTFS4_message:
-	.ascii	"NTFS4: \0"
-NTFS5_message:
-	.ascii	"NTFS5: \0"
-NTFS5p_message:
-	.ascii	"NTFS5p: \0"
-FAT32_message:
-	.ascii	"FAT32: \0"
-FAT16_message:
-	.ascii	"FAT16: \0"
-FAT12_message:
-	.ascii	"FAT12: \0"
-non_MS_message:
-	.ascii	"non-MS: skip \0"
-extended_message:
-	.ascii	"Extended: \0"
-invalid_message:
-	.ascii	"invalid or null \0"
-
-#if (! defined(GRLDR_MBR)) && (! defined(GRLDR_INSTALL))
-	. = _start1 + 0x1ffa
+	. = _start1 + 0x1FFA
 #else
 	. = . + (0x3ec - ((. - _start1) % 0x200)) % 0x200
 
@@ -7934,7 +8202,7 @@
 
 	/* version word of grldr.mbr, the address is (grldr_signature - 2) */
 
-	.word   2
+	.word   3
 
 grldr_signature:
 	.byte	0x47, 0x52, 0x55, 0xaa	/* signature for helper */
Index: stage2/a20.inc
===================================================================
--- stage2/a20.inc	(revision 60)
+++ stage2/a20.inc	(working copy)
@@ -54,6 +54,12 @@
 #define A20_KBC		6		/* A20 through KBC */
 #define A20_FAST	8		/* A20 through port 92h */
 
+	/* Align Dword here so that other alignments below could work
+	 * as expected.
+	 */
+
+	.align	4
+
 enable_disable_a20:
 
 	###################################################################
@@ -86,36 +92,42 @@
 base_addr:
 	popw	%bp
 	ret
+
 1:
 	/********************************************/
 	/**  Now we have to enable or disable A20  **/
 	/********************************************/
 
-	pushal			# save all
+	pushl	%ebp
+	call	assign_base_pointer	/* BP points to base_addr */
+	/* save original EBP */
+	popl	%cs:(A20_old_ebp - base_addr)(%bp)
 
+	/* save original return address */
+	popw	%cs:(A20ReturnAddress - base_addr)(%bp)
+
+	movl	%eax, %cs:(A20_old_eax - base_addr)(%bp)
+	movl	%ebx, %cs:(A20_old_ebx - base_addr)(%bp)
+	movl	%ecx, %cs:(A20_old_ecx - base_addr)(%bp)
+	movl	%edx, %cs:(A20_old_edx - base_addr)(%bp)
+	movl	%esi, %cs:(A20_old_esi - base_addr)(%bp)
+	movl	%edi, %cs:(A20_old_edi - base_addr)(%bp)
+	
+//	pushal			# save all
+
 	movw	$200, %cx
 	testb	%dl, %dl
 	jnz	1f
 	movw	$20, %cx
 1:
-	call	assign_base_pointer	/* BP points to base_addr */
 
 	# Times to try to make this work
 	movw	%cx, %cs:(A20Tries - base_addr)(%bp)
 
-	/* save DX */
-	movw	%dx, %cs:(A20Config - base_addr)(%bp)
-
 	/* save original IF, DF */
 	pushfw
 	popw	%cs:(A20Flags - base_addr)(%bp)
 
-	/* save original return address */
-	movw	%sp, %bp
-	pushw	32(%bp)
-	call	assign_base_pointer	/* BP points to base_addr */
-	popw	%cs:(A20ReturnAddress - base_addr)(%bp)
-
 a20_try_again:
 
 	######################################################################
@@ -189,20 +201,6 @@
 	popw	%dx
 	popw	%bp
 
-	/* restore BP and DX in the safest way! */
-	call	assign_base_pointer	/* BP points to base_addr */
-	movw	%cs:(A20Config - base_addr)(%bp), %dx
-
-	/* restore original return address */
-	movw	%cs:(A20ReturnAddress - base_addr)(%bp), %ax
-	movw	%sp, %bp
-	movw	%ax, 32(%bp)		/* update the stack! */
-	call	assign_base_pointer	/* BP points to base_addr */
-
-	/* restore original IF, DF */
-	pushw	%cs:(A20Flags - base_addr)(%bp)
-	popfw
-
 	pushl	%ecx
 	movl	$0x2, %ecx
 	call	a20_test_match
@@ -336,7 +334,15 @@
 	call	a20_print_string
 1:
 	popfw
-	popal
+//	popal
+	movl	%cs:(A20_old_eax - base_addr)(%bp), %eax
+	movl	%cs:(A20_old_ebx - base_addr)(%bp), %ebx
+	movl	%cs:(A20_old_ecx - base_addr)(%bp), %ecx
+	movl	%cs:(A20_old_edx - base_addr)(%bp), %edx
+	movl	%cs:(A20_old_esi - base_addr)(%bp), %esi
+	movl	%cs:(A20_old_edi - base_addr)(%bp), %edi
+	pushw	%cs:(A20ReturnAddress - base_addr)(%bp)	  /* return address */
+	movl	%cs:(A20_old_ebp - base_addr)(%bp), %ebp  /* restore EBP */
 	ret
 
 
@@ -358,10 +364,12 @@
 a20_test_match:
 1:
 	call	a20_test
+	pushw	%ax
 	sete	%al		/* save ZF to AL */
 	testb	%dl, %dl
 	sete	%ah		/* save ZF to AH */
 	cmpb	%al, %ah
+	popw	%ax
 	ADDR32 loopnz	1b	/* dec ECX */
 	/* ZF=1(means equal) for match */
 	ret
@@ -372,13 +380,35 @@
 	######################################################################
 
 a20_test:
-	pushl	%eax
-	pushw	%cx
-	pushw	%ds
-	pushw	%es
-	pushw	%si
-	pushw	%di
 
+	/******************************************************************/
+	/* Don't call a20_debug_print! The A20_tmp_ variables are shared! */
+	/******************************************************************/
+
+	pushl	%ebp
+	call	assign_base_pointer	/* BP points to base_addr */
+	/* save original EBP */
+	popl	%cs:(A20_tmp_ebp - base_addr)(%bp)
+
+	/* save a20_test return address */
+	popw	%cs:(A20_tmp_ReturnAddress - base_addr)(%bp)
+
+	movl	%eax, %cs:(A20_tmp_eax - base_addr)(%bp)
+	movl	%ebx, %cs:(A20_tmp_ebx - base_addr)(%bp)
+	movl	%ecx, %cs:(A20_tmp_ecx - base_addr)(%bp)
+	movl	%edx, %cs:(A20_tmp_edx - base_addr)(%bp)
+	movl	%esi, %cs:(A20_tmp_esi - base_addr)(%bp)
+	movl	%edi, %cs:(A20_tmp_edi - base_addr)(%bp)
+	movw	%ds, %cs:(A20_tmp_ds - base_addr)(%bp)
+	movw	%es, %cs:(A20_tmp_es - base_addr)(%bp)
+	
+	//pushl	%eax
+	//pushw	%cx
+	//pushw	%ds
+	//pushw	%es
+	//pushw	%si
+	//pushw	%di
+
 	pushfw				/* save old IF, DF */
 
 #if DISABLE_CPU_CACHE
@@ -441,12 +471,23 @@
 	popfw			/* restore IF, DF */
 	sahf			/* update ZF */
 
-	popw	%di
-	popw	%si
-	popw	%es
-	popw	%ds
-	popw	%cx
-	popl	%eax
+	//popw	%di
+	//popw	%si
+	//popw	%es
+	//popw	%ds
+	//popw	%cx
+	//popl	%eax
+	call	assign_base_pointer	/* BP points to base_addr */
+	movl	%cs:(A20_tmp_eax - base_addr)(%bp), %eax
+	movl	%cs:(A20_tmp_ebx - base_addr)(%bp), %ebx
+	movl	%cs:(A20_tmp_ecx - base_addr)(%bp), %ecx
+	movl	%cs:(A20_tmp_edx - base_addr)(%bp), %edx
+	movl	%cs:(A20_tmp_esi - base_addr)(%bp), %esi
+	movl	%cs:(A20_tmp_edi - base_addr)(%bp), %edi
+	movw	%cs:(A20_tmp_ds - base_addr)(%bp), %ds
+	movw	%cs:(A20_tmp_es - base_addr)(%bp), %es
+	pushw	%cs:(A20_tmp_ReturnAddress - base_addr)(%bp)
+	movl	%cs:(A20_tmp_ebp - base_addr)(%bp), %ebp  /* restore EBP */
 	ret
 
 slow_out:
@@ -471,8 +512,18 @@
 	jnz	1f		/* yes, continue */
 	ret
 1:
-	pushal
+	//pushal
 	call	assign_base_pointer	/* BP points to base_addr */
+	movl	%eax, %cs:(A20_tmp_eax - base_addr)(%bp)
+	movl	%ebx, %cs:(A20_tmp_ebx - base_addr)(%bp)
+	movl	%ecx, %cs:(A20_tmp_ecx - base_addr)(%bp)
+	movl	%edx, %cs:(A20_tmp_edx - base_addr)(%bp)
+	movl	%esi, %cs:(A20_tmp_esi - base_addr)(%bp)
+	movl	%edi, %cs:(A20_tmp_edi - base_addr)(%bp)
+	movw	%ds, %cs:(A20_tmp_ds - base_addr)(%bp)
+	movw	%es, %cs:(A20_tmp_es - base_addr)(%bp)
+	movw	%fs, %cs:(A20_tmp_fs - base_addr)(%bp)
+	movw	%gs, %cs:(A20_tmp_gs - base_addr)(%bp)
 
 	movb	%cs:(A20Tries - base_addr)(%bp), %al		/* A20Tries */
 	call	a20_hex
@@ -484,7 +535,18 @@
 
 	leaw	(A20DbgMsgTry - base_addr)(%bp), %si	/* CS:SI is string */
 	call	a20_print_string
-	popal
+	call	assign_base_pointer	/* BP points to base_addr */
+	movl	%cs:(A20_tmp_eax - base_addr)(%bp), %eax
+	movl	%cs:(A20_tmp_ebx - base_addr)(%bp), %ebx
+	movl	%cs:(A20_tmp_ecx - base_addr)(%bp), %ecx
+	movl	%cs:(A20_tmp_edx - base_addr)(%bp), %edx
+	movl	%cs:(A20_tmp_esi - base_addr)(%bp), %esi
+	movl	%cs:(A20_tmp_edi - base_addr)(%bp), %edi
+	movw	%cs:(A20_tmp_ds - base_addr)(%bp), %ds
+	movw	%cs:(A20_tmp_es - base_addr)(%bp), %es
+	movw	%cs:(A20_tmp_fs - base_addr)(%bp), %fs
+	movw	%cs:(A20_tmp_gs - base_addr)(%bp), %gs
+	//popal
 	ret
 
 	/************************************************/
@@ -554,6 +616,20 @@
 	popl	%ecx
 	ret
 
+	/* a20 debug message. 25 backspaces to wipe out the previous
+	 * "A20 Debug: XXXX trying..." message.
+	 */
+A20DbgMsgTry:
+	.ascii	"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bA20 Debug: "
+A20DbgMsgTryHex:
+	.string	"XXXX trying..."		// null terminated
+
+	/* a20 done message. 9 backspaces to wipe out the previous
+	 * "trying..." message.
+	 */
+A20DbgMsgEnd:
+	.string	"\b\b\b\b\b\b\b\b\bdone! "	// null terminated
+
 	.align	2
 
 A20List:
@@ -568,24 +644,32 @@
 	.word	0		// Times until giving up on A20
 
 	/* Just in case INT 15 might have destroyed the stack... */
-A20Config:
-	.word	0		// save original DX here
 A20Flags:
 	.word	0		// save original Flags here
 A20ReturnAddress:
 	.word	0		// save original return address here
+A20_tmp_ReturnAddress:
+	.word	0		// save a20_test return address here
 
-	/* a20 debug message. 25 backspaces to wipe out the previous
-	 * "A20 Debug: XXXX trying..." message.
-	 */
-A20DbgMsgTry:
-	.ascii	"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bA20 Debug: "
-A20DbgMsgTryHex:
-	.string	"XXXX trying..."		// null terminated
+	.align	4
 
-	/* a20 done message. 9 backspaces to wipe out the previous
-	 * "trying..." message.
-	 */
-A20DbgMsgEnd:
-	.string	"\b\b\b\b\b\b\b\b\bdone! "	// null terminated
+A20_old_ebp:	.long	0
+A20_old_eax:	.long	0
+A20_old_ebx:	.long	0
+A20_old_ecx:	.long	0
+A20_old_edx:	.long	0
+A20_old_esi:	.long	0
+A20_old_edi:	.long	0
+A20_tmp_ebp:	.long	0
+A20_tmp_eax:	.long	0
+A20_tmp_ebx:	.long	0
+A20_tmp_ecx:	.long	0
+A20_tmp_edx:	.long	0
+A20_tmp_esi:	.long	0
+A20_tmp_edi:	.long	0
+A20_tmp_ds:	.word	0
+A20_tmp_es:	.word	0
+A20_tmp_fs:	.word	0
+A20_tmp_gs:	.word	0
 
+
Index: stage2/shared.h
===================================================================
--- stage2/shared.h	(revision 60)
+++ stage2/shared.h	(working copy)
@@ -78,6 +78,7 @@
 #define BIOSDISK_ERROR_GEOMETRY		0x100
 #define BIOSDISK_FLAG_LBA_EXTENSION	0x1
 #define BIOSDISK_FLAG_CDROM		0x2
+#define BIOSDISK_FLAG_BIFURCATE		0x4	/* accessibility acts differently between chs and lba */
 
 /*
  *  This is the filesystem (not raw device) buffer.
@@ -90,8 +91,13 @@
 /* Command-line buffer for Multiboot kernels and modules. This area
    includes the area into which Stage 1.5 and Stage 1 are loaded, but
    that's no problem.  */
+#ifndef STAGE1_5
+#define MB_CMDLINE_BUF		RAW_ADDR (0x7000)
+#define MB_CMDLINE_BUFLEN	0x1000
+#else
 #define MB_CMDLINE_BUF		RAW_ADDR (0x2000)
 #define MB_CMDLINE_BUFLEN	0x6000
+#endif
 
 /* The buffer for the password.  */
 #define PASSWORD_BUF		RAW_ADDR (0x78000)
@@ -105,12 +111,13 @@
 #define CMDLINE_BUF		(DEFAULT_FILE_BUF + DEFAULT_FILE_BUFLEN)
 #define CMDLINE_BUFLEN		MAX_CMDLINE
 
-/* The kill buffer for the command-line.  */
-#define KILL_BUF		(CMDLINE_BUF + CMDLINE_BUFLEN)
-#define KILL_BUFLEN		MAX_CMDLINE
+///* The kill buffer for the command-line.  */
+//#define KILL_BUF		(CMDLINE_BUF + CMDLINE_BUFLEN)
+//#define KILL_BUFLEN		MAX_CMDLINE
 
 /* The history buffer for the command-line.  */
-#define HISTORY_BUF		(KILL_BUF + KILL_BUFLEN)
+//#define HISTORY_BUF		(KILL_BUF + KILL_BUFLEN)
+#define HISTORY_BUF		(CMDLINE_BUF + CMDLINE_BUFLEN)
 #define HISTORY_SIZE		5
 #define HISTORY_BUFLEN		(MAX_CMDLINE * HISTORY_SIZE)
 
@@ -135,9 +142,6 @@
 /* The size of the key map.  */
 #define KEY_MAP_SIZE		128
 
-/* The size of the io map.  */
-#define IO_MAP_SIZE		128
-
 /*
  *  extended chainloader code address for switching to real mode
  */
@@ -265,7 +269,7 @@
 #define PROT_MODE_DSEG  0x10
 #define PSEUDO_RM_CSEG	0x18
 #define PSEUDO_RM_DSEG	0x20
-#define STACKOFF	(0x2000 - 0x10)
+#define STACKOFF	MB_CMDLINE_BUF	/* (0x2000 - 0x10) */
 #define PROTSTACKINIT   (FSYS_BUF - 0x10)
 
 
@@ -751,10 +755,10 @@
 extern unsigned long lba_cd_boot;	/* LBA of no-emulation boot image, in 2048-byte sectors */
 extern unsigned long safe_mbr_hook;	/* safe mbr hook flags used by Win9x */
 extern unsigned long int13_scheme;	/* controls disk access methods in emulation */
-extern unsigned long atapi_dev_count;	/* ATAPI CDROM DRIVE COUNT */
+extern unsigned char atapi_dev_count;	/* ATAPI CDROM DRIVE COUNT */
 extern unsigned long *reg_base_addr_append;
 extern unsigned long init_atapi(void);
-extern unsigned long min_cdrom_id;	/* MINIMUM ATAPI CDROM DRIVE NUMBER */
+extern unsigned char min_cdrom_id;	/* MINIMUM ATAPI CDROM DRIVE NUMBER */
 extern unsigned long cdrom_drive;
 //extern unsigned long cdrom_drives[];
 //#ifndef cdrom_drive
@@ -855,7 +859,6 @@
 /* The key map.  */
 extern unsigned short bios_key_map[];
 extern unsigned short ascii_key_map[];
-extern unsigned short io_map[];
 
 /* calls for direct boot-loader chaining */
 void chain_stage1 (unsigned long segment, unsigned long offset,
@@ -965,6 +968,7 @@
 #define BUILTIN_SCRIPT		0x8	/* Run in the script.  */
 #define BUILTIN_NO_ECHO		0x10	/* Don't print command on booting. */
 #define BUILTIN_HELP_LIST	0x20	/* Show help in listing.  */
+#define BUILTIN_BOOTING		0x40	/* The command is boot-sensitive.  */
 
 /* The table for a builtin.  */
 struct builtin
@@ -1005,13 +1009,10 @@
 #endif
 extern int grub_timeout;
 
-void init_builtins (void);
-void init_config (void);
 char *skip_to (int after_equal, char *cmdline);
 struct builtin *find_command (char *command);
 void print_cmdline_message (int forever);
 void enter_cmdline (char *heap, int forever);
-int run_script (char *script, char *heap);
 #endif
 
 /* C library replacement functions with identical semantics. */
Index: stage2/common.c
===================================================================
--- stage2/common.c	(revision 60)
+++ stage2/common.c	(working copy)
@@ -220,14 +220,36 @@
   DEBUG_SLEEP
   printf("\rTurning on gate A20...                          ");
 #if 1
-  if (gateA20 (1))			/* int15/24 -----safe enough */
-	/* wipe out the messages */
-	printf("\r                                                                \r");
-  else
     {
-	printf("Failure! Report bug, please!\n");
-	/* sleep a moment */
-	{unsigned long j; for (j = 0; j < 0x80000000; j++);}
+	unsigned long j;
+	int wait;
+	int time1;
+	int time2;
+
+	if (gateA20 (1))			/* int15/24 -----safe enough */
+	{
+		/* wipe out the messages on success */
+		printf("\r                                                                \r");
+		wait = 0;	/* sleep 0 second after A20 control */
+	} else {
+		printf("Failure! Report bug, please!\n");
+		wait = 5;	/* sleep 5 second on failure */
+	}
+
+	/* Get current time.  */
+	while ((time2 = getrtsecs ()) == 0xFF);
+
+	for (j = 0; j < 0x00800000; j++)
+	{
+	  if ((time1 = getrtsecs ()) != time2 && time1 != 0xFF)
+	    {
+	      if (wait == 0)
+		  break;
+	      
+	      time2 = time1;
+	      wait--;
+	    }
+	}
     }
 #else
   extern void grub2_gate_a20 (int on);
@@ -372,9 +394,6 @@
 		tmp_geom.cylinders, tmp_geom.heads, tmp_geom.sectors,
 		tmp_geom.total_sectors, tmp_geom.sector_size);
       
-//      /* Clean out the I/O map.  */
-//      grub_memset ((char *) io_map, 0, IO_MAP_SIZE * sizeof (unsigned short));
-
       /* Set the information.  */
       info->drive_number = drive;
       info->drive_mode = ((tmp_geom.flags & BIOSDISK_FLAG_LBA_EXTENSION)
@@ -384,8 +403,6 @@
       info->drive_sectors = tmp_geom.sectors;
 
       addr += sizeof (struct drive_info);
-//      for (port = io_map; *port; port++, addr += sizeof (unsigned short))
-//	*((unsigned short *) addr) = *port;
 
       info->size = addr - (unsigned long) info;
       mbi.drives_length += info->size;
@@ -523,7 +540,8 @@
 #ifndef GRUB_UTIL
 #ifndef STAGE1_5
   debug = 1;
-  min_cdrom_id = (cdrom_drive < 0xE0 && cdrom_drive >= 0xC0) ? 0xE0 : 0xC0;
+  if (! atapi_dev_count)
+    min_cdrom_id = (cdrom_drive < 0xE0 && cdrom_drive >= 0xC0) ? 0xE0 : 0xC0;
   
   /* if grub.exe is booted as a Linux kernel, check the initrd disk. */
 
@@ -564,5 +582,5 @@
 #if !defined(STAGE1_5) && !defined(GRUB_UTIL)
   DEBUG_SLEEP
 #endif /* ! STAGE1_5 && ! GRUB_UTIL */
-  cmain ();
+//  cmain ();	/* moved into asm.S and asmstub.c */
 }
Index: grub/asmstub.c
===================================================================
--- grub/asmstub.c	(revision 60)
+++ grub/asmstub.c	(working copy)
@@ -75,7 +75,6 @@
 unsigned long linux_text_len = 0;
 char *linux_data_tmp_addr = 0;
 char *linux_data_real_addr = 0;
-unsigned short io_map[IO_MAP_SIZE];
 struct apm_info apm_bios_info;
 
 /* Emulation requirements. */
@@ -129,6 +128,7 @@
 	  /* Actually enter the generic stage2 code.  */
 	  status = 0;
 	  init_bios_info ();
+	  cmain ();
 	}
       else
 	{
Index: ChangeLog_GRUB4DOS.txt
===================================================================
--- ChangeLog_GRUB4DOS.txt	(revision 60)
+++ ChangeLog_GRUB4DOS.txt	(working copy)
@@ -1,3 +1,33 @@
+2008-10-03 cancelled unnecessary initialisations for the root device.
+2008-10-02 improved int15 probing in probe_int.
+2008-10-01 before booting GRLDR, give the user a chance to boot previous mbr.
+2008-09-30 fixed a big bug in set_bootdev causing extra rawread executed and the geometry messed up.
+2008-09-29 fixed a big bug in get_diskinfo causing duplicate geometry calculation for each IO request on floppy.
+2008-09-27 fixed a new bug intrduced recently in get_diskinfo.
+2008-09-25 fixed an issue of uninitialised current_term in boot.c, causing the failure of the kernel command in graphics mode.
+2008-09-24 fixed the issue of "$BITMAP should be non-resident when in attribute list" in fsys_ntfs.c.
+2008-09-23 fixed virtual cdrom sector read issue(64K at a time) for a non-mem mapping.
+2008-09-21 added a new command "tpm --init".
+2008-09-21 fixed memory conflicts between graphics mode and linux kernel.
+2008-09-20 fixed a serious problem in grldrstart causing boot failure on FAT.
+2008-09-19 fixed a new bug intrduced last in get_diskinfo.
+2008-09-15 fixed a problem when different action occurs on a drive between chs and lba.
+2008-09-13 fixed a problem of reentering int13 handler from a virtual device on a real cdrom device driven by the builtin cdrom driver.
+2008-09-12 fixed an issue of whole cdrom mapping.
+2008-09-09 fixed virtual cdrom sector read issue when it is not a mem-mapping.
+2008-09-07 title delimitors(or comments) can be used in menu now.
+2008-08-27 save stack space occupation by the int13_handler.
+2008-08-26 fixed a bug relevant to iso emulation, causing disk read error.
+2008-08-24 save stack space occupation by the int13_handler.
+2008-08-14 enlarged stage2 stack space.
+2008-08-13 fixed again the bug on the root command.
+2008-08-12 fixed int5 in probe_int.
+2008-08-10 added a new command checkrange; fixed a bug on the root command.
+2008-08-08 added builtin stack for int13_handler to avoid stack overflow.
+2008-08-06 fixed a suspicious problem on the SCRATCH buffer in get_diskinfo.
+2008-08-04 fixed again error handling problem about operator && and ||; added STIs to better respond hardware interrupt.
+2008-08-03 fixed error handling problem about operator && and ||; grldr.mbr structure change; other small alterations.
+2008-07-28 added STIs to better respond hardware interrupt or to feed watchdog.
 2008-07-10 let KEY_UP(KEY_DOWN) loop to the last(first) menu entry.
 2008-07-06 added backup_int13 and restore_int13 for a buggy usb bios f24a ver 1.00parttbl on compaq v5235tu(reporter: uleak). turn a20 debug on for memdrives.
 2008-06-28 fixed ext3-inode-size issue in grldr boot sector and bootlace.inc.
