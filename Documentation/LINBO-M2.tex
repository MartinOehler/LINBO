\documentclass[ngerman,a4paper,12pt]{article}

%%% Makros

\def\kdo#1{\textbf{\texttt{#1}}}
\def\myurl#1{\href{#1}{\kdo{#1}}}

\usepackage{ngerman, isolatin1, times, courier, graphicx, hyperref, color}

\definecolor{darkgreen}{rgb}{0,0.5,0}
% \hypersetup{colorlinks,urlcolor=darkgreen,linkcolor=darkgreen}
\hypersetup{colorlinks}

\parindent0pt
\parskip2mm

\begin{document}
\title{\Huge LINBO\\\LARGE Linux-basiertes Interaktives Netzwerk-Bootsystem}
\author{Klaus Knopper}
\date{10.05.2007}
\maketitle

\newpage

\tableofcontents

\newpage

\listoffigures

\newpage

\section{Einführung}

LINBO ist ein halb- bis vollautomatisch (je nach Konfiguration) arbeitender Bootmanager, der nicht nur in der Lage ist, verschiedene Betriebssysteme von Festplatte zu starten, sondern der auch Wartungs-, Update- und Reparaturfunktionen für Festplatteninstallationen übernimmt.

\subsection{Funktionsweise}

\begin{figure}[h!bt]
\centerline{\includegraphics[width=0.75\textwidth]{pics/linbo-booting.pdf}}
\caption{UML Aktivitätsdiagramm für LINBO}\label{fig:linbouml}
\end{figure}

Vom Bootlader (lilo oder PXE/Bootp-Server) werden Kernel und initiales Ram-Dateisystem geladen und gestartet. Nach normalerweise recht kurzer Startzeit wird eine graphische Oberfläche, \kdo{linbo\_gui} mit Auswahlmöglichkeit präsentiert, während parallel dazu die Hardwareerkennung von Netzwerkkarten und Festplatten läuft. Nach Auswahl eines Buttons werden verschiedene Aktionen über das Worker-Backend-Skript \kdo{linbo\_cmd} abgewickelt.

\subsection{Testlauf in \kdo{qemu}}

(Installation in einer richtigen DHCP-Server-Umgebung: Siehe Abschnitt~\ref{dhcpconf}.)

Das zentrale \kdo{Makefile} im LINBO-Entwicklungsverzeichnis bietet drei Testszenarien mit
Hilfe von \kdo{qemu} als virtuelle Machine(n):

\begin{tabular}{lp{10cm}}
\kdo{make test} & Direktes Booten von LINBO-Kern und Start des internen TFTP-Servers (Directory "`Images"')\\
\kdo{make hdtest} & Booten von simulierter Festplatte \kdo{Images/hda.img}\\
\kdo{make pxetest} & Booten per PXE von einem durch qemu simulierten PXE-Server\\
\end{tabular}

Für die zuletzt genannte Option ist die Installation von qemu ab Version
0.9.0+cvs erforderlich, da frühere Versionen den "`bootp"'-Parameter noch
nicht kannten.

\subsection{Namen und Beschreibungen}

\subsubsection{Cache-Partition}
Auf den mit LINBO verwalteten Rechnern wird eine \label{cache}Cache-Partition verwendet, um LINBO selbst und die verwalteten Betriebssysteme lokal vorzuhalten, und auch ohne Netzwerk starten zu können.

\subsubsection{Multicast}
Der von LINBO verwendete TFTP-Client \kdo{atftp} zum Download von Images ist multicast-fähig, d.h. es ist möglich, dass mehrere Clients Daten von einem gemeinsamen Stream vom Server gleichzeitig beziehen, wodurch die Netzwerk-Auslastung gerade bei parallelen Installationen dramatisch reduziert werden kann. Hierfür ist allerdings ein ebenfalls multicast-fähiger TFTP-Server, z.B. \kdo{atftpd} erforderlich.

\subsubsection{PXE}\label{pxe}
"`Pre Execution Environment"' bezeichnet eine standardisierte Methode, ein Bootmenü oder Betriebssystem übers Netzwerk zu laden und zu starten. Hierfür ist entweder eine PXE-fähige Netzwerkkarte erforderlich, oder eine ensprechende Bootdiskette mit Treiber von \myurl{http://www.rom-o-matic.net}.

\newpage

\section{Installation}
LINBO wird üblicherweise per PXE gebootet, und kann sich selbst auf die Cache-Partition (\ref{cache}) kopieren.
\subsection{Bootvorgang}
LINBO kann wie ein normaler Linux-Kernel gebootet werden, unabhängig ob von lokaler Festplattenpartition oder einem PXE/BOOTP-fähigen DHCP-Server.

Aus technischen Gründen\footnote{Es hat sich in Tests gezeigt, dass einige Netzwerkkarten keine Einzeldateien größer 8MB per TFTP beziehen können, außerdem ist der absolute Adressraum für den Kernel auf wenige MB begrenzt} ist LINBO aufgesplittet in einen Kernel-Teil \kdo{linbo} (ca. 3MB komprimiert), und einen Dateisystem-Teil \kdo{linbofs.gz} (ca. 8MB komprimiert), wobei der Kernelteil auch ein kleines Dateisystem mit \kdo{busybox} als Minimalshell, und der Dateisystem-Teil die größeren Programme und Tools wie \kdo{linbo\_gui}, Systembibliotheken, und die Initialkonfiguration \kdo{start.conf} enthält.

\newpage

\section{Anwenderhandbuch}

\subsection{LINBO booten}
LINBO kann sowohl übers Netz per PXE (\ref{pxe}) als auch von einer bereits mit LINBO installierten Festplatte gestartet werden. Die Installation eines Bootservers für LINBO ist unter~\ref{bootserver} beschrieben, die Installation des LINBO-Bootladers auf Festplatte unter~\ref{bootdisk}.

\begin{figure}[h!bt]
\centerline{\includegraphics[scale=0.33]{pics/linbo-pxelinux.png}}
\caption{PXE-Bootlader in qemu}\label{fig:pxelinux}
\end{figure}

LINBO besteht aus einen Kernel- und einem Dateisystem-Teil, die separat geladen und anschließend automatisch im Hauptspeicher zusammengesetzt werden. Nach einer minimalen Hardwareerkennung (i.e. Grafikkarte) durch den Kernel, wird die graphische Oberfläche von LINBO, \kdo{linbo\_gui}, gestartet.

\begin{figure}[h!bt]
\centerline{\includegraphics[scale=0.33]{pics/linbo-pxe-bootscreen.png}}
\caption{Start von LINBO über pxelinux}\label{fig:pxeboot}
\end{figure}

Hinweis: Da parallel zum Start der Oberfläche eine weitere Hardwareerkennug stattfindet (Netzwerk, Festplattencontroller und -partitionen), stehen einige LINBO-Funktionen erst nach einigen Sekunden zur Verfügung. Normalerweise ist das vom GUI aufgerufene \do{linbo\_cmd} Worker-Backend aber so intelligent, dass es bei noch nicht erkannten Festplattenpartitionen einige Zeit wartet, bis diese verfügbar sind.

\subsection{Graphische LINBO Oberfläche}

\subsubsection{Betriebssysteme wiederherstellen und starten}

Abbildung~\ref{fig:linbostart} zeigt das Startmenü von LINBO. Hier sind alle Betriebssysteme, die für LINBO vorbereitet und auf Festplate installiert wurden, aufgeführt.

\begin{figure}[h!bt]
\centerline{\includegraphics[scale=0.33]{pics/linbo-start.png}}
\caption{Startmenü von LINBO}\label{fig:linbostart}
\end{figure}


Mit Klick auf \kdo{Synchronisieren} hinter dem Namen des Betriebssystems, wird das auf einer Partition befindliche System mit Hilfe eines auf der Cache-Partition (\ref{cache}) befindlichen Archivs überschrieben bzw. in den Ursprungszustand versetzt. \textsl{Achtung: Hierbei gehen alle Änderungen, die in der letzen Session mit diesem Betriebssystem erstellt wurden, verloren.}

\kdo{Neu aufsetzen} (Abbildung~\ref{fig:osnew}) lädt eine ggf.\ neuere Version des jeweiligen Betriebssstems vom Server per TFTP/Multicast auf die Cache-Partition herunter, und installiert diese anschließend wie bei \kdo{Synchronisieren}.

\begin{figure}[h!bt]
\centerline{\includegraphics[scale=0.33]{pics/linbo-neu-done.png}}
\caption{Neu aufsetzen eines Betriebssystems mit LINBO}\label{fig:osnew}
\end{figure}

\kdo{Start} bootet das angegebene Betriebssystem so, wie es sich derzeit auf der Festplatte befindet. Der Rechner startet hierbei nicht neu, sondern LINBO führt einen "`Soft-Reboot"' durch, was den Startvorgang stark beschleunigt. Treten beim Starten Fehler auf, oder befindet sich das installiere Betriebssystem nicht mehr in einem benutzbaren Zustand, so sollte nach dem nächsten Reboot mit Hilfe von \kdo{Synchronisieren} oder \kdo{Neu aufsetzen} wieder der zuletzt gespeicherte, arbeitsfähige Zustand restauriert werden, bevor ein neuer \kdo{Start} versucht wird.

Abbildung~\ref{fig:osboot} zeigt ein Mini-Linux, das durch LINBO gestartet wurde.

\begin{figure}[h!bt]
\centerline{\includegraphics[scale=0.33]{pics/linbo-os-booted.png}}
\caption{Aus LINBO gestartetes Mini-Linux}\label{fig:osboot}
\end{figure}

\subsubsection{Betriebssystem-Images verwalten}

Die "`Reiter"' hinter dem Startmenü sind für die Verwaltung von Images (Archiven) der installierten oder zu installierenden Betriebssysteme zuständig. Hier können verschiedene Versionen eingespielt werden, die inkrementell auf einem Basis-Image aufbauen.

\begin{figure}[h!bt]
\centerline{\includegraphics[scale=0.33]{pics/linbo-neu.png}}
\caption{Neu aufsetzen - Dekompressionsvorgang}\label{fig:osnewwait}
\end{figure}

Gegenüber "`Synchronisieren"' und "`Neu aufsetzen"' aus dem Startmenü erlauben die gleichnamigen Buttons in den Betriebssystem-Reitern also eine genauere Angabe der jeweiligen Version, während im Startmenü immer nur die neuste Version restauriert wird.

\subsubsection{Alles neu -- Administrationsmenü}

Um die Festplatte nach den Vorgaben des Administrators zu partitionieren, die Partitionen zu formatieren und sämtliche angebotenen Images auf der Cache-Partition abzulegen, sowie LINBO bootfähig auf Festplatte zu installieren, ist der Reiter \kdo{Admin} und die darunter vorhandenen Buttons zuständig.\label{bootdisk}

\begin{figure}[h!bt]
\centerline{\includegraphics[scale=0.33]{pics/linbo-admin.png}}
\caption{Admin-Menü}\label{fig:admin}
\end{figure}

Bitte beachten Sie, dass beim Neupartitionieren und Formatieren der Festplatte sämtliche dort gespeicherten Daten verloren gehen.

\newpage

\section{Administration}
\subsection{Konfiguration}
\subsubsection{\kdo{start.conf} - Partitionen und Images}
Die im \kdo{linbofs.gz} für jeden Client-Rechner befindliche Datei \kdo{start.conf} ist im Stil der bekannten KDE-Desktop-Iconbescreibungen verfasst. Kommentare werden durch \kdo{\#} eingeleitet, dürfen
am Anfang einer Zeile oder mitten im Text aufauchen, und werden inklusive bis zum Zeilenende folgendem ext von \kdo{linbo\_gui} ignoriert.

Eine Beispieldatei, die sich im Buildsystem in \kdo{Binaries/linbo\_gui/start.conf} befindet, ist hier angegeben.

\begin{scriptsize}
\begin{verbatim}
[LINBO]                 # LINBO global config
Cache = /dev/hda2       # Cache Partition with local Images
Server = 10.0.2.2       # First TFTP Server with remote Images

[Partition]             # Start of a Partition config section
Dev = /dev/hda1         # Device name of partition (hda1 = first partition on first IDE disk)
Size = 100000           # Partition size in kB
Id = 6                  # Partition type (83 = Linux, 82 = swap, c = FAT32, 6 = NTFS, ...)
FSType = ntfs           # File system on Partition
Bootable = yes          # Mark this partition as bootable

[Partition]
Dev = /dev/hda2         # Device name of partition
Size = 100000           # Partition size in kB
Id = 83                 # Partition type (83 = Linux, 82 = swap, c = FAT32, ...)
FSType = reiserfs       # File system on Partition
Bootable = no           # Mark this partition as non-bootable (or Linux)

[Partition]
Dev = /dev/hda3         # Device name of partition
Size = 512              # Partition size in kB
Id = 82                 # Partition type (83 = Linux, 82 = swap, c = FAT32, ...)
FSType = swap           # File system on Partition

[Partition]
Dev = /dev/hda4         # Device name of partition
Size =                  # Partition size in kB (empty if "remaining space")
Id = 5                  # Partition type (5 = Extended)
FSType =                # File system on Partition (none for extended partition)
Bootable = no           # Mark this partition as non-bootable (or Linux)

[Partition]
Dev = /dev/hda5         # Device name of partition
Size = 10000            # Partition size in kB
Id = 83                 # Partition type (83 = Linux, 82 = swap, c = FAT32, ...)
FSType = ext2           # File system on Partition
Bootable = no           # Mark this partition as non-bootable (or Linux)

[Partition]
Dev = /dev/hda6         # Device name of partition
Size = 500000           # Partition size in kB
Id = 83                 # Partition type (83 = Linux, 82 = swap, c = FAT32, ...)
FSType = reiserfs       # File system on Partition
Bootable = no           # Mark this partition as non-bootable (or Linux)

[OS]
Name = Mini-Knoppix The Ultimate          # Name of OS
Version = 5.2           # Version/Date of OS (optional)
Description = 01.02.2007, 7:10 Standardinstallation # Descriptive Text
Image = miniknoppix.tar.gz # Filename of (incremental?) tar archive or partition image
BaseImage  = # Filename of base tar archive or base partition image (optional)
Timestamp = 200705102307 # Timestamp of image creation
Boot = /dev/hda5        # Partition containing Kernel & Initrd
Root = /dev/hda5        # root=/dev/partition Parameter (Root FS)
Kernel = vmlinuz        # Relative filename of Kernel or Boot image
Initrd =                # Relative filename of Initrd
Append =                # Kernel cmdline, root= will be added (optional)
StartEnabled = yes      # Enable "Start" Button
SyncEnabled = yes       # Enable "Synchronize" Button
RemoteSyncEnabled = yes # Enable "Synchronize from Server" Button

[OS]
Name = Windows Visa     # Name of OS
Description = 06.02.2007, 10:10 Es bootet.                       # Descriptive Text
Version = 1             # Version/Date of OS (optional)
Image = visa-20070206.tar.gz # Filename of (incremental?) tar archive or partition image
BaseImage  = visa.img.gz # Filename of base tar archive or base partition image (optional)
Timestamp = 200705102307 # Timestamp of image creation
Boot = /dev/hda1        # Partition containing Kernel & Initrd
Root = /dev/hda1        # root=/dev/partition Parameter (Root FS)
Kernel = grub.exe       # Relative filename of Kernel or Boot image
Initrd =                # Relative filename of Initrd
Append = --config-file=map(rd) (hd0,0); map --hook; chainloader (hd0,0)+1; rootnoverify(hd0,0) --device-map=(hd0) /dev/hda # grub.exe cmdline
StartEnabled = yes      # Enable "Start" Button
SyncEnabled = yes       # Enable "Synchronize" Button
RemoteSyncEnabled = yes # Enable "Synchronize from Server" Button

[OS]
Name = Ubuntu           # Name of OS
Version = 1             # Version/Date of OS (optional)
Description = 01.02.2007, 7:10 Standardinstallation # Descriptive Text
Image = ubuntu-1.tar.gz  # Filename of (incremental?) tar archive or partition image
BaseImage  = ubuntu.tar.gz # Filename of base tar archive or base partition image (optional)
Timestamp = 200705102307 # Timestamp of image creation
Boot = /dev/hda6        # Partition containing Kernel & Initrd
Root = /dev/hda6        # root=/dev/partition Parameter (Root FS)
Kernel = boot/vmlinuz   # Relative filename of Kernel or Boot image
Initrd = boot/initrd.gz # Relative filename of Initrd
Append =                # Kernel cmdline, root= will be added (optional)
StartEnabled = no       # Enable "Start" Button
SyncEnabled = no        # Enable "Synchronize" Button
RemoteSyncEnabled = yes # Enable "Synchronize from Server" Button

[OS]
Name = Ubuntu           # Name of OS
Version = 2             # Version/Date of OS (optional)
Description = 02.02.2007, 7:10 Standardinstallation mit xemacs   # Descriptive Text
Image = ubuntu-2.tar.gz  # Filename of (incremental?) tar archive or partition image
BaseImage  = ubuntu.tar.gz # Filename of base tar archive or base partition image (optional)
Timestamp = 200705110201 # Timestamp of image creation
Boot = /dev/hda6        # Partition containing Kernel & Initrd
Root = /dev/hda6        # root=/dev/partition Parameter (Root FS)
Kernel = boot/vmlinuz   # Relative filename of Kernel or Boot image
Initrd = boot/initrd.gz # Relative filename of Initrd
Append =                # Kernel cmdline, root= will be added (optional)
StartEnabled = yes      # Enable "Start" Button
SyncEnabled = yes       # Enable "Synchronize" Button
RemoteSyncEnabled = yes # Enable "New from Server" Button
\end{verbatim}
\end{scriptsize}

Auffällig dürfte sein, dass im \kdo{[OS]}-Abschnitt Namen von
Betriebssystemen mehrfach genannt werden dürfen, wobei die nachfolgenden
Einstellungen und Image-Namen dann als Versionspaket dieses
Betriebssystems interpretiert werden, und in den einzelnen Reitern
für die Betriebssysteme im \kdo{linbo\_gui} als Subversionen auftauchen.

\subsubsection{PXE-Konfiguration (DHCP-Server)}\label{bootserver}

\label{dhcpconf}
LINBO-Kernel, LINBO-Dateisystem und LINBO-Images müssen sich in einem
per TFTP erreichbaren Verzeichnis auf dem Server befinden. Ein
klassischer Name für dieses Verzeichnis ist auf vielen Unix-Systemen
\kdo{tftpboot}. Der für LINBO empfohlene TFTP-Server \kdo{atftpd} könnte
dementsprechend auf dem Server wie folgt gestartet werden:

\begin{bf}
\begin{verbatim}
sudo atftpd -daemon --port 69 --retry-timeout 5 \
     --mcast-port 1758 --mcast-addr 239.239.239.0-255 \
     --mcast-ttl 1 --maxthread 100 --verbose=5 \
     /tftpboot
\end{verbatim}
\end{bf}

Im DHCP-Server sind dann die Clients bzw. Client-Netze anzugeben, die per LINBO verwaltet werden sollen. Optional können für verschiedene Rechner auch entsprechend verschiedene \kdo{linbofs.gz} in der Konfiguration von \newline
\kdo{pxelinux.cfg/CLI\-ENT-ADRE\-SSE} angegeben werden, in denen sich jeweils eine andere \kdo{start.conf}-Konfigurationsdatei befinden kann.\footnote{Später wird diese Konfiguration ein graphisches Verwaltungstool mit übernehmen helfen.}

Beispiel für einen entsprechenden Abschnit aus der \kdo{dhcpd.conf} des ISC-dhcpd Version 3:

\begin{verbatim}
allow booting;
allow bootp;

subnet 10.0.2.0 netmask 255.255.255.0 {
  next-server 10.0.2.2;
  filename "pxelinux.0";
  option subnet-mask 255.255.255.0;
  range 10.0.2.10 10.0.2.15;
  option domain-name-servers 10.0.2.2;
  option routers 10.0.2.2;
}
\end{verbatim}

In diesem Beispiel werden die IP-Adressen 10.0.2.10 bis einschließlich 10.0.2.15 dyamisch vergeben, die Clients starten per TFTP den PXE-Bootlader \kdo{pxelinux.0}, der seine Konfigurationsdatei unter \kdo{pxelinux.cfg/default} nachlädt. LINBO-Kern und Images müssen ebenfalls per TFTP erreichbar sein.

\textsl{Hinweis:} Üblicherweise fügen die Clients ein Pfad-Präfix \kdo{/} zum Dateinamen hinzu, daher sollte für Testzwecke mit

\begin{center}
\kdo{atftp -r /linbo -l linbo 10.0.2.2}
\end{center}

getestet werden, ob der LINBO-Kern über den TFTP-Server erreichbar ist, zumal ohne führenden \kdo{/} der TFTP-Server mitunter mit einem Fehler antwortet, statt die im TFTP-Exportverzeichnis liegenden Dateien zu liefern. V.a. der qemu-interne TFTP-Server zeigt dieses Verhalten.

\newpage

\section{LINBO-Buildsystem}
\subsection{Systemvoraussetzungen}

\begin{enumerate}
\item Installiertes POSIX-konformes Betriebssystem mit Bourne-kompatibler
  Shell (z.B. Debian "`etch"'). Cygwin sollte auch evtl. auch funktionieren, mit Linux-Crosscompiler.

\item GNU-Tar (zum Entpacken das Archives)

\item GNU-Make

\item GNU C-Compiler Version 3 oder höher

\item GNU-Binutils (zum Compilieren verschiedener Kernel-Komponenten notwendig)

\item Root-Rechte sind zum Bauen von LINBO NICHT erforderlich.
  Das Kernel-Buildsystem sorgt dafür, dass die Dateien im initramfs die
  erforderlichen Rechte erhalten, und dass auch Device-Dateien korrekt angelegt werden,
  daher kann als normaler User am System gearbeitet werden.

\item Zum Testen/Debuggen: qemu Version 0.9.0+cvs oder höher (-bootp Option erforderlich für
simulierten PXE-Boot).
\end{enumerate}

Der Bau von LINBO wird durch ein Makefile im LINBO-Verzeichnis gesteuert.
\kdo{make} ohne Parameter liefert eine Kurzhilfe. Die einzelnen Schritte
des Bauvorgangs sind recht selbsterklärend.

\subsection{Verzeichnisse}

\kdo{Binaries} enthält statische Binaries sowie dynamische Executables und
Libraries für das initramfs. Die \kdo{Binaries/*.sh}-Dateien sind
Shellskripte, die in LINBO den Bootvorgang und das GUI steuern.

Die für LINBO benötigten Dateien und Libraries werden in den Dateien\newline
\kdo{Kernel/initramfs\_kernel.d/*.conf} sowie \newline
\kdo{Kernel/initramfs.d/*.conf} verwaltet.  Dort sind auch neu
hinzugefügte Dateien einzutragen, wenn sie in das initramfs aufgenommen
werden sollen.

Das Verzeichnis \kdo{Graphics} enthält die Quellen des LINBO-Logos
Binaries/linbo.xpm, das im GUI dargestellt wird, sowie den
Desktop-Hintergrund und das PXE-Bootbild für LINBO. Diese Dateien werden
nicht direkt in \kdo{Graphics} verwendet, sondern müssen bei Bedarf nach
\kdo{Images} kopiert werden.

\kdo{GUI} enthält die Sourcen für \kdo{linbo\_gui}, LINBOs graphische Oberfläche, sowie
embedded Qt als Abhängigkeit.

\kdo{Documentation} wird später das Benutzer- und Administrationshandbuch
von LINBO enthalten (dieses Dokument).

\kdo{Kernel} enthält den für LINBO verwendeten Linux-Kernel-Source. Wenn
dieser aktualisiert wird, sollte die alte .config-Datei weiterverwendet
werden, da sie die für das initramfs notwendigen Einstellungen enthält.

\kdo{Images} enthält den fertig gebauten LINBO-Kernel \kdo{linbo} als
Hardlink auf Kernel/linux-*/arch/i386/boot/bzImage, \kdo{linbofs.gz} als
zusätzliches initramfs mit den größeren Dateien, sowie den PXE-Bootlader
\kdo{pxelinux.0}, Images und Archive zur
Installation von LINBO und den gewünschten Betriebssystemen auf den
Clients.

\kdo{Sources} ist ein Archiv der für die gebauten Binaries verwendeten
Quelltexte, um die Binaries selbst neu bauen zu können, und die GNU
GENERAL PUBLIC LICENSE §3 zu erfüllen. Für das Buildsystem ist das
Verzeichnis eigentlich irrelevant, da es im Makefile nicht verwendet
wird. Neu integrierte Programme sollten jedoch gewissenhaft in Sources
archiviert werden (Debian: \kdo{cd Sources ; apt-get source paketname}).

\subsection{Bauvorgang}

Durch "`\kdo{make}"' ohne Parameter dokumentiert:

\begin{footnotesize}
\begin{bf}
\begin{verbatim}
WELCOME TO THE LINBO BUILD SYSTEM

make kernel	(Re-)Build Kernel and Modules (recommended before "make linbo")
make linbo	(Re-)Build LINBO-Kernel and LINBO-FS
make config	Configure LINBO kernel and edit LINBO filesystem.
make clean	Cleanup LINBO kernel source for recompilation.
make test	Run LINBO kernel in qemu
make hdtest	Run LINBO from a harddisk-installed LINBO session
make pxetest	Run LINBO in a qemu simulated PXE network boot
            	(qemu 0.9.0+cvs version required that supports '-bootp')

Don't worry about the sequence of build commands, this Makefile will tell you
what to do first, in case anything is missing.

Have a lot of fun. ;-)
\end{verbatim}
\end{bf}
\end{footnotesize}
\end{document}

GNU/Linux Network Boot System
=============================

(Stand: Milestone 1, 28.07.2006)

LINBO Kernel
------------

LINBO besteht in der aktuellen Version aus einem projektintern "BBBB" *)
getauften Binary File, das bootfähig komprimiert den eigentlichen
Linux-Kernel, sowie ein initramfs mit allen eingebetteten Programmen
(teils statisch gelinkt, teils dynamisch mit integrierten Libraries)
enthält.

Der BBBB kann wie ein normaler Linux-Kernel gebootet werden, z.B.:
- "Raw" auf einer Festplattenpartition, die per MBR oder BIOS-Einstellung
  gebootet wird,
- Auf bootfähigen Memorystick mit dd kopiert (dd if=LINBO.bin of=/dev/sda),
- Per PXE als Bootkernel (ohne initrd!) exportiert,
- Im Emulator gebootet, siehe "Testing".

Kernel Version ist 2.6.17.6 (die derzeit verfügbare stabile
Kernel-Version), ohne Patches. Die Knoppix-spezifischen Module cloop und
unionfs wurden nicht verwendet, da sie auf dem ohnehin schreibbaren und
komprimierten initramfs nicht gebraucht werden.

*) BBBB = "Big Bad Binary Blob", der Name resultiert aus der Tatsache,
dass sämtliche Linbo-Komponenten (bis auf die, die in Phase 2 bzw. vom
Server nachgeladen werden), in einer einzigen komprimierten Binärdatei
vorhanden sind, was das Handling sehr einfach macht.

Testing
-------

LINBO.bin kann wie ein normaler Linux-Kernel, mit oder ohne
Kernel-Parameter, mit den üblichen Methoden gebootet werden.

Um das Booten von Linux aus LINBO heraus zu testen, ist ein
Harddisk-Image für vmware bzw. qemu im Buildsystem mitgeliefert, das
drei Partitionen (DOS, Linux, Linux) mit zwei bootfähigen
Linux-Minisystemen enthält, eins mit und eins ohne innitrd. Diese werden
in der LINBO-Oberfläche aufgelistet und per Klick gebootet.

Mit folgender qemu(0.8)-Kommandozeile haben wir LINBO mit dem mitgelieferten
HD-Image getestet:

qemu -hda hda.img -net nic -kernel LINBO.bin

Per Makefile im LINBO-Buildsystem (siehe LINBO-Buildsystem) funktioniert dies
mit

make test

Funktionen in Milestone/Phase 1
-------------------------------

erreichte Ziele:

- Hardwareerkennung zunächst nur per Kernel (Festplatten, Netzwerk)

- Starten von X (Xorg Version 7.0.22) und LINBO-GUI mit Mausunterstützung
  ("standard" PS/2 und USB/IMPS2-Mäuse sollten automatisch erkannt werden)

- Scannen von lokalen Partitionen, Suche nach bootfähigen Kernels
  (bei Windows: grub4dos.exe, noch nicht getestet)

- Auswahl einer Partition, Booten des dort installierten Kernels per kexec.

- Zu Debugging-Zwecken wird in Phase 1 unterhalb des LINBO-GUI eine
Root-Shell-Konsole geöffnet, in der die Bourne-Shell-kompatible Busybox
läuft. Dieses Feature wird in der Endversion entfernt bzw. als
"Admin-only" zuschaltbar gemacht.

TODO (Phase 2-3):

- Deutsches Tatstaturlayout für Konsole und X. Eigentlich wird die
Tastatur nicht gebraucht, da das GUI Mausgesteuert wird. Für die
Debug-Konsole und die spätere Lauffähigkeit im alternativen Textmodus
(Accessibility) sollte die Tastatur aber auf das gewünschte Layout
einstellbar sein.

- Mehrsprachigkeit: Die in LINBO verwendeten Texte und Online-Hilfe ist
derzeit komplett in deutscher Sprache konfiguriert. In Hinblick auf
Integration in internationale Projekte (z.B. Skolelinux,
Minerva-EU-Projekt etc.) sollte die Oberfläche jedoch auch zumindest in
Englisch konfigurierbar sein. Das Buildsystem und die Kommentare in den
Quellen sind bereits in englischer Sprache verfasst, da die Endbenutzer
damit gar nicht in Kontat kommen.

- Geschwindigkeit: Da in dieser Testversion sämtliche Treiber im
LINBO-Kernel monolithisch integriert sind dauert die reine
Hardwareerkennung verhleichsweise lange, während das Starten des
X-Servers und der Aufbau der Oberfläche überraschenderweise kaum mehr
als eine Sekunde in Anspruch nimmt. Im qemu auf einem Pentium 4 / 1200
MHz dauert das Booten vom Laden des Kernels bis in die graphische
Oberfläche ca. 12 Sekunden, was von uns als viel zu langsam angesehen
wird. Wenn die Treiber für Festplatten und Netz in Phase 2 modular
während dem Start des GUI zur Laufzeit nachgeladen werden, und der
Kernel selbst NUR die SVGA-Unterstützung enthält, sollte sich die
Bootzeit bis zur GUI-Darstellung drastisch verkürzen. Wir streben 5-6
Sekunden vom Start des Kernels bis zum GUI an.

- Windows-Boot (hierfür ist eine kleine Windows-Testinstallation mit
integriertem grub4dos erforderlich, Martin Öhler arbeitet dran).

- Netzwerkanbindung an den Server und Übergabemöglichkeit für Parameter
(z.B. mit einer in LNBO.bin integrierten Liste, die durch die vom
DHCP-Server vergebene IP-Adresse für diesen Rechner, oder die MAC der
Netzwerkkarte, aktiviert wird).

- Reparaturfunktion
  
  - aus dem Cache

  - vom Server

Experimente für später:

- Kleiner Window-Manager? Evtl. unnötig, da sich in der derzeitigen
Oberfläche keine Fenster überlagern können, aber Menüfunktion möglich.

- Neu programmierte QT-Oberfläche für die Partitionsauswahl?

- Integration eines graphischen Partitionierungsprogramms zur
interativen Partitionierung?

- Kleiner Browser als Option, um LINBO auch als "standalone-Surfsystem"
laufen lassen zu können, ohne Betriebssystem auf Platte?


LINBO-Buildsystem
-----------------

Systemvoraussetzungen:

- Installiertes POSIX-konformes Betriebssystem mit Bourne-kompatibler
  Shell (Cygwin sollte auch funktionieren)

- GNU-Tar (zum Entpacken das Archives)

- GNU-Make

- GNU C-Compiler Version 3.x oder höher

- GNU-Binutils (zum Compilieren verschiedener Kernel-Komponenten notwendig)

- Root-Rechte sind zum Bauen von LINBO NICHT erforderlich.
  Das Kernel-Buildsystem sorgt dafür, dass die Dateien im BBBB die
  erforderlichen Rechte erhalten, und dass Device-Dateien korrekt angelegt werden,
  daher kann als normaler User am System gearbeitet werden.

Der Bau des BBBB wird durch ein Makefile im LINBO-Verzeichnis gesteuert.
"make" ohne Parameter liefert eine Kurzhilfe. Die einzelnen Schritte
des Bauvorgangs sind recht selbsterklärend.

Verzeichnisse:

"Binaries" enthält statische Binaries sowie dynamische Executables und
Libraries für das initramfs. Die Binaries/*.sh-Dateien sind
Shellskripte, die in LINBO den Bootvorgang und das GUI steuern. Die für
LINBO benötigten Dateien und Libraries werden per initramfs.conf
(Verzeichnis "Kernel") verwaltet. Dort sind auch neu hinzugefügte
Dateien einzutragen, wenn sie in das initramfs/BBBB aufgenommen werden
sollen.

"Graphics" enthält die Quellen des LINBO-Logos Binaries/linbo.xpm, das
im GUI dargestellt wird.

"Documentation" wird später das Benutzer- und Administrationshandbuch
von LINBO enthalten.

"Kernel" enthält den für LINBO verwendeten Linux-Kernel-Source. Wenn
dieser aktualisiert wird, sollte die alte .config-Datei weiterverwendet
werden, da sie die für das initramfs notwendigen Einstellungen enthält.
Innerhalb der Kernel-Quellen in Kernel/linux-2.6.17.6 ist initramfs ist
ein Symlink auf das "Binaries"-Verzeichnis, initramfs.conf ein Symlink
auf initramfs.conf im Kernel-Verzeichnis, womit das
initramfs-Dateisystem verwaltet wird.

"Images" enthält den fertig gebauten LINBO-Kernel als Hardlink auf
Kernel/linux-*/arch/i386/boot/bzImage, sowie evtl. in Phase 2 Bootimages
und Archive für verschiedene Datenträger zur Installation von LINBO auf
dem Bootserver.

"Sources" ist ein Archiv der für die gebauten Binaries verwendeten
Quelltexte, um die Binaries selbst neu bauen zu können, und die GNU
GENERAL PUBLIC LICENSE §3 zu erfüllen. Für das Buildsystem ist das
Verzeichnis eigentlich irrelevant, da es im Makefile nicht verwendet
wird. Neu integrierte Programme sollten jedoch gewissenhaft in Sources
akchiviert werden (Debian: cd Sources ; apt-get source paketname).

Bauvorgang:

Durch "make" ohne Parameter dokumentiert:

knopper@Koffer:/mnt/knoppix.build/LINBO$ make
---
WELCOME TO THE LINBO BUILD SYSTEM

make linbo      (Re-)Compile a LINBO-Kernel
make config     Configure LINBO kernel and edit LINBO filesystem.
make clean      Cleanup LINBO kernel source for recompilation.
make test       Run LINBO in qemu
(That's all we do, for now.)

Don't worry about the sequence of build commands, this Makefile will tell you
what to do first, in case anything is missing.

Have a lot of fun. ;-)
---
